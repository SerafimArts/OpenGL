<?php

/**
 * This file is part of OpenGL package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * MACHINE GENERATED FILE, DO NOT EDIT
 */

declare(strict_types=1);

namespace Serafim\OpenGL;

/**
 * The OpenGL functionality up to version 3.3. Includes the deprecated symbols of the Compatibility Profile.
 *
 * OpenGL 3.3 implementations support revision 3.30 of the OpenGL Shading Language.
 *
 * Extensions promoted to core in this release:
 *
 * - ARB_shader_bit_encoding @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_shader_bit_encoding.txt
 * - ARB_blend_func_extended @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_blend_func_extended.txt
 * - ARB_explicit_attrib_location @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_explicit_attrib_location.txt
 * - ARB_occlusion_query2 @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_occlusion_query2.txt
 * - ARB_sampler_objects @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_sampler_objects.txt
 * - ARB_texture_rgb10_a2ui @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_texture_rgb10_a2ui.txt
 * - ARB_texture_swizzle @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_texture_swizzle.txt
 * - ARB_timer_query @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_timer_query.txt
 * - ARB_instanced_arrays @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_instanced_arrays.txt
 * - ARB_vertex_type_2_10_10_10_rev @see https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_vertex_type_2_10_10_10_rev.txt
 */
class GL33 extends GL32
{
    /**
     * @var int
     * @since 3.3
     */
    public const GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88fe;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_SRC1_COLOR = 0x88f9;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_ONE_MINUS_SRC1_COLOR = 0x88fa;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_ONE_MINUS_SRC1_ALPHA = 0x88fb;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88fc;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_ANY_SAMPLES_PASSED = 0x8c2f;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_SAMPLER_BINDING = 0x8919;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_RGB10_A2UI = 0x906f;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TEXTURE_SWIZZLE_R = 0x8e42;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TEXTURE_SWIZZLE_G = 0x8e43;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TEXTURE_SWIZZLE_B = 0x8e44;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TEXTURE_SWIZZLE_A = 0x8e45;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TEXTURE_SWIZZLE_RGBA = 0x8e46;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TIME_ELAPSED = 0x88bf;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_TIMESTAMP = 0x8e28;
    /**
     * @var int
     * @since 3.3
     */
    public const GL_INT_2_10_10_10_REV = 0x8d9f;

    /**
     * Specifies that the varying out variable *`name`* in *`program`* should be bound to fragment color
     * *`colorNumber`* when the program is next linked. *`index`* may be zero or one to specify that the color be
     * used as either the first or second color input to the blend equation, respectively.
     *
     * The bindings specified by `glBindFragDataLocationIndexed` have no effect until *`program`* is next linked.
     * Bindings may be specified at any time after *`program`* has been created. Specifically, they may be specified
     * before shader objects are attached to the program. Therefore, any name may be specified in *`name`*, including
     * a name that is never used as a varying out variable in any fragment shader object. Names beginning with `gl_`
     * are reserved by the GL.
     *
     * If *`name`* was bound previously, its assigned binding is replaced with *`colorNumber`* and *`index`*.
     * *`name`* must be a null-terminated string. *`index`* must be less than or equal to one, and *`colorNumber`*
     * must be less than the value of `GL_MAX_DRAW_BUFFERS` if *`index`* is zero, and less than the value of
     * `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` if index is greater than or equal to one.
     *
     * In addition to the errors generated by `glBindFragDataLocationIndexed`, the program *`program`* will fail to
     * link if:
     *
     * - The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`.
     * - More than one varying out variable is bound to the same color number.
     *
     * @see http://docs.gl/gl3/glBindFragDataLocationIndexed
     * @see http://docs.gl/gl4/glBindFragDataLocationIndexed
     * @since 3.3
     * @param int $program
     * @param int $colorNumber
     * @param int $index
     * @param \FFI\CData|\FFI\CIntPtr|null $name
     * @return void
     */
    public static function glBindFragDataLocationIndexed(int $program, int $colorNumber, int $index, ?\FFI\CData $name): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($program >= 0 && $program <= 4_294_967_295, 'Argument $program overflow: C type GLuint is required');
        assert($colorNumber >= 0 && $colorNumber <= 4_294_967_295, 'Argument $colorNumber overflow: C type GLuint is required');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');

        $proc = self::getProc('glBindFragDataLocationIndexed', 'void (*)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)');
        $proc($program, $colorNumber, $index, $name);
    }

    /**
     * Returns the index of the fragment color to which the variable *`name`* was bound when the program object
     * *`program`* was last linked. If *`name`* is not a varying out variable of *`program`*, or if an error occurs,
     * -1 will be returned.
     *
     * @see http://docs.gl/gl3/glGetFragDataIndex
     * @see http://docs.gl/gl4/glGetFragDataIndex
     * @since 3.3
     * @param int $program
     * @param \FFI\CData|\FFI\CIntPtr|null $name
     * @return int
     */
    public static function glGetFragDataIndex(int $program, ?\FFI\CData $name): int
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($program >= 0 && $program <= 4_294_967_295, 'Argument $program overflow: C type GLuint is required');

        $proc = self::getProc('glGetFragDataIndex', 'GLint (*)(GLuint program, const GLchar *name)');
        return $proc($program, $name);
    }

    /**
     * Returns *`n`* sampler object names in *`samplers`*. There is no guarantee that the names form a contiguous set
     * of integers; however, it is guaranteed that none of the returned names was in use immediately before the call
     * to `glGenSamplers`.
     *
     * Sampler object names returned by a call to `glGenSamplers` are not returned by subsequent calls, unless they
     * are first deleted with {@see glDeleteSamplers}.
     *
     * The names returned in *`samplers`* are marked as used, for the purposes of `glGenSamplers` only, but they
     * acquire state and type only when they are first bound.
     *
     * @see http://docs.gl/gl3/glGenSamplers
     * @see http://docs.gl/gl4/glGenSamplers
     * @since 3.3
     * @param int $count
     * @param \FFI\CData|\FFI\CIntPtr|null $samplers
     * @return void
     */
    public static function glGenSamplers(int $count, ?\FFI\CData $samplers): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($count >= \PHP_INT_MIN && $count <= \PHP_INT_MAX, 'Argument $count overflow: C type GLsizei is required');

        $proc = self::getProc('glGenSamplers', 'void (*)(GLsizei count, GLuint *samplers)');
        $proc($count, $samplers);
    }

    /**
     * Deletes *`n`* sampler objects named by the elements of the array *`samplers`*. After a sampler object is
     * deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted,
     * it is as though {@see glBindSampler} is called with unit set to the unit the sampler is bound to and
     * sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
     *
     * @see http://docs.gl/gl3/glDeleteSamplers
     * @see http://docs.gl/gl4/glDeleteSamplers
     * @since 3.3
     * @param int $count
     * @param \FFI\CData|\FFI\CIntPtr|null $samplers
     * @return void
     */
    public static function glDeleteSamplers(int $count, ?\FFI\CData $samplers): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($count >= \PHP_INT_MIN && $count <= \PHP_INT_MAX, 'Argument $count overflow: C type GLsizei is required');

        $proc = self::getProc('glDeleteSamplers', 'void (*)(GLsizei count, const GLuint *samplers)');
        $proc($count, $samplers);
    }

    /**
     * Returns `GL_TRUE` if *`id`* is currently the name of a sampler object. If *`id`* is zero, or is a non-zero
     * value that is not currently the name of a sampler object, or if an error occurs, `glIsSampler` returns
     * `GL_FALSE`.
     *
     * A name returned by {@see glGenSamplers}, is the name of a sampler object.
     *
     * @see http://docs.gl/gl3/glIsSampler
     * @see http://docs.gl/gl4/glIsSampler
     * @since 3.3
     * @param int $sampler
     * @return int
     */
    public static function glIsSampler(int $sampler): int
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');

        $proc = self::getProc('glIsSampler', 'GLboolean (*)(GLuint sampler)');
        return $proc($sampler);
    }

    /**
     * Binds *`sampler`* to the texture unit at index *`unit`*. *`sampler`* must be zero or the name of a sampler
     * object previously returned from a call to {@see glGenSamplers}. *`unit`* must be less than the value
     * of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.
     *
     * When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to
     * that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler
     * state becomes active. A single sampler object may be bound to multiple texture units simultaneously.
     *
     * @see http://docs.gl/gl3/glBindSampler
     * @see http://docs.gl/gl4/glBindSampler
     * @since 3.3
     * @param int $unit
     * @param int $sampler
     * @return void
     */
    public static function glBindSampler(int $unit, int $sampler): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($unit >= 0 && $unit <= 4_294_967_295, 'Argument $unit overflow: C type GLuint is required');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');

        $proc = self::getProc('glBindSampler', 'void (*)(GLuint unit, GLuint sampler)');
        $proc($unit, $sampler);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param int $param
     * @return void
     */
    public static function glSamplerParameteri(int $sampler, int $pname, int $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');
        assert($param >= \PHP_INT_MIN && $param <= \PHP_INT_MAX, 'Argument $param overflow: C type GLint is required');

        $proc = self::getProc('glSamplerParameteri', 'void (*)(GLuint sampler, GLenum pname, GLint param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $param
     * @return void
     */
    public static function glSamplerParameteriv(int $sampler, int $pname, ?\FFI\CData $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glSamplerParameteriv', 'void (*)(GLuint sampler, GLenum pname, const GLint *param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param float $param
     * @return void
     */
    public static function glSamplerParameterf(int $sampler, int $pname, float $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');
        assert($param >= -3.40282e38 && $param <= 3.40282e38, 'Argument $param overflow: C type GLfloat is required');

        $proc = self::getProc('glSamplerParameterf', 'void (*)(GLuint sampler, GLenum pname, GLfloat param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CFloatPtr|null $param
     * @return void
     */
    public static function glSamplerParameterfv(int $sampler, int $pname, ?\FFI\CData $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glSamplerParameterfv', 'void (*)(GLuint sampler, GLenum pname, const GLfloat *param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $param
     * @return void
     */
    public static function glSamplerParameterIiv(int $sampler, int $pname, ?\FFI\CData $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glSamplerParameterIiv', 'void (*)(GLuint sampler, GLenum pname, const GLint *param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $param
     * @return void
     */
    public static function glSamplerParameterIuiv(int $sampler, int $pname, ?\FFI\CData $param): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glSamplerParameterIuiv', 'void (*)(GLuint sampler, GLenum pname, const GLuint *param)');
        $proc($sampler, $pname, $param);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $params
     * @return void
     */
    public static function glGetSamplerParameteriv(int $sampler, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetSamplerParameteriv', 'void (*)(GLuint sampler, GLenum pname, GLint *params)');
        $proc($sampler, $pname, $params);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $params
     * @return void
     */
    public static function glGetSamplerParameterIiv(int $sampler, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetSamplerParameterIiv', 'void (*)(GLuint sampler, GLenum pname, GLint *params)');
        $proc($sampler, $pname, $params);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CFloatPtr|null $params
     * @return void
     */
    public static function glGetSamplerParameterfv(int $sampler, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetSamplerParameterfv', 'void (*)(GLuint sampler, GLenum pname, GLfloat *params)');
        $proc($sampler, $pname, $params);
    }

    /**
     * @since 3.3
     * @param int $sampler
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $params
     * @return void
     */
    public static function glGetSamplerParameterIuiv(int $sampler, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($sampler >= 0 && $sampler <= 4_294_967_295, 'Argument $sampler overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetSamplerParameterIuiv', 'void (*)(GLuint sampler, GLenum pname, GLuint *params)');
        $proc($sampler, $pname, $params);
    }

    /**
     * Causes the GL to record the current time into the query object named *`id`*. *`target`* must be
     * `GL_TIMESTAMP`. The time is recorded after all previous commands on the GL client and server state and the
     * framebuffer have been fully realized. When the time is recorded, the query result for that object is marked
     * available. `glQueryCounter` timer queries can be used within a {@see glBeginQuery} /
     * {@see glEndQuery} block where the target is `GL_TIME_ELAPSED` and it does not affect the result of that
     * query object.
     *
     * @see http://docs.gl/gl3/glQueryCounter
     * @see http://docs.gl/gl4/glQueryCounter
     * @since 3.3
     * @param int $id
     * @param int $target
     * @return void
     */
    public static function glQueryCounter(int $id, int $target): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($id >= 0 && $id <= 4_294_967_295, 'Argument $id overflow: C type GLuint is required');
        assert($target >= 0 && $target <= 4_294_967_295, 'Argument $target overflow: C type GLenum is required');

        $proc = self::getProc('glQueryCounter', 'void (*)(GLuint id, GLenum target)');
        $proc($id, $target);
    }

    /**
     * @since 3.3
     * @param int $id
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $params
     * @return void
     */
    public static function glGetQueryObjecti64v(int $id, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($id >= 0 && $id <= 4_294_967_295, 'Argument $id overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetQueryObjecti64v', 'void (*)(GLuint id, GLenum pname, GLint64 *params)');
        $proc($id, $pname, $params);
    }

    /**
     * @since 3.3
     * @param int $id
     * @param int $pname
     * @param \FFI\CData|\FFI\CIntPtr|null $params
     * @return void
     */
    public static function glGetQueryObjectui64v(int $id, int $pname, ?\FFI\CData $params): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($id >= 0 && $id <= 4_294_967_295, 'Argument $id overflow: C type GLuint is required');
        assert($pname >= 0 && $pname <= 4_294_967_295, 'Argument $pname overflow: C type GLenum is required');

        $proc = self::getProc('glGetQueryObjectui64v', 'void (*)(GLuint id, GLenum pname, GLuint64 *params)');
        $proc($id, $pname, $params);
    }

    /**
     * Modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives
     * in a single draw call. If *`divisor`* is zero, the attribute at slot *`index`* advances once per vertex. If
     * *`divisor`* is non-zero, the attribute advances once per *`divisor`* instances of the set(s) of vertices being
     * rendered. An attribute is referred to as instanced if its `GL_VERTEX_ATTRIB_ARRAY_DIVISOR` value is non-zero.
     *
     * *`index`* must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.
     *
     * @see http://docs.gl/gl3/glVertexAttribDivisor
     * @see http://docs.gl/gl4/glVertexAttribDivisor
     * @since 3.3
     * @param int $index
     * @param int $divisor
     * @return void
     */
    public static function glVertexAttribDivisor(int $index, int $divisor): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($divisor >= 0 && $divisor <= 4_294_967_295, 'Argument $divisor overflow: C type GLuint is required');

        $proc = self::getProc('glVertexAttribDivisor', 'void (*)(GLuint index, GLuint divisor)');
        $proc($index, $divisor);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param int $value
     * @return void
     */
    public static function glVertexAttribP1ui(int $index, int $type, int $normalized, int $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');
        assert($value >= 0 && $value <= 4_294_967_295, 'Argument $value overflow: C type GLuint is required');

        $proc = self::getProc('glVertexAttribP1ui', 'void (*)(GLuint index, GLenum type, GLboolean normalized, GLuint value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param \FFI\CData|\FFI\CIntPtr|null $value
     * @return void
     */
    public static function glVertexAttribP1uiv(int $index, int $type, int $normalized, ?\FFI\CData $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');

        $proc = self::getProc('glVertexAttribP1uiv', 'void (*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param int $value
     * @return void
     */
    public static function glVertexAttribP2ui(int $index, int $type, int $normalized, int $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');
        assert($value >= 0 && $value <= 4_294_967_295, 'Argument $value overflow: C type GLuint is required');

        $proc = self::getProc('glVertexAttribP2ui', 'void (*)(GLuint index, GLenum type, GLboolean normalized, GLuint value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param \FFI\CData|\FFI\CIntPtr|null $value
     * @return void
     */
    public static function glVertexAttribP2uiv(int $index, int $type, int $normalized, ?\FFI\CData $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');

        $proc = self::getProc('glVertexAttribP2uiv', 'void (*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param int $value
     * @return void
     */
    public static function glVertexAttribP3ui(int $index, int $type, int $normalized, int $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');
        assert($value >= 0 && $value <= 4_294_967_295, 'Argument $value overflow: C type GLuint is required');

        $proc = self::getProc('glVertexAttribP3ui', 'void (*)(GLuint index, GLenum type, GLboolean normalized, GLuint value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param \FFI\CData|\FFI\CIntPtr|null $value
     * @return void
     */
    public static function glVertexAttribP3uiv(int $index, int $type, int $normalized, ?\FFI\CData $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');

        $proc = self::getProc('glVertexAttribP3uiv', 'void (*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param int $value
     * @return void
     */
    public static function glVertexAttribP4ui(int $index, int $type, int $normalized, int $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');
        assert($value >= 0 && $value <= 4_294_967_295, 'Argument $value overflow: C type GLuint is required');

        $proc = self::getProc('glVertexAttribP4ui', 'void (*)(GLuint index, GLenum type, GLboolean normalized, GLuint value)');
        $proc($index, $type, $normalized, $value);
    }

    /**
     * @since 3.3
     * @param int $index
     * @param int $type
     * @param int $normalized
     * @param \FFI\CData|\FFI\CIntPtr|null $value
     * @return void
     */
    public static function glVertexAttribP4uiv(int $index, int $type, int $normalized, ?\FFI\CData $value): void
    {
        assert(version_compare(self::$info->version, '3.3') >= 0, __FUNCTION__ . ' is available since OpenGL 3.3, but only OpenGL '. self::$info->version . ' is available');
        assert($index >= 0 && $index <= 4_294_967_295, 'Argument $index overflow: C type GLuint is required');
        assert($type >= 0 && $type <= 4_294_967_295, 'Argument $type overflow: C type GLenum is required');
        assert($normalized >= 0 && $normalized <= 255, 'Argument $normalized overflow: C type GLboolean is required');

        $proc = self::getProc('glVertexAttribP4uiv', 'void (*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)');
        $proc($index, $type, $normalized, $value);
    }
}
