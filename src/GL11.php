<?php

/**
 * This file is part of OpenGL package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * MACHINE GENERATED FILE, DO NOT EDIT
 */

declare(strict_types=1);

namespace Serafim\OpenGL;

/**
 * @version 1.1
 */
class GL11 extends GL
{
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM = 0x0100;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LOAD = 0x0101;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RETURN = 0x0102;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MULT = 0x0103;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ADD = 0x0104;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NEVER = 0x0200;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LESS = 0x0201;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EQUAL = 0x0202;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LEQUAL = 0x0203;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GREATER = 0x0204;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NOTEQUAL = 0x0205;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GEQUAL = 0x0206;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALWAYS = 0x0207;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_BIT = 0x0001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_BIT = 0x0002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_BIT = 0x0004;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_BIT = 0x0008;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_STIPPLE_BIT = 0x0010;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MODE_BIT = 0x0020;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHTING_BIT = 0x0040;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_BIT = 0x0080;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_BUFFER_BIT = 0x0100;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_BUFFER_BIT = 0x0200;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_BUFFER_BIT = 0x0400;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VIEWPORT_BIT = 0x0800;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TRANSFORM_BIT = 0x1000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ENABLE_BIT = 0x2000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_BUFFER_BIT = 0x4000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_HINT_BIT = 0x8000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EVAL_BIT = 0x0001_0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIST_BIT = 0x0002_0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BIT = 0x0004_0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SCISSOR_BIT = 0x0008_0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALL_ATTRIB_BITS = 0x000F_FFFF;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINTS = 0x0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINES = 0x0001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_LOOP = 0x0002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_STRIP = 0x0003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TRIANGLES = 0x0004;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TRIANGLE_STRIP = 0x0005;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TRIANGLE_FAN = 0x0006;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_QUADS = 0x0007;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_QUAD_STRIP = 0x0008;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON = 0x0009;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ZERO = 0x0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ONE = 0x0001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SRC_COLOR = 0x0300;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ONE_MINUS_SRC_COLOR = 0x0301;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SRC_ALPHA = 0x0302;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ONE_MINUS_SRC_ALPHA = 0x0303;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DST_ALPHA = 0x0304;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ONE_MINUS_DST_ALPHA = 0x0305;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DST_COLOR = 0x0306;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ONE_MINUS_DST_COLOR = 0x0307;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SRC_ALPHA_SATURATE = 0x0308;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TRUE = 0x0001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FALSE = 0x0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE0 = 0x3000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE1 = 0x3001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE2 = 0x3002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE3 = 0x3003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE4 = 0x3004;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIP_PLANE5 = 0x3005;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BYTE = 0x1400;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNSIGNED_BYTE = 0x1401;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SHORT = 0x1402;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNSIGNED_SHORT = 0x1403;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INT = 0x1404;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNSIGNED_INT = 0x1405;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FLOAT = 0x1406;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_2_BYTES = 0x1407;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_3_BYTES = 0x1408;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_4_BYTES = 0x1409;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DOUBLE = 0x140A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NONE = 0x0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FRONT_LEFT = 0x0400;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FRONT_RIGHT = 0x0401;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BACK_LEFT = 0x0402;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BACK_RIGHT = 0x0403;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FRONT = 0x0404;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BACK = 0x0405;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LEFT = 0x0406;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RIGHT = 0x0407;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FRONT_AND_BACK = 0x0408;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUX0 = 0x0409;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUX1 = 0x040A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUX2 = 0x040B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUX3 = 0x040C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NO_ERROR = 0x0000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INVALID_ENUM = 0x0500;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INVALID_VALUE = 0x0501;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INVALID_OPERATION = 0x0502;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STACK_OVERFLOW = 0x0503;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STACK_UNDERFLOW = 0x0504;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OUT_OF_MEMORY = 0x0505;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_2D = 0x0600;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_3D = 0x0601;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_3D_COLOR = 0x0602;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_3D_COLOR_TEXTURE = 0x0603;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_4D_COLOR_TEXTURE = 0x0604;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PASS_THROUGH_TOKEN = 0x0700;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_TOKEN = 0x0701;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_TOKEN = 0x0702;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_TOKEN = 0x0703;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BITMAP_TOKEN = 0x0704;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DRAW_PIXEL_TOKEN = 0x0705;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COPY_PIXEL_TOKEN = 0x0706;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_RESET_TOKEN = 0x0707;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EXP = 0x0800;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EXP2 = 0x0801;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CW = 0x0900;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CCW = 0x0901;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COEFF = 0x0A00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ORDER = 0x0A01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DOMAIN = 0x0A02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_COLOR = 0x0B00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_INDEX = 0x0B01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_NORMAL = 0x0B02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_TEXTURE_COORDS = 0x0B03;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_COLOR = 0x0B04;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_INDEX = 0x0B05;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_POSITION = 0x0B07;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_POSITION_VALID = 0x0B08;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CURRENT_RASTER_DISTANCE = 0x0B09;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_SMOOTH = 0x0B10;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_SIZE = 0x0B11;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_SIZE_RANGE = 0x0B12;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_SIZE_GRANULARITY = 0x0B13;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_SMOOTH = 0x0B20;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_WIDTH = 0x0B21;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_WIDTH_RANGE = 0x0B22;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_WIDTH_GRANULARITY = 0x0B23;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_STIPPLE = 0x0B24;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_STIPPLE_PATTERN = 0x0B25;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_STIPPLE_REPEAT = 0x0B26;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIST_MODE = 0x0B30;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_LIST_NESTING = 0x0B31;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIST_BASE = 0x0B32;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIST_INDEX = 0x0B33;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_MODE = 0x0B40;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_SMOOTH = 0x0B41;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_STIPPLE = 0x0B42;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EDGE_FLAG = 0x0B43;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CULL_FACE = 0x0B44;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CULL_FACE_MODE = 0x0B45;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FRONT_FACE = 0x0B46;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHTING = 0x0B50;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT_MODEL_LOCAL_VIEWER = 0x0B51;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT_MODEL_TWO_SIDE = 0x0B52;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT_MODEL_AMBIENT = 0x0B53;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SHADE_MODEL = 0x0B54;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_MATERIAL_FACE = 0x0B55;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_MATERIAL_PARAMETER = 0x0B56;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_MATERIAL = 0x0B57;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG = 0x0B60;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_INDEX = 0x0B61;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_DENSITY = 0x0B62;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_START = 0x0B63;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_END = 0x0B64;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_MODE = 0x0B65;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_COLOR = 0x0B66;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_RANGE = 0x0B70;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_TEST = 0x0B71;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_WRITEMASK = 0x0B72;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_CLEAR_VALUE = 0x0B73;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_FUNC = 0x0B74;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_CLEAR_VALUE = 0x0B80;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_TEST = 0x0B90;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_CLEAR_VALUE = 0x0B91;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_FUNC = 0x0B92;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_VALUE_MASK = 0x0B93;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_FAIL = 0x0B94;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_PASS_DEPTH_PASS = 0x0B96;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_REF = 0x0B97;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_WRITEMASK = 0x0B98;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MATRIX_MODE = 0x0BA0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NORMALIZE = 0x0BA1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VIEWPORT = 0x0BA2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MODELVIEW_STACK_DEPTH = 0x0BA3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PROJECTION_STACK_DEPTH = 0x0BA4;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_STACK_DEPTH = 0x0BA5;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MODELVIEW_MATRIX = 0x0BA6;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PROJECTION_MATRIX = 0x0BA7;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_MATRIX = 0x0BA8;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ATTRIB_STACK_DEPTH = 0x0BB0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_TEST = 0x0BC0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_TEST_FUNC = 0x0BC1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_TEST_REF = 0x0BC2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DITHER = 0x0BD0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLEND_DST = 0x0BE0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLEND_SRC = 0x0BE1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLEND = 0x0BE2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LOGIC_OP_MODE = 0x0BF0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_LOGIC_OP = 0x0BF1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LOGIC_OP = 0x0BF1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_LOGIC_OP = 0x0BF2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUX_BUFFERS = 0x0C00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DRAW_BUFFER = 0x0C01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_READ_BUFFER = 0x0C02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SCISSOR_BOX = 0x0C10;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SCISSOR_TEST = 0x0C11;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_CLEAR_VALUE = 0x0C20;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_WRITEMASK = 0x0C21;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_CLEAR_VALUE = 0x0C22;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_WRITEMASK = 0x0C23;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_MODE = 0x0C30;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA_MODE = 0x0C31;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DOUBLEBUFFER = 0x0C32;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STEREO = 0x0C33;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RENDER_MODE = 0x0C40;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PERSPECTIVE_CORRECTION_HINT = 0x0C50;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT_SMOOTH_HINT = 0x0C51;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE_SMOOTH_HINT = 0x0C52;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_SMOOTH_HINT = 0x0C53;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FOG_HINT = 0x0C54;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GEN_S = 0x0C60;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GEN_T = 0x0C61;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GEN_R = 0x0C62;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GEN_Q = 0x0C63;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_I = 0x0C70;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_S_TO_S = 0x0C71;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_R = 0x0C72;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_G = 0x0C73;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_B = 0x0C74;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_A = 0x0C75;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_R_TO_R = 0x0C76;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_G_TO_G = 0x0C77;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_B_TO_B = 0x0C78;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_A_TO_A = 0x0C79;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_I_SIZE = 0x0CB0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_S_TO_S_SIZE = 0x0CB1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_R_SIZE = 0x0CB2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_G_SIZE = 0x0CB3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_B_SIZE = 0x0CB4;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_I_TO_A_SIZE = 0x0CB5;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_R_TO_R_SIZE = 0x0CB6;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_G_TO_G_SIZE = 0x0CB7;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_B_TO_B_SIZE = 0x0CB8;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PIXEL_MAP_A_TO_A_SIZE = 0x0CB9;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_SWAP_BYTES = 0x0CF0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_LSB_FIRST = 0x0CF1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_ROW_LENGTH = 0x0CF2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_SKIP_ROWS = 0x0CF3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_SKIP_PIXELS = 0x0CF4;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_UNPACK_ALIGNMENT = 0x0CF5;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_SWAP_BYTES = 0x0D00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_LSB_FIRST = 0x0D01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_ROW_LENGTH = 0x0D02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_SKIP_ROWS = 0x0D03;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_SKIP_PIXELS = 0x0D04;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PACK_ALIGNMENT = 0x0D05;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP_COLOR = 0x0D10;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP_STENCIL = 0x0D11;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_SHIFT = 0x0D12;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_OFFSET = 0x0D13;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RED_SCALE = 0x0D14;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RED_BIAS = 0x0D15;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ZOOM_X = 0x0D16;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ZOOM_Y = 0x0D17;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GREEN_SCALE = 0x0D18;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GREEN_BIAS = 0x0D19;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLUE_SCALE = 0x0D1A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLUE_BIAS = 0x0D1B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_SCALE = 0x0D1C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_BIAS = 0x0D1D;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_SCALE = 0x0D1E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_BIAS = 0x0D1F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_EVAL_ORDER = 0x0D30;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_LIGHTS = 0x0D31;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_CLIP_PLANES = 0x0D32;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_TEXTURE_SIZE = 0x0D33;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_PIXEL_MAP_TABLE = 0x0D34;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_ATTRIB_STACK_DEPTH = 0x0D35;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_MODELVIEW_STACK_DEPTH = 0x0D36;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_NAME_STACK_DEPTH = 0x0D37;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_PROJECTION_STACK_DEPTH = 0x0D38;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_TEXTURE_STACK_DEPTH = 0x0D39;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_VIEWPORT_DIMS = 0x0D3A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SUBPIXEL_BITS = 0x0D50;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_BITS = 0x0D51;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RED_BITS = 0x0D52;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GREEN_BITS = 0x0D53;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLUE_BITS = 0x0D54;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA_BITS = 0x0D55;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_BITS = 0x0D56;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_BITS = 0x0D57;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_RED_BITS = 0x0D58;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_GREEN_BITS = 0x0D59;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_BLUE_BITS = 0x0D5A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ACCUM_ALPHA_BITS = 0x0D5B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NAME_STACK_DEPTH = 0x0D70;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AUTO_NORMAL = 0x0D80;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_COLOR_4 = 0x0D90;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_INDEX = 0x0D91;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_NORMAL = 0x0D92;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_TEXTURE_COORD_1 = 0x0D93;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_TEXTURE_COORD_2 = 0x0D94;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_TEXTURE_COORD_3 = 0x0D95;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_TEXTURE_COORD_4 = 0x0D96;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_VERTEX_3 = 0x0D97;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_VERTEX_4 = 0x0D98;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_COLOR_4 = 0x0DB0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_INDEX = 0x0DB1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_NORMAL = 0x0DB2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_TEXTURE_COORD_1 = 0x0DB3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_TEXTURE_COORD_2 = 0x0DB4;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_TEXTURE_COORD_3 = 0x0DB5;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_TEXTURE_COORD_4 = 0x0DB6;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_VERTEX_3 = 0x0DB7;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_VERTEX_4 = 0x0DB8;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_GRID_DOMAIN = 0x0DD0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP1_GRID_SEGMENTS = 0x0DD1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_GRID_DOMAIN = 0x0DD2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MAP2_GRID_SEGMENTS = 0x0DD3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_1D = 0x0DE0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_2D = 0x0DE1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FEEDBACK_BUFFER_POINTER = 0x0DF0;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FEEDBACK_BUFFER_SIZE = 0x0DF1;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FEEDBACK_BUFFER_TYPE = 0x0DF2;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SELECTION_BUFFER_POINTER = 0x0DF3;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SELECTION_BUFFER_SIZE = 0x0DF4;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_WIDTH = 0x1000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_HEIGHT = 0x1001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_INTERNAL_FORMAT = 0x1003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COMPONENTS = 0x1003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BORDER_COLOR = 0x1004;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BORDER = 0x1005;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DONT_CARE = 0x1100;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FASTEST = 0x1101;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NICEST = 0x1102;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT0 = 0x4000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT1 = 0x4001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT2 = 0x4002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT3 = 0x4003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT4 = 0x4004;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT5 = 0x4005;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT6 = 0x4006;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LIGHT7 = 0x4007;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AMBIENT = 0x1200;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DIFFUSE = 0x1201;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SPECULAR = 0x1202;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POSITION = 0x1203;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SPOT_DIRECTION = 0x1204;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SPOT_EXPONENT = 0x1205;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SPOT_CUTOFF = 0x1206;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CONSTANT_ATTENUATION = 0x1207;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINEAR_ATTENUATION = 0x1208;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_QUADRATIC_ATTENUATION = 0x1209;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COMPILE = 0x1300;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COMPILE_AND_EXECUTE = 0x1301;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLEAR = 0x1500;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AND = 0x1501;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AND_REVERSE = 0x1502;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COPY = 0x1503;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AND_INVERTED = 0x1504;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NOOP = 0x1505;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_XOR = 0x1506;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OR = 0x1507;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NOR = 0x1508;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EQUIV = 0x1509;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INVERT = 0x150A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OR_REVERSE = 0x150B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COPY_INVERTED = 0x150C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OR_INVERTED = 0x150D;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NAND = 0x150E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SET = 0x150F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EMISSION = 0x1600;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SHININESS = 0x1601;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_AMBIENT_AND_DIFFUSE = 0x1602;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_INDEXES = 0x1603;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MODELVIEW = 0x1700;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PROJECTION = 0x1701;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE = 0x1702;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR = 0x1800;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH = 0x1801;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL = 0x1802;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_INDEX = 0x1900;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_STENCIL_INDEX = 0x1901;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DEPTH_COMPONENT = 0x1902;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RED = 0x1903;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_GREEN = 0x1904;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BLUE = 0x1905;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA = 0x1906;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB = 0x1907;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA = 0x1908;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE = 0x1909;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE_ALPHA = 0x190A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_BITMAP = 0x1A00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POINT = 0x1B00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINE = 0x1B01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FILL = 0x1B02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RENDER = 0x1C00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FEEDBACK = 0x1C01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SELECT = 0x1C02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_FLAT = 0x1D00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SMOOTH = 0x1D01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_KEEP = 0x1E00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_REPLACE = 0x1E01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INCR = 0x1E02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DECR = 0x1E03;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VENDOR = 0x1F00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RENDERER = 0x1F01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERSION = 0x1F02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EXTENSIONS = 0x1F03;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_S = 0x2000;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T = 0x2001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_R = 0x2002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_Q = 0x2003;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_MODULATE = 0x2100;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_DECAL = 0x2101;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_ENV_MODE = 0x2200;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_ENV_COLOR = 0x2201;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_ENV = 0x2300;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EYE_LINEAR = 0x2400;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OBJECT_LINEAR = 0x2401;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_SPHERE_MAP = 0x2402;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GEN_MODE = 0x2500;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_OBJECT_PLANE = 0x2501;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EYE_PLANE = 0x2502;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NEAREST = 0x2600;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINEAR = 0x2601;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NEAREST_MIPMAP_NEAREST = 0x2700;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINEAR_MIPMAP_NEAREST = 0x2701;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NEAREST_MIPMAP_LINEAR = 0x2702;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LINEAR_MIPMAP_LINEAR = 0x2703;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_MAG_FILTER = 0x2800;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_MIN_FILTER = 0x2801;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_WRAP_S = 0x2802;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_WRAP_T = 0x2803;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLAMP = 0x2900;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_REPEAT = 0x2901;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIENT_PIXEL_STORE_BIT = 0x0001;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIENT_VERTEX_ARRAY_BIT = 0x0002;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_CLIENT_ALL_ATTRIB_BITS = 0xFFFF_FFFF;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_OFFSET_FACTOR = 0x8038;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_OFFSET_UNITS = 0x2A00;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_OFFSET_POINT = 0x2A01;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_OFFSET_LINE = 0x2A02;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_POLYGON_OFFSET_FILL = 0x8037;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA4 = 0x803B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA8 = 0x803C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA12 = 0x803D;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_ALPHA16 = 0x803E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE4 = 0x803F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE8 = 0x8040;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE12 = 0x8041;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE16 = 0x8042;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE4_ALPHA4 = 0x8043;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE6_ALPHA2 = 0x8044;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE8_ALPHA8 = 0x8045;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE12_ALPHA4 = 0x8046;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE12_ALPHA12 = 0x8047;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_LUMINANCE16_ALPHA16 = 0x8048;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INTENSITY = 0x8049;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INTENSITY4 = 0x804A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INTENSITY8 = 0x804B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INTENSITY12 = 0x804C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INTENSITY16 = 0x804D;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_R3_G3_B2 = 0x2A10;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB4 = 0x804F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB5 = 0x8050;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB8 = 0x8051;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB10 = 0x8052;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB12 = 0x8053;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB16 = 0x8054;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA2 = 0x8055;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA4 = 0x8056;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB5_A1 = 0x8057;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA8 = 0x8058;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGB10_A2 = 0x8059;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA12 = 0x805A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_RGBA16 = 0x805B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_RED_SIZE = 0x805C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_GREEN_SIZE = 0x805D;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BLUE_SIZE = 0x805E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_ALPHA_SIZE = 0x805F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_LUMINANCE_SIZE = 0x8060;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_INTENSITY_SIZE = 0x8061;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PROXY_TEXTURE_1D = 0x8063;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_PROXY_TEXTURE_2D = 0x8064;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_PRIORITY = 0x8066;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_RESIDENT = 0x8067;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BINDING_1D = 0x8068;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_BINDING_2D = 0x8069;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERTEX_ARRAY = 0x8074;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NORMAL_ARRAY = 0x8075;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_ARRAY = 0x8076;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_ARRAY = 0x8077;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COORD_ARRAY = 0x8078;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EDGE_FLAG_ARRAY = 0x8079;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERTEX_ARRAY_SIZE = 0x807A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERTEX_ARRAY_TYPE = 0x807B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERTEX_ARRAY_STRIDE = 0x807C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NORMAL_ARRAY_TYPE = 0x807E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NORMAL_ARRAY_STRIDE = 0x807F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_ARRAY_SIZE = 0x8081;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_ARRAY_TYPE = 0x8082;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_ARRAY_STRIDE = 0x8083;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_ARRAY_TYPE = 0x8085;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_ARRAY_STRIDE = 0x8086;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COORD_ARRAY_SIZE = 0x8088;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COORD_ARRAY_TYPE = 0x8089;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COORD_ARRAY_STRIDE = 0x808A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EDGE_FLAG_ARRAY_STRIDE = 0x808C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_VERTEX_ARRAY_POINTER = 0x808E;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_NORMAL_ARRAY_POINTER = 0x808F;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_COLOR_ARRAY_POINTER = 0x8090;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_INDEX_ARRAY_POINTER = 0x8091;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_TEXTURE_COORD_ARRAY_POINTER = 0x8092;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_EDGE_FLAG_ARRAY_POINTER = 0x8093;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_V2F = 0x2A20;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_V3F = 0x2A21;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_C4UB_V2F = 0x2A22;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_C4UB_V3F = 0x2A23;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_C3F_V3F = 0x2A24;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_N3F_V3F = 0x2A25;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_C4F_N3F_V3F = 0x2A26;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T2F_V3F = 0x2A27;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T4F_V4F = 0x2A28;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T2F_C4UB_V3F = 0x2A29;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T2F_C3F_V3F = 0x2A2A;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T2F_N3F_V3F = 0x2A2B;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T2F_C4F_N3F_V3F = 0x2A2C;
    /**
     * @since 1.1
     * @var int
     */
    public const GL_T4F_C4F_N3F_V4F = 0x2A2D;

    /**
     * The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images
     * rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering.
     * Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created
     * by accumulating images generated with different transformation matrices.
     *
     * Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per
     * component in the accumulation buffer depends on the implementation. You can examine this number by calling
     * {@see GL46::glGetIntegerv} four times, with arguments {@see GL46::GL_ACCUM_RED_BITS},
     * {@see GL46::GL_ACCUM_GREEN_BITS}, {@see GL46::GL_ACCUM_BLUE_BITS}, and {@see GL46::GL_ACCUM_ALPHA_BITS}.
     * Regardless of the number of bits per component, the range of values stored by each component is    -1 1  . The
     * accumulation buffer pixels are mapped one-to-one with frame buffer pixels.
     *
     * {@see GL46::glAccum} operates on the accumulation buffer. The first argument, $op, is a symbolic constant that
     * selects an accumulation buffer operation. The second argument, $value, is a floating-point value to be used in
     * that operation. Five operations are specified: {@see GL46::GL_ACCUM}, {@see GL46::GL_LOAD},
     * {@see GL46::GL_ADD}, {@see GL46::GL_MULT}, and {@see GL46::GL_RETURN}.
     *
     * All accumulation buffer operations are limited to the area of the current scissor box and applied identically
     * to the red, green, blue, and alpha components of each pixel. If a {@see GL46::glAccum} operation results in a
     * value outside the range    -1 1  , the contents of an accumulation buffer pixel component are undefined.
     *
     * The operations are as follows:
     *
     *  - {@see GL46::GL_ACCUM}: Obtains R, G, B, and A values from the buffer
     *    currently selected for reading (see {@see GL46::glReadBuffer}).
     *    Each component value is divided by    2 n  - 1  , where n is the
     *    number of bits allocated to each color
     *    component in the currently selected buffer. The result is a
     *    floating-point value in the range    0 1  , which
     *    is multiplied by $value and added to the corresponding pixel component
     *    in the accumulation buffer, thereby
     *    updating the accumulation buffer.
     *
     *  - {@see GL46::GL_LOAD}: Similar to {@see GL46::GL_ACCUM}, except that
     *    the current value in the accumulation buffer is not used in the
     *    calculation of the new value. That is, the R, G, B, and A values from
     *    the currently selected buffer are
     *    divided by    2 n  - 1  , multiplied by $value, and then stored in the
     *    corresponding accumulation buffer cell,
     *    overwriting the current value.
     *
     *  - {@see GL46::GL_ADD}: Adds $value to each R, G, B, and A in the
     *    accumulation buffer.
     *
     *  - {@see GL46::GL_MULT}: Multiplies each R, G, B, and A in the
     *    accumulation buffer by $value and returns the scaled component to its
     *    corresponding accumulation buffer location.
     *
     *  - {@see GL46::GL_RETURN}: Transfers accumulation buffer values to the
     *    color buffer or buffers currently selected for writing. Each R,
     *    G, B, and A component is multiplied by $value, then multiplied by    2
     *    n  - 1  , clamped to the range    0  2
     *    n  - 1   , and stored in the corresponding display buffer cell. The
     *    only fragment operations that are applied
     *    to this transfer are pixel ownership, scissor, dithering, and color
     *    writemasks.
     *
     * To clear the accumulation buffer, call {@see GL46::glClearAccum} with R, G, B, and A values to set it to, then
     * call {@see GL46::glClear} with the accumulation buffer enabled.
     *
     * @see http://docs.gl/gl2/glAccum
     * @since 1.1
     * @param int $op
     * @param float $value
     * @return void
     */
    public function accum(int $op, float $value): void
    {
        $this->info->ffi->glAccum($op, $value);
    }

    /**
     * The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's
     * alpha value and a constant reference value. {@see GL46::glAlphaFunc} specifies the reference value and the
     * comparison function. The comparison is performed only if alpha testing is enabled. By default, it is not
     * enabled. (See {@see GL46::glEnable} and {@see GL46::glDisable} of {@see GL46::GL_ALPHA_TEST}.)
     *
     * $func and $ref specify the conditions under which the pixel is drawn. The incoming alpha value is compared to
     * $ref using the function specified by $func. If the value passes the comparison, the incoming fragment is drawn
     * if it also passes subsequent stencil and depth buffer tests. If the value fails the comparison, no change is
     * made to the frame buffer at that pixel location. The comparison functions are as follows:
     *
     *  - {@see GL46::GL_NEVER}: Never passes.
     *
     *  - {@see GL46::GL_LESS}: Passes if the incoming alpha value is less than
     *    the reference value.
     *
     *  - {@see GL46::GL_EQUAL}: Passes if the incoming alpha value is equal to
     *    the reference value.
     *
     *  - {@see GL46::GL_LEQUAL}: Passes if the incoming alpha value is less
     *    than or equal to the reference value.
     *
     *  - {@see GL46::GL_GREATER}: Passes if the incoming alpha value is greater
     *    than the reference value.
     *
     *  - {@see GL46::GL_NOTEQUAL}: Passes if the incoming alpha value is not
     *    equal to the reference value.
     *
     *  - {@see GL46::GL_GEQUAL}: Passes if the incoming alpha value is greater
     *    than or equal to the reference value.
     *
     *  - {@see GL46::GL_ALWAYS}: Always passes (initial value).
     *
     * {@see GL46::glAlphaFunc} operates on all pixel write operations, including those resulting from the scan
     * conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations.
     * {@see GL46::glAlphaFunc} does not affect screen clear operations.
     *
     * @see http://docs.gl/gl2/glAlphaFunc
     * @since 1.1
     * @param int $func
     * @param float $ref
     * @return void
     */
    public function alphaFunc(int $func, float $ref): void
    {
        $this->info->ffi->glAlphaFunc($func, $ref);
    }

    /**
     * GL establishes a ``working set'' of textures that are resident in texture memory. These textures can be bound
     * to a texture target much more efficiently than textures that are not resident.
     *
     * {@see GL46::glAreTexturesResident} queries the texture residence status of the $n textures named by the
     * elements of $textures. If all the named textures are resident, {@see GL46::glAreTexturesResident} returns
     * {@see GL46::GL_TRUE}, and the contents of $residences are undisturbed. If not all the named textures are
     * resident, {@see GL46::glAreTexturesResident} returns {@see GL46::GL_FALSE}, and detailed status is returned in
     * the $n elements of $residences. If an element of $residences is {@see GL46::GL_TRUE}, then the texture named
     * by the corresponding element of $textures is resident.
     *
     * The residence status of a single bound texture may also be queried by calling {@see GL46::glGetTexParameter}
     * with the target argument set to the target to which the texture is bound, and the pname argument set to
     * {@see GL46::GL_TEXTURE_RESIDENT}. This is the only way that the residence status of a default texture can be
     * queried.
     *
     * @see http://docs.gl/gl2/glAreTexturesResident
     * @since 1.1
     * @param int $n
     * @param \FFI\CData|null $textures
     * @param bool|null $residences
     * @return bool
     */
    public function areTexturesResident(int $n, ?\FFI\CData $textures, ?bool &$residences): bool
    {
        $residencesCType = $this->info->ffi->new('GLboolean', false);
        try {
            return $this->info->ffi->glAreTexturesResident($n, $textures, \FFI::addr($residencesCType)) !== 0;
        } finally {
            $residences = $residencesCType->cdata !== 0;
            \FFI::free($residencesCType);
        }
    }

    /**
     * {@see GL46::glArrayElement} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify
     * vertex and attribute data for point, line, and polygon primitives. If {@see GL46::GL_VERTEX_ARRAY} is enabled
     * when {@see GL46::glArrayElement} is called, a single vertex is drawn, using vertex and attribute data taken
     * from location $i of the enabled arrays. If {@see GL46::GL_VERTEX_ARRAY} is not enabled, no drawing occurs but
     * the attributes corresponding to the enabled arrays are modified.
     *
     * Use {@see GL46::glArrayElement} to construct primitives by indexing vertex data, rather than by streaming
     * through arrays of data in first-to-last order. Because each call specifies only a single vertex, it is
     * possible to explicitly specify per-primitive attributes such as a single normal for each triangle.
     *
     * Changes made to array data between the execution of {@see GL46::glBegin} and the corresponding execution of
     * {@see GL46::glEnd} may affect calls to {@see GL46::glArrayElement} that are made within the same
     * {@see GL46::glBegin}/{@see GL46::glEnd} period in nonsequential ways. That is, a call to
     * {@see GL46::glArrayElement} that precedes a change to array data may access the changed data, and a call that
     * follows a change to array data may access original data.
     *
     * @see http://docs.gl/gl2/glArrayElement
     * @since 1.1
     * @param int $i
     * @return void
     */
    public function arrayElement(int $i): void
    {
        $this->info->ffi->glArrayElement($i);
    }

    /**
     * {@see GL46::glBegin} and {@see GL46::glEnd} delimit the vertices that define a primitive or a group of like
     * primitives. {@see GL46::glBegin} accepts a single argument that specifies in which of ten ways the vertices
     * are interpreted. Taking n as an integer count starting at one, and N as the total number of vertices
     * specified, the interpretations are as follows:
     *
     *  - {@see GL46::GL_POINTS}: Treats each vertex as a single point. Vertex n
     *    defines point n. N points are drawn.
     *
     *  - {@see GL46::GL_LINES}: Treats each pair of vertices as an independent
     *    line segment. Vertices    2 &amp;it; n - 1   and    2 &amp;it;
     *    n   define line n.    N 2   lines are drawn.
     *
     *  - {@see GL46::GL_LINE_STRIP}: Draws a connected group of line segments
     *    from the first vertex to the last. Vertices n and    n + 1   define
     *    line n.    N - 1   lines are drawn.
     *
     *  - {@see GL46::GL_LINE_LOOP}: Draws a connected group of line segments
     *    from the first vertex to the last, then back to the first. Vertices
     *    n and    n + 1   define line n. The last line, however, is defined by
     *    vertices N and   1 . N lines are drawn.
     *
     *  - {@see GL46::GL_TRIANGLES}: Treats each triplet of vertices as an
     *    independent triangle. Vertices    3 &amp;it; n - 2  ,    3 &amp;it; n
     *    -
     *    1  , and    3 &amp;it; n   define triangle n.    N 3   triangles are
     *    drawn.
     *
     *  - {@see GL46::GL_TRIANGLE_STRIP}: Draws a connected group of triangles.
     *    One triangle is defined for each vertex presented after the first two
     *    vertices. For odd n, vertices n,    n + 1  , and    n + 2   define
     *    triangle n. For even n, vertices    n + 1
     *    , n, and    n + 2   define triangle n.    N - 2   triangles are drawn.
     *
     *  - {@see GL46::GL_TRIANGLE_FAN}: Draws a connected group of triangles.
     *    One triangle is defined for each vertex presented after the first two
     *    vertices. Vertices   1 ,    n + 1  , and    n + 2   define triangle n.
     *       N - 2   triangles are drawn.
     *
     *  - {@see GL46::GL_QUADS}: Treats each group of four vertices as an
     *    independent quadrilateral. Vertices    4 &amp;it; n - 3  ,    4
     *    &amp;it; n - 2  ,    4 &amp;it; n - 1  , and    4 &amp;it; n   define
     *    quadrilateral n.    N 4   quadrilaterals
     *    are drawn.
     *
     *  - {@see GL46::GL_QUAD_STRIP}: Draws a connected group of quadrilaterals.
     *    One quadrilateral is defined for each pair of vertices presented
     *    after the first pair. Vertices    2 &amp;it; n - 1  ,    2 &amp;it; n
     *    ,    2 &amp;it; n + 2  , and    2
     *    &amp;it; n + 1   define quadrilateral n.     N 2  - 1   quadrilaterals
     *    are drawn. Note that the order in which
     *    vertices are used to construct a quadrilateral from strip data is
     *    different from that used with independent
     *    data.
     *
     *  - {@see GL46::GL_POLYGON}: Draws a single, convex polygon. Vertices   1
     *    through N define this polygon.
     *
     * Only a subset of GL commands can be used between {@see GL46::glBegin} and {@see GL46::glEnd}. The commands are
     * {@see GL46::glVertex}, {@see GL46::glColor}, {@see GL46::glSecondaryColor}, {@see GL46::glIndex},
     * {@see GL46::glNormal}, {@see GL46::glFogCoord}, {@see GL46::glTexCoord}, {@see GL46::glMultiTexCoord},
     * {@see GL46::glVertexAttrib}, {@see GL46::glEvalCoord}, {@see GL46::glEvalPoint}, {@see GL46::glArrayElement},
     * {@see GL46::glMaterial}, and {@see GL46::glEdgeFlag}. Also, it is acceptable to use {@see GL46::glCallList} or
     * {@see GL46::glCallLists} to execute display lists that include only the preceding commands. If any other GL
     * command is executed between {@see GL46::glBegin} and {@see GL46::glEnd}, the error flag is set and the command
     * is ignored.
     *
     * Regardless of the value chosen for $mode, there is no limit to the number of vertices that can be defined
     * between {@see GL46::glBegin} and {@see GL46::glEnd}. Lines, triangles, quadrilaterals, and polygons that are
     * incompletely specified are not drawn. Incomplete specification results when either too few vertices are
     * provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The
     * incomplete primitive is ignored; the rest are drawn.
     *
     * The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a
     * triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are
     * {@see GL46::GL_LINES} (2), {@see GL46::GL_TRIANGLES} (3), {@see GL46::GL_QUADS} (4), and
     * {@see GL46::GL_QUAD_STRIP} (2).
     *
     * @see http://docs.gl/gl2/glBegin
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function begin(int $mode): void
    {
        $this->info->ffi->glBegin($mode);
    }

    /**
     * {@see GL46::glBindTexture} lets you create or use a named texture. Calling {@see GL46::glBindTexture} with
     * $target set to {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_2D}, {@see GL46::GL_TEXTURE_3D},
     * {@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_RECTANGLE},
     * {@see GL46::GL_TEXTURE_CUBE_MAP}, {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, {@see GL46::GL_TEXTURE_BUFFER},
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE} or {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY} and $texture set to the
     * name of the new texture binds the texture name to the target. When a texture is bound to a target, the
     * previous binding for that target is automatically broken.
     *
     * Texture names are unsigned integers. The value zero is reserved to represent the default texture for each
     * texture target. Texture names and the corresponding texture contents are local to the shared object space of
     * the current GL rendering context; two rendering contexts share texture names only if they explicitly enable
     * sharing between contexts through the appropriate GL windows interfaces functions.
     *
     * You must use {@see GL46::glGenTextures} to generate a set of new texture names.
     *
     * When a texture is first bound, it assumes the specified target: A texture first bound to
     * {@see GL46::GL_TEXTURE_1D} becomes one-dimensional texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_2D} becomes two-dimensional texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_3D} becomes three-dimensional texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_1D_ARRAY} becomes one-dimensional array texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_2D_ARRAY} becomes two-dimensional array texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_RECTANGLE} becomes rectangle texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_CUBE_MAP} becomes a cube-mapped texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY} becomes a cube-mapped array texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_BUFFER} becomes a buffer texture, a texture first bound to
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE} becomes a two-dimensional multisampled texture, and a texture first
     * bound to {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY} becomes a two-dimensional multisampled array texture.
     * The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the
     * default {@see GL46::GL_TEXTURE_1D} at GL initialization, and similarly for the other texture types.
     *
     * While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and
     * queries of the target to which it is bound return state from the bound texture. In effect, the texture targets
     * become aliases for the textures currently bound to them, and the texture name zero refers to the default
     * textures that were bound to them at initialization.
     *
     * A texture binding created with {@see GL46::glBindTexture} remains active until a different texture is bound to
     * the same target, or until the bound texture is deleted with {@see GL46::glDeleteTextures}.
     *
     * Once created, a named texture may be re-bound to its same original target as often as needed. It is usually
     * much faster to use {@see GL46::glBindTexture} to bind an existing named texture to one of the texture targets
     * than it is to reload the texture image using {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     * {@see GL46::glTexImage3D} or another similar function.
     *
     * @see http://docs.gl/gl2/glBindTexture
     * @see http://docs.gl/gl4/glBindTexture
     * @since 1.1
     * @param int $target
     * @param int $texture
     * @return void
     */
    public function bindTexture(int $target, int $texture): void
    {
        $this->info->ffi->glBindTexture($target, $texture);
    }

    /**
     * A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and
     * frame buffer pixels corresponding to 1's in the bitmap are written using the current raster color or index.
     * Frame buffer pixels corresponding to 0's in the bitmap are not modified.
     *
     * {@see GL46::glBitmap} takes seven arguments. The first pair specifies the width and height of the bitmap
     * image. The second pair specifies the location of the bitmap origin relative to the lower left corner of the
     * bitmap image. The third pair of arguments specifies x and y offsets to be added to the current raster position
     * after the bitmap has been drawn. The final argument is a pointer to the bitmap image itself.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a bitmap image is specified, $bitmap is treated as a byte offset into the
     * buffer object's data store.
     *
     * The bitmap image is interpreted like image data for the {@see GL46::glDrawPixels} command, with $width and
     * $height corresponding to the width and height arguments of that command, and with type set to
     * {@see GL46::GL_BITMAP} and format set to {@see GL46::GL_COLOR_INDEX}. Modes specified using
     * {@see GL46::glPixelStore} affect the interpretation of bitmap image data; modes specified using
     * {@see GL46::glPixelTransfer} do not.
     *
     * If the current raster position is invalid, {@see GL46::glBitmap} is ignored. Otherwise, the lower left corner
     * of the bitmap image is positioned at the window coordinates
     *
     *    x w  = &amp;LeftFloor;&amp;RightFloor;  x r  - x o
     *
     *    y w  = &amp;LeftFloor;&amp;RightFloor;  y r  - y o
     *
     * where    x r  y r    is the raster position and    x o  y o    is the bitmap origin. Fragments are then
     * generated for each pixel corresponding to a 1 (one) in the bitmap image. These fragments are generated using
     * the current raster z coordinate, color or color index, and current raster texture coordinates. They are then
     * treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging,
     * and all per-fragment operations such as alpha and depth testing.
     *
     * After the bitmap has been drawn, the x and y coordinates of the current raster position are offset by $xmove
     * and $ymove. No change is made to the z coordinate of the current raster position, or to the current raster
     * color, texture coordinates, or index.
     *
     * @see http://docs.gl/gl2/glBitmap
     * @since 1.1
     * @param int $width
     * @param int $height
     * @param float $xorig
     * @param float $yorig
     * @param float $xmove
     * @param float $ymove
     * @param \FFI\CData|null $bitmap
     * @return void
     */
    public function bitmap(int $width, int $height, float $xorig, float $yorig, float $xmove, float $ymove, ?\FFI\CData $bitmap): void
    {
        $this->info->ffi->glBitmap($width, $height, $xorig, $yorig, $xmove, $ymove, $bitmap);
    }

    /**
     * Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that
     * are already in the frame buffer (the destination values). Blending is initially disabled. Use
     * {@see GL46::glEnable} and  {@see GL46::glDisable} with argument {@see GL46::GL_BLEND} to enable and disable
     * blending.
     *
     * {@see GL46::glBlendFunc} defines the operation of blending for all draw buffers when it is enabled.
     * {@see GL46::glBlendFunci} defines the operation of blending for a single draw buffer specified by $buf when
     * enabled for that draw buffer. $sfactor specifies which method is used to scale the source color components.
     * $dfactor specifies which method is used to scale the destination color components. Both parameters must be one
     * of the following symbolic constants: {@see GL46::GL_ZERO}, {@see GL46::GL_ONE}, {@see GL46::GL_SRC_COLOR},
     * {@see GL46::GL_ONE_MINUS_SRC_COLOR}, {@see GL46::GL_DST_COLOR}, {@see GL46::GL_ONE_MINUS_DST_COLOR},
     * {@see GL46::GL_SRC_ALPHA}, {@see GL46::GL_ONE_MINUS_SRC_ALPHA}, {@see GL46::GL_DST_ALPHA},
     * {@see GL46::GL_ONE_MINUS_DST_ALPHA}, {@see GL46::GL_CONSTANT_COLOR}, {@see GL46::GL_ONE_MINUS_CONSTANT_COLOR},
     * {@see GL46::GL_CONSTANT_ALPHA}, {@see GL46::GL_ONE_MINUS_CONSTANT_ALPHA}, {@see GL46::GL_SRC_ALPHA_SATURATE},
     * {@see GL46::GL_SRC1_COLOR}, {@see GL46::GL_ONE_MINUS_SRC1_COLOR}, {@see GL46::GL_SRC1_ALPHA}, and
     * {@see GL46::GL_ONE_MINUS_SRC1_ALPHA}. The possible methods are described in the following table. Each method
     * defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent
     * equations, first source, second source and destination color components are referred to as    R s0  G s0  B s0
     *  A s0   ,    R s1  G s1  B s1  A s1    and    R d  G d  B d  A d   , respectively. The color specified by
     * {@see GL46::glBlendColor} is referred to as    R c  G c  B c  A c   . They are understood to have integer
     * values between 0 and    k R  k G  k B  k A   , where
     *
     *    k c  =  2  m c    - 1
     *
     * and    m R  m G  m B  m A    is the number of red, green, blue, and alpha bitplanes.
     *
     * Source and destination scale factors are referred to as    s R  s G  s B  s A    and    d R  d G  d B  d A   .
     * The scale factors described in the table, denoted    f R  f G  f B  f A   , represent either source or
     * destination factors. All scale factors have range    0 1  .
     *
     * | {@see GL46::GL_ZERO}                     |    0 0 0 0                                                        |
     * | {@see GL46::GL_ONE}                      |    1 1 1 1                                                        |
     * | {@see GL46::GL_SRC_COLOR}                |     R s0  k R    G s0  k G    B s0  k B    A s0  k A              |
     * | {@see GL46::GL_ONE_MINUS_SRC_COLOR}      |     1 1 1 1  -   R s0  k R    G s0  k G    B s0  k B    A s0  k A |
     * | {@see GL46::GL_DST_COLOR}                |     R d  k R    G d  k G    B d  k B    A d  k A                  |
     * | {@see GL46::GL_ONE_MINUS_DST_COLOR}      |     1 1 1 1  -   R d  k R    G d  k G    B d  k B    A d  k A     |
     * | {@see GL46::GL_SRC_ALPHA}                |     A s0  k A    A s0  k A    A s0  k A    A s0  k A              |
     * | {@see GL46::GL_ONE_MINUS_SRC_ALPHA}      |     1 1 1 1  -   A s0  k A    A s0  k A    A s0  k A    A s0  k A |
     * | {@see GL46::GL_DST_ALPHA}                |     A d  k A    A d  k A    A d  k A    A d  k A                  |
     * | {@see GL46::GL_ONE_MINUS_DST_ALPHA}      |     1 1 1 1  -   A d  k A    A d  k A    A d  k A    A d  k A     |
     * | {@see GL46::GL_CONSTANT_COLOR}           |    R c  G c  B c  A c                                             |
     * | {@see GL46::GL_ONE_MINUS_CONSTANT_COLOR} |     1 1 1 1  -  R c  G c  B c  A c                                |
     * | {@see GL46::GL_CONSTANT_ALPHA}           |    A c  A c  A c  A c                                             |
     * | {@see GL46::GL_ONE_MINUS_CONSTANT_ALPHA} |     1 1 1 1  -  A c  A c  A c  A c                                |
     * | {@see GL46::GL_SRC_ALPHA_SATURATE}       |    i i i 1                                                        |
     * | {@see GL46::GL_SRC1_COLOR}               |     R s1  k R    G s1  k G    B s1  k B    A s1  k A              |
     * | {@see GL46::GL_ONE_MINUS_SRC1_COLOR}     |     1 1 1 1  -   R s1  k R    G s1  k G    B s1  k B    A s1  k A |
     * | {@see GL46::GL_SRC1_ALPHA}               |     A s1  k A    A s1  k A    A s1  k A    A s1  k A              |
     * | {@see GL46::GL_ONE_MINUS_SRC1_ALPHA}     |     1 1 1 1  -   A s1  k A    A s1  k A    A s1  k A    A s1  k A |
     * In the table,
     *
     *    i =   min &amp;af;  A s   k A  - A d     k A
     *
     * To determine the blended RGBA values of a pixel, the system uses the following equations:
     *
     *    R d  =  min &amp;af;  k R   R s  &amp;it; s R  + R d  &amp;it; d R          G d  =  min &amp;af;  k G   G s
     *  &amp;it; s G  + G d  &amp;it; d G          B d  =  min &amp;af;  k B   B s  &amp;it; s B  + B d  &amp;it; d B
     *          A d  =  min &amp;af;  k A   A s  &amp;it; s A  + A d  &amp;it; d A
     *
     * Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because
     * blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is
     * guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For
     * example, when $sfactor is {@see GL46::GL_SRC_ALPHA}, $dfactor is {@see GL46::GL_ONE_MINUS_SRC_ALPHA}, and   A
     * s   is equal to   k A  , the equations reduce to simple replacement:
     *
     *    R d  = R s       G d  = G s       B d  = B s       A d  = A s
     *
     * @see http://docs.gl/gl2/glBlendFunc
     * @see http://docs.gl/gl4/glBlendFunc
     * @since 1.1
     * @param int $sfactor
     * @param int $dfactor
     * @return void
     */
    public function blendFunc(int $sfactor, int $dfactor): void
    {
        $this->info->ffi->glBlendFunc($sfactor, $dfactor);
    }

    /**
     * {@see GL46::glCallList} causes the named display list to be executed. The commands saved in the display list
     * are executed in order, just as if they were called without using a display list. If $list has not been defined
     * as a display list, {@see GL46::glCallList} is ignored.
     *
     * {@see GL46::glCallList} can appear inside a display list. To avoid the possibility of infinite recursion
     * resulting from display lists calling one another, a limit is placed on the nesting level of display lists
     * during display-list execution. This limit is at least 64, and it depends on the implementation.
     *
     * GL state is not saved and restored across a call to {@see GL46::glCallList}. Thus, changes made to GL state
     * during the execution of a display list remain after execution of the display list is completed. Use
     * {@see GL46::glPushAttrib}, {@see GL46::glPopAttrib}, {@see GL46::glPushMatrix}, and {@see GL46::glPopMatrix}
     * to preserve GL state across {@see GL46::glCallList} calls.
     *
     * @see http://docs.gl/gl2/glCallList
     * @since 1.1
     * @param int $list
     * @return void
     */
    public function callList(int $list): void
    {
        $this->info->ffi->glCallList($list);
    }

    /**
     * {@see GL46::glCallLists} causes each display list in the list of names passed as $lists to be executed. As a
     * result, the commands saved in each display list are executed in order, just as if they were called without
     * using a display list. Names of display lists that have not been defined are ignored.
     *
     * {@see GL46::glCallLists} provides an efficient means for executing more than one display list. $type allows
     * lists with various name formats to be accepted. The formats are as follows:
     *
     *  - {@see GL46::GL_BYTE}: $lists is treated as an array of signed bytes,
     *    each in the range   -128  through 127.
     *
     *  - {@see GL46::GL_UNSIGNED_BYTE}: $lists is treated as an array of
     *    unsigned bytes, each in the range 0 through 255.
     *
     *  - {@see GL46::GL_SHORT}: $lists is treated as an array of signed
     *    two-byte integers, each in the range   -32768  through 32767.
     *
     *  - {@see GL46::GL_UNSIGNED_SHORT}: $lists is treated as an array of
     *    unsigned two-byte integers, each in the range 0 through 65535.
     *
     *  - {@see GL46::GL_INT}: $lists is treated as an array of signed four-byte
     *    integers.
     *
     *  - {@see GL46::GL_UNSIGNED_INT}: $lists is treated as an array of
     *    unsigned four-byte integers.
     *
     *  - {@see GL46::GL_FLOAT}: $lists is treated as an array of four-byte
     *    floating-point values.
     *
     *  - {@see GL46::GL_2_BYTES}: $lists is treated as an array of unsigned
     *    bytes. Each pair of bytes specifies a single display-list name. The
     *    value of the pair is computed as 256 times the unsigned value of the
     *    first byte plus the unsigned value of the
     *    second byte.
     *
     *  - {@see GL46::GL_3_BYTES}: $lists is treated as an array of unsigned
     *    bytes. Each triplet of bytes specifies a single display-list name.
     *    The value of the triplet is computed as 65536 times the unsigned value
     *    of the first byte, plus 256 times the
     *    unsigned value of the second byte, plus the unsigned value of the
     *    third byte.
     *
     *  - {@see GL46::GL_4_BYTES}: $lists is treated as an array of unsigned
     *    bytes. Each quadruplet of bytes specifies a single display-list
     *    name. The value of the quadruplet is computed as 16777216 times the
     *    unsigned value of the first byte, plus
     *    65536 times the unsigned value of the second byte, plus 256 times the
     *    unsigned value of the third byte, plus
     *    the unsigned value of the fourth byte.
     *
     * The list of display-list names is not null-terminated. Rather, $n specifies how many names are to be taken
     * from $lists.
     *
     * An additional level of indirection is made available with the {@see GL46::glListBase} command, which specifies
     * an unsigned offset that is added to each display-list name specified in $lists before that display list is
     * executed.
     *
     * {@see GL46::glCallLists} can appear inside a display list. To avoid the possibility of infinite recursion
     * resulting from display lists calling one another, a limit is placed on the nesting level of display lists
     * during display-list execution. This limit must be at least 64, and it depends on the implementation.
     *
     * GL state is not saved and restored across a call to {@see GL46::glCallLists}. Thus, changes made to GL state
     * during the execution of the display lists remain after execution is completed. Use {@see GL46::glPushAttrib},
     * {@see GL46::glPopAttrib}, {@see GL46::glPushMatrix}, and {@see GL46::glPopMatrix} to preserve GL state across
     * {@see GL46::glCallLists} calls.
     *
     * @see http://docs.gl/gl2/glCallLists
     * @since 1.1
     * @param int $n
     * @param int $type
     * @param \FFI\CData|null $lists
     * @return void
     */
    public function callLists(int $n, int $type, ?\FFI\CData $lists): void
    {
        $this->info->ffi->glCallLists($n, $type, $lists);
    }

    /**
     * {@see GL46::glClear} sets the bitplane area of the window to values previously selected by
     * {@see GL46::glClearColor}, {@see GL46::glClearDepth}, and {@see GL46::glClearStencil}. Multiple color buffers
     * can be cleared simultaneously by selecting more than one buffer at a time using {@see GL46::glDrawBuffer}.
     *
     * The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of
     * {@see GL46::glClear}. The scissor box bounds the cleared region. Alpha function, blend function, logical
     * operation, stenciling, texture mapping, and depth-buffering are ignored by {@see GL46::glClear}.
     *
     * {@see GL46::glClear} takes a single argument that is the bitwise OR of several values indicating which buffer
     * is to be cleared.
     *
     * The values are as follows:
     *
     *  - {@see GL46::GL_COLOR_BUFFER_BIT}: Indicates the buffers currently
     *    enabled for color writing.
     *
     *  - {@see GL46::GL_DEPTH_BUFFER_BIT}: Indicates the depth buffer.
     *
     *  - {@see GL46::GL_STENCIL_BUFFER_BIT}: Indicates the stencil buffer.
     *
     * The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
     *
     * @see http://docs.gl/gl2/glClear
     * @see http://docs.gl/gl4/glClear
     * @since 1.1
     * @param int $mask
     * @return void
     */
    public function clear(int $mask): void
    {
        $this->info->ffi->glClear($mask);
    }

    /**
     * {@see GL46::glClearAccum} specifies the red, green, blue, and alpha values used by {@see GL46::glClear} to
     * clear the accumulation buffer.
     *
     * Values specified by {@see GL46::glClearAccum} are clamped to the range    -1 1  .
     *
     * @see http://docs.gl/gl2/glClearAccum
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @param float $alpha
     * @return void
     */
    public function clearAccum(float $red, float $green, float $blue, float $alpha): void
    {
        $this->info->ffi->glClearAccum($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glClearColor} specifies the red, green, blue, and alpha values used by {@see GL46::glClear} to
     * clear the color buffers. Values specified by {@see GL46::glClearColor} are clamped to the range    0 1  .
     *
     * @see http://docs.gl/gl2/glClearColor
     * @see http://docs.gl/gl4/glClearColor
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @param float $alpha
     * @return void
     */
    public function clearColor(float $red, float $green, float $blue, float $alpha): void
    {
        $this->info->ffi->glClearColor($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glClearDepth} specifies the depth value used by {@see GL46::glClear} to clear the depth buffer.
     * Values specified by {@see GL46::glClearDepth} are clamped to the range    0 1  .
     *
     * @see http://docs.gl/gl2/glClearDepth
     * @see http://docs.gl/gl4/glClearDepth
     * @since 1.1
     * @param float $depth
     * @return void
     */
    public function clearDepth(float $depth): void
    {
        $this->info->ffi->glClearDepth($depth);
    }

    /**
     * {@see GL46::glClearIndex} specifies the index used by {@see GL46::glClear} to clear the color index buffers.
     * $c is not clamped. Rather, $c is converted to a fixed-point value with unspecified precision to the right of
     * the binary point. The integer part of this value is then masked with    2 m  - 1  , where m is the number of
     * bits in a color index stored in the frame buffer.
     *
     * @see http://docs.gl/gl2/glClearIndex
     * @since 1.1
     * @param float $c
     * @return void
     */
    public function clearIndex(float $c): void
    {
        $this->info->ffi->glClearIndex($c);
    }

    /**
     * {@see GL46::glClearStencil} specifies the index used by {@see GL46::glClear} to clear the stencil buffer. $s
     * is masked with    2 m  - 1  , where m is the number of bits in the stencil buffer.
     *
     * @see http://docs.gl/gl2/glClearStencil
     * @see http://docs.gl/gl4/glClearStencil
     * @since 1.1
     * @param int $s
     * @return void
     */
    public function clearStencil(int $s): void
    {
        $this->info->ffi->glClearStencil($s);
    }

    /**
     * Geometry is always clipped against the boundaries of a six-plane frustum in x, y, and z.
     * {@see GL46::glClipPlane} allows the specification of additional planes, not necessarily perpendicular to the
     * x, y, or z axis, against which all geometry is clipped. To determine the maximum number of additional clipping
     * planes, call {@see GL46::glGetIntegerv} with argument {@see GL46::GL_MAX_CLIP_PLANES}. All implementations
     * support at least six such clipping planes. Because the resulting clipping region is the intersection of the
     * defined half-spaces, it is always convex.
     *
     * {@see GL46::glClipPlane} specifies a half-space using a four-component plane equation. When
     * {@see GL46::glClipPlane} is called, $equation is transformed by the inverse of the modelview matrix and stored
     * in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored
     * plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane
     * equation components is positive or zero, the vertex is in with respect to that clipping plane. Otherwise, it
     * is out.
     *
     * To enable and disable clipping planes, call {@see GL46::glEnable} and {@see GL46::glDisable} with the argument
     * {@see GL46::GL_CLIP_PLANE}i, where i is the plane number.
     *
     * All clipping planes are initially defined as (0, 0, 0, 0) in eye coordinates and are disabled.
     *
     * @see http://docs.gl/gl2/glClipPlane
     * @since 1.1
     * @param int $plane
     * @param \FFI\CData|null $equation
     * @return void
     */
    public function clipPlane(int $plane, ?\FFI\CData $equation): void
    {
        $this->info->ffi->glClipPlane($plane, $equation);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3b(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3b($red, $green, $blue);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3bv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3bv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @return void
     */
    public function color3d(float $red, float $green, float $blue): void
    {
        $this->info->ffi->glColor3d($red, $green, $blue);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3dv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @return void
     */
    public function color3f(float $red, float $green, float $blue): void
    {
        $this->info->ffi->glColor3f($red, $green, $blue);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3fv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3i(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3i($red, $green, $blue);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3iv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3s(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3s($red, $green, $blue);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3sv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3ub(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3ub($red, $green, $blue);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl2/glColorTable
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3ubv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3ubv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3ui(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3ui($red, $green, $blue);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3uiv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3uiv($v);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @return void
     */
    public function color3us(int $red, int $green, int $blue): void
    {
        $this->info->ffi->glColor3us($red, $green, $blue);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color3usv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor3usv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4b(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4b($red, $green, $blue, $alpha);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4bv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4bv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @param float $alpha
     * @return void
     */
    public function color4d(float $red, float $green, float $blue, float $alpha): void
    {
        $this->info->ffi->glColor4d($red, $green, $blue, $alpha);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4dv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param float $red
     * @param float $green
     * @param float $blue
     * @param float $alpha
     * @return void
     */
    public function color4f(float $red, float $green, float $blue, float $alpha): void
    {
        $this->info->ffi->glColor4f($red, $green, $blue, $alpha);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4fv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4i(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4i($red, $green, $blue, $alpha);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4iv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4s(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4s($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4sv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4ub(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4ub($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl2/glColorTable
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4ubv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4ubv($v);
    }

    /**
     * The GL stores both a current single-valued color index and a current four-valued RGBA color.
     * {@see GL46::glColor} sets a new four-valued RGBA color. {@see GL46::glColor} has two major variants:
     * {@see GL46::glColor3} and {@see GL46::glColor4}. {@see GL46::glColor3} variants specify new red, green, and
     * blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly.
     * {@see GL46::glColor4} variants specify all four color components explicitly.
     *
     * {@see GL46::glColor3b}, {@see GL46::glColor4b}, {@see GL46::glColor3s}, {@see GL46::glColor4s},
     * {@see GL46::glColor3i}, and {@see GL46::glColor4i} take three or four signed byte, short, or long integers as
     * arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     *
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.
     * Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the
     * largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer
     * color components, when specified, are linearly mapped to floating-point values such that the most positive
     * representable value maps to 1.0, and the most negative representable value maps to   -1.0 . (Note that this
     * mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     *
     * Neither floating-point nor signed integer values are clamped to the range    0 1   before the current color is
     * updated. However, color components are clamped to this range before they are interpolated or written into a
     * color buffer.
     *
     * @see http://docs.gl/gl2/glColor
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4ui(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4ui($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4uiv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4uiv($v);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColor
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function color4us(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColor4us($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function color4usv(?\FFI\CData $v): void
    {
        $this->info->ffi->glColor4usv($v);
    }

    /**
     * {@see GL46::glColorMask} and {@see GL46::glColorMaski} specify whether the individual color components in the
     * frame buffer can or cannot be written. {@see GL46::glColorMaski} sets the mask for a specific draw buffer,
     * whereas {@see GL46::glColorMask} sets the mask for all draw buffers. If $red is {@see GL46::GL_FALSE}, for
     * example, no change is made to the red component of any pixel in any of the color buffers, regardless of the
     * drawing operation attempted.
     *
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled
     * for entire color components.
     *
     * @see http://docs.gl/gl2/glColorMask
     * @see http://docs.gl/gl4/glColorMask
     * @since 1.1
     * @param int $red
     * @param int $green
     * @param int $blue
     * @param int $alpha
     * @return void
     */
    public function colorMask(int $red, int $green, int $blue, int $alpha): void
    {
        $this->info->ffi->glColorMask($red, $green, $blue, $alpha);
    }

    /**
     * {@see GL46::glColorMaterial} specifies which material parameters track the current color. When
     * {@see GL46::GL_COLOR_MATERIAL} is enabled, the material parameter or parameters specified by $mode, of the
     * material or materials specified by $face, track the current color at all times.
     *
     * To enable and disable {@see GL46::GL_COLOR_MATERIAL}, call {@see GL46::glEnable} and {@see GL46::glDisable}
     * with argument {@see GL46::GL_COLOR_MATERIAL}. {@see GL46::GL_COLOR_MATERIAL} is initially disabled.
     *
     * @see http://docs.gl/gl2/glColorMaterial
     * @since 1.1
     * @param int $face
     * @param int $mode
     * @return void
     */
    public function colorMaterial(int $face, int $mode): void
    {
        $this->info->ffi->glColorMaterial($face, $mode);
    }

    /**
     * {@see GL46::glColorPointer} specifies the location and data format of an array of color components to use when
     * rendering. $size specifies the number of components per color, and must be 3 or 4. $type specifies the data
     * type of each color component, and $stride specifies the byte stride from one color to the next, allowing
     * vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage
     * may be more efficient on some implementations; see {@see GL46::glInterleavedArrays}.)
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a color array is specified, $pointer is treated as a byte offset into the
     * buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is saved as
     * color vertex array client-side state ({@see GL46::GL_COLOR_ARRAY_BUFFER_BINDING}).
     *
     * When a color array is specified, $size, $type, $stride, and $pointer are saved as client-side state, in
     * addition to the current vertex array buffer object binding.
     *
     * To enable and disable the color array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_COLOR_ARRAY}. If enabled, the color array
     * is used when {@see GL46::glDrawArrays}, {@see GL46::glMultiDrawArrays}, {@see GL46::glDrawElements},
     * {@see GL46::glMultiDrawElements}, {@see GL46::glDrawRangeElements}, or {@see GL46::glArrayElement} is called.
     *
     * @see http://docs.gl/gl2/glColorPointer
     * @since 1.1
     * @param int $size
     * @param int $type
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function colorPointer(int $size, int $type, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glColorPointer($size, $type, $stride, $pointer);
    }

    /**
     * {@see GL46::glCopyPixels} copies a screen-aligned rectangle of pixels from the specified frame buffer location
     * to a region relative to the current raster position. Its operation is well defined only if the entire pixel
     * source region is within the exposed portion of the window. Results of copies from outside the window, or from
     * regions of the window that are not exposed, are hardware dependent and undefined.
     *
     * $x and $y specify the window coordinates of the lower left corner of the rectangular region to be copied.
     * $width and $height specify the dimensions of the rectangular region to be copied. Both $width and $height must
     * not be negative.
     *
     * Several parameters control the processing of the pixel data while it is being copied. These parameters are set
     * with three commands: {@see GL46::glPixelTransfer}, {@see GL46::glPixelMap}, and {@see GL46::glPixelZoom}. This
     * reference page describes the effects on {@see GL46::glCopyPixels} of most, but not all, of the parameters
     * specified by these three commands.
     *
     * {@see GL46::glCopyPixels} copies values from each pixel with the lower left-hand corner at     x + i   y + j
     *  for    0 &lt;= i &lt; width   and    0 &lt;= j &lt; height  . This pixel is said to be the ith pixel in the
     * jth row. Pixels are copied in row order from the lowest to the highest row, left to right in each row.
     *
     * $type specifies whether color, depth, or stencil data is to be copied. The details of the transfer for each
     * data type are as follows:
     *
     *  - {@see GL46::GL_COLOR}: Indices or RGBA colors are read from the buffer
     *    currently specified as the read source buffer (see
     *    {@see GL46::glReadBuffer}). If the GL is in color index mode, each
     *    index that is read from this buffer is
     *    converted to a fixed-point format with an unspecified number of bits
     *    to the right of the binary point. Each
     *    index is then shifted left by {@see GL46::GL_INDEX_SHIFT} bits, and
     *    added to {@see GL46::GL_INDEX_OFFSET}. If
     *    {@see GL46::GL_INDEX_SHIFT} is negative, the shift is to the right. In
     *    either case, zero bits fill otherwise
     *    unspecified bit locations in the result. If {@see GL46::GL_MAP_COLOR}
     *    is true, the index is replaced with the
     *    value that it references in lookup table {@see
     *    GL46::GL_PIXEL_MAP_I_TO_I}. Whether the lookup replacement of
     *    the index is done or not, the integer part of the index is then ANDed
     *    with    2 b  - 1  , where b is the
     *    number of bits in a color index buffer.   If the GL is in RGBA mode,
     *    the red, green, blue, and alpha
     *    components of each pixel that is read are converted to an internal
     *    floating-point format with unspecified
     *    precision. The conversion maps the largest representable component
     *    value to 1.0, and component value 0 to 0.0.
     *    The resulting floating-point color values are then multiplied by {@see
     *    GL46::GL_c_SCALE} and added to
     *    {@see GL46::GL_c_BIAS}, where c is RED, GREEN, BLUE, and ALPHA for the
     *    respective color components. The
     *    results are clamped to the range [0,1]. If {@see GL46::GL_MAP_COLOR}
     *    is true, each color component is scaled
     *    by the size of lookup table {@see GL46::GL_PIXEL_MAP_c_TO_c}, then
     *    replaced by the value that it references in
     *    that table. c is R, G, B, or A.   If the `ARB_imaging` extension is
     *    supported, the color values may be
     *    additionally processed by color-table lookups, color-matrix
     *    transformations, and convolution filters.   The GL
     *    then converts the resulting indices or RGBA colors to fragments by
     *    attaching the current raster position z
     *    coordinate and texture coordinates to each pixel, then assigning
     *    window coordinates     x r  + i   y r  + j
     *    , where    x r  y r    is the current raster position, and the pixel
     *    was the ith pixel in the jth row. These
     *    pixel fragments are then treated just like the fragments generated by
     *    rasterizing points, lines, or polygons.
     *    Texture mapping, fog, and all the fragment operations are applied
     *    before the fragments are written to the
     *    frame buffer.
     *
     *  - {@see GL46::GL_DEPTH}: Depth values are read from the depth buffer and
     *    converted directly to an internal floating-point format with
     *    unspecified precision. The resulting floating-point depth value is
     *    then multiplied by
     *    {@see GL46::GL_DEPTH_SCALE} and added to {@see GL46::GL_DEPTH_BIAS}.
     *    The result is clamped to the range [0,1].
     *      The GL then converts the resulting depth components to fragments by
     *    attaching the current raster position
     *    color or color index and texture coordinates to each pixel, then
     *    assigning window coordinates     x r  + i   y
     *    r  + j   , where    x r  y r    is the current raster position, and
     *    the pixel was the ith pixel in the jth
     *    row. These pixel fragments are then treated just like the fragments
     *    generated by rasterizing points, lines, or
     *    polygons. Texture mapping, fog, and all the fragment operations are
     *    applied before the fragments are written
     *    to the frame buffer.
     *
     *  - {@see GL46::GL_STENCIL}: Stencil indices are read from the stencil
     *    buffer and converted to an internal fixed-point format with an
     *    unspecified number of bits to the right of the binary point. Each
     *    fixed-point index is then shifted left by
     *    {@see GL46::GL_INDEX_SHIFT} bits, and added to {@see
     *    GL46::GL_INDEX_OFFSET}. If {@see GL46::GL_INDEX_SHIFT} is
     *    negative, the shift is to the right. In either case, zero bits fill
     *    otherwise unspecified bit locations in the
     *    result. If {@see GL46::GL_MAP_STENCIL} is true, the index is replaced
     *    with the value that it references in
     *    lookup table {@see GL46::GL_PIXEL_MAP_S_TO_S}. Whether the lookup
     *    replacement of the index is done or not, the
     *    integer part of the index is then ANDed with    2 b  - 1  , where b is
     *    the number of bits in the stencil
     *    buffer. The resulting stencil indices are then written to the stencil
     *    buffer such that the index read from the
     *    ith location of the jth row is written to location     x r  + i   y r
     *    + j   , where    x r  y r    is the
     *    current raster position. Only the pixel ownership test, the scissor
     *    test, and the stencil writemask affect
     *    these write operations.
     *
     * The rasterization described thus far assumes pixel zoom factors of 1.0. If {@see GL46::glPixelZoom} is used to
     * change the x and y pixel zoom factors, pixels are converted to fragments as follows. If    x r  y r    is the
     * current raster position, and a given pixel is in the ith location in the jth row of the source pixel
     * rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at
     *
     *     x r  +  zoom x   &amp;it; i   y r  +  zoom y   &amp;it; j
     *
     * and
     *
     *     x r  +   zoom x   &amp;af;   i + 1      y r  +   zoom y   &amp;af;   j + 1
     *
     * where   zoom x   is the value of {@see GL46::GL_ZOOM_X} and   zoom y   is the value of {@see GL46::GL_ZOOM_Y}.
     *
     * @see http://docs.gl/gl2/glCopyPixels
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @param int $type
     * @return void
     */
    public function copyPixels(int $x, int $y, int $width, int $height, int $type): void
    {
        $this->info->ffi->glCopyPixels($x, $y, $width, $height, $type);
    }

    /**
     * {@see GL46::glCopyTexImage1D} defines a one-dimensional texture image with pixels from the current
     * {@see GL46::GL_READ_BUFFER}.
     *
     * The screen-aligned pixel row with left corner at    x y   and with a length of  width  defines the texture
     * array at the mipmap level specified by $level. $internalformat specifies the internal format of the texture
     * array.
     *
     * The pixels in the row are processed exactly as if {@see GL46::glReadPixels} had been called, but the process
     * stops just before final conversion. At this point all pixel component values are clamped to the range    0 1
     * and then converted to the texture's internal format for storage in the texel array.
     *
     * Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates.
     *
     * If any of the pixels within the specified row of the current {@see GL46::GL_READ_BUFFER} are outside the
     * window associated with the current rendering context, then the values obtained for those pixels are undefined.
     *
     * {@see GL46::glCopyTexImage1D} defines a one-dimensional texture image with pixels from the current
     * {@see GL46::GL_READ_BUFFER}.
     *
     * When $internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the
     * sRGB color space. In this case, the {@see GL46::glPixelMap} function can be used to accomplish the conversion.
     *
     * @see http://docs.gl/gl2/glCopyTexImage1D
     * @see http://docs.gl/gl4/glCopyTexImage1D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $internalFormat
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $border
     * @return void
     */
    public function copyTexImage1D(int $target, int $level, int $internalFormat, int $x, int $y, int $width, int $border): void
    {
        $this->info->ffi->glCopyTexImage1D($target, $level, $internalFormat, $x, $y, $width, $border);
    }

    /**
     * {@see GL46::glCopyTexImage2D} defines a two-dimensional texture image, or cube-map texture image with pixels
     * from the current {@see GL46::GL_READ_BUFFER}.
     *
     * The screen-aligned pixel rectangle with lower left corner at ($x, $y) and with a width of  width  and a height
     * of  height  defines the texture array at the mipmap level specified by $level. $internalformat specifies the
     * internal format of the texture array.
     *
     * The pixels in the rectangle are processed exactly as if {@see GL46::glReadPixels} had been called, but the
     * process stops just before final conversion. At this point all pixel component values are clamped to the range
     *   0 1   and then converted to the texture's internal format for storage in the texel array.
     *
     * Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.
     *
     * If any of the pixels within the specified rectangle of the current {@see GL46::GL_READ_BUFFER} are outside the
     * window associated with the current rendering context, then the values obtained for those pixels are undefined.
     *
     * When $internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the
     * sRGB color space. In this case, the {@see GL46::glPixelMap} function can be used to accomplish the conversion.
     *
     * @see http://docs.gl/gl2/glCopyTexImage2D
     * @see http://docs.gl/gl4/glCopyTexImage2D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $internalFormat
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @param int $border
     * @return void
     */
    public function copyTexImage2D(int $target, int $level, int $internalFormat, int $x, int $y, int $width, int $height, int $border): void
    {
        $this->info->ffi->glCopyTexImage2D($target, $level, $internalFormat, $x, $y, $width, $height, $border);
    }

    /**
     * {@see GL46::glCopyTexSubImage1D} and {@see GL46::glCopyTextureSubImage1D} replace a portion of a
     * one-dimensional texture image with pixels from the current {@see GL46::GL_READ_BUFFER} (rather than from main
     * memory, as is the case for {@see GL46::glTexSubImage1D}). For {@see GL46::glCopyTexSubImage1D}, the texture
     * object that is bound to $target will be used for the process. For {@see GL46::glCopyTextureSubImage1D},
     * $texture tells which texture object should be used for the purpose of the call.
     *
     * The screen-aligned pixel row with left corner at ($x,\\ $y), and with length $width replaces the portion of
     * the texture array with x indices $xoffset through    xoffset + width - 1   , inclusive. The destination in the
     * texture array may not include any texels outside the texture array as it was originally specified.
     *
     * The pixels in the row are processed exactly as if {@see GL46::glReadPixels} had been called, but the process
     * stops just before final conversion. At this point, all pixel component values are clamped to the range    0 1
     *   and then converted to the texture's internal format for storage in the texel array.
     *
     * It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of
     * the pixels within the specified row of the current {@see GL46::GL_READ_BUFFER} are outside the read window
     * associated with the current rendering context, then the values obtained for those pixels are undefined.
     *
     * No change is made to the internalformat or width parameters of the specified texture array or to texel values
     * outside the specified subregion.
     *
     * @see http://docs.gl/gl2/glCopyTexSubImage1D
     * @see http://docs.gl/gl4/glCopyTexSubImage1D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $xoffset
     * @param int $x
     * @param int $y
     * @param int $width
     * @return void
     */
    public function copyTexSubImage1D(int $target, int $level, int $xoffset, int $x, int $y, int $width): void
    {
        $this->info->ffi->glCopyTexSubImage1D($target, $level, $xoffset, $x, $y, $width);
    }

    /**
     * {@see GL46::glCopyTexSubImage2D} and {@see GL46::glCopyTextureSubImage2D} replace a rectangular portion of a
     * two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of
     * slices of a one-dimensional array texture with pixels from the current {@see GL46::GL_READ_BUFFER} (rather
     * than from main memory, as is the case for {@see GL46::glTexSubImage2D}).
     *
     * The screen-aligned pixel rectangle with lower left corner at    x y   and with width $width and height $height
     * replaces the portion of the texture array with x indices $xoffset through    xoffset + width - 1  , inclusive,
     * and y indices $yoffset through    yoffset + height - 1  , inclusive, at the mipmap level specified by $level.
     *
     * The pixels in the rectangle are processed exactly as if {@see GL46::glReadPixels} had been called, but the
     * process stops just before final conversion. At this point, all pixel component values are clamped to the range
     * $[0,1]$ and then converted to the texture's internal format for storage in the texel array.
     *
     * The destination rectangle in the texture array may not include any texels outside the texture array as it was
     * originally specified. It is not an error to specify a subtexture with zero width or height, but such a
     * specification has no effect.
     *
     * When $target is {@see GL46::GL_TEXTURE_1D_ARRAY} then the y coordinate and height are treated as the start
     * slice and number of slices to modify.
     *
     * If any of the pixels within the specified rectangle of the current {@see GL46::GL_READ_BUFFER} are outside the
     * read window associated with the current rendering context, then the values obtained for those pixels are
     * undefined.
     *
     * No change is made to the internalformat, width, or height, parameters of the specified texture array or to
     * texel values outside the specified subregion.
     *
     * @see http://docs.gl/gl2/glCopyTexSubImage2D
     * @see http://docs.gl/gl4/glCopyTexSubImage2D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $xoffset
     * @param int $yoffset
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @return void
     */
    public function copyTexSubImage2D(int $target, int $level, int $xoffset, int $yoffset, int $x, int $y, int $width, int $height): void
    {
        $this->info->ffi->glCopyTexSubImage2D($target, $level, $xoffset, $yoffset, $x, $y, $width, $height);
    }

    /**
     * {@see GL46::glCullFace} specifies whether front- or back-facing facets are culled (as specified by mode) when
     * facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the
     * {@see GL46::glEnable} and  {@see GL46::glDisable} commands with the argument {@see GL46::GL_CULL_FACE}. Facets
     * include triangles, quadrilaterals, polygons, and rectangles.
     *
     * {@see GL46::glFrontFace} specifies which of the clockwise and counterclockwise facets are front-facing and
     * back-facing. See {@see GL46::glFrontFace}.
     *
     * @see http://docs.gl/gl2/glCullFace
     * @see http://docs.gl/gl4/glCullFace
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function cullFace(int $mode): void
    {
        $this->info->ffi->glCullFace($mode);
    }

    /**
     * {@see GL46::glDeleteLists} causes a contiguous group of display lists to be deleted. $list is the name of the
     * first display list to be deleted, and $range is the number of display lists to delete. All display lists d
     * with    list &lt;= d &lt;=  list + range - 1    are deleted.
     *
     * All storage locations allocated to the specified display lists are freed, and the names are available for
     * reuse at a later time. Names within the range that do not have an associated display list are ignored. If
     * $range is 0, nothing happens.
     *
     * @see http://docs.gl/gl2/glDeleteLists
     * @since 1.1
     * @param int $list
     * @param int $range
     * @return void
     */
    public function deleteLists(int $list, int $range): void
    {
        $this->info->ffi->glDeleteLists($list, $range);
    }

    /**
     * {@see GL46::glDeleteTextures} deletes $n textures named by the elements of the array $textures. After a
     * texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by
     * {@see GL46::glGenTextures}). If a texture that is currently bound is deleted, the binding reverts to 0 (the
     * default texture).
     *
     * {@see GL46::glDeleteTextures} silently ignores 0's and names that do not correspond to existing textures.
     *
     * @see http://docs.gl/gl2/glDeleteTextures
     * @see http://docs.gl/gl4/glDeleteTextures
     * @since 1.1
     * @param int $n
     * @param \FFI\CData|null $textures
     * @return void
     */
    public function deleteTextures(int $n, ?\FFI\CData $textures): void
    {
        $this->info->ffi->glDeleteTextures($n, $textures);
    }

    /**
     * {@see GL46::glDepthFunc} specifies the function used to compare each incoming pixel depth value with the depth
     * value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See
     * {@see GL46::glEnable} and  {@see GL46::glDisable} of {@see GL46::GL_DEPTH_TEST}.)
     *
     * $func specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:
     *
     *  - {@see GL46::GL_NEVER}: Never passes.
     *
     *  - {@see GL46::GL_LESS}: Passes if the incoming depth value is less than
     *    the stored depth value.
     *
     *  - {@see GL46::GL_EQUAL}: Passes if the incoming depth value is equal to
     *    the stored depth value.
     *
     *  - {@see GL46::GL_LEQUAL}: Passes if the incoming depth value is less
     *    than or equal to the stored depth value.
     *
     *  - {@see GL46::GL_GREATER}: Passes if the incoming depth value is greater
     *    than the stored depth value.
     *
     *  - {@see GL46::GL_NOTEQUAL}: Passes if the incoming depth value is not
     *    equal to the stored depth value.
     *
     *  - {@see GL46::GL_GEQUAL}: Passes if the incoming depth value is greater
     *    than or equal to the stored depth value.
     *
     *  - {@see GL46::GL_ALWAYS}: Always passes.
     *
     * The initial value of $func is {@see GL46::GL_LESS}. Initially, depth testing is disabled. If depth testing is
     * disabled or if no depth buffer exists, it is as if the depth test always passes.
     *
     * @see http://docs.gl/gl2/glDepthFunc
     * @see http://docs.gl/gl4/glDepthFunc
     * @since 1.1
     * @param int $func
     * @return void
     */
    public function depthFunc(int $func): void
    {
        $this->info->ffi->glDepthFunc($func);
    }

    /**
     * {@see GL46::glDepthMask} specifies whether the depth buffer is enabled for writing. If $flag is
     * {@see GL46::GL_FALSE}, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer
     * writing is enabled.
     *
     * @see http://docs.gl/gl2/glDepthMask
     * @see http://docs.gl/gl4/glDepthMask
     * @since 1.1
     * @param int $flag
     * @return void
     */
    public function depthMask(int $flag): void
    {
        $this->info->ffi->glDepthMask($flag);
    }

    /**
     * After clipping and division by w, depth coordinates range from   -1  to 1, corresponding to the near and far
     * clipping planes. {@see GL46::glDepthRange} specifies a linear mapping of the normalized depth coordinates in
     * this range to window depth coordinates. Regardless of the actual depth buffer implementation, window
     * coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the
     * values accepted by {@see GL46::glDepthRange} are both clamped to this range before they are accepted.
     *
     * The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer
     * range is fully utilized.
     *
     * @see http://docs.gl/gl2/glDepthRange
     * @see http://docs.gl/gl4/glDepthRange
     * @since 1.1
     * @param float $zNear
     * @param float $zFar
     * @return void
     */
    public function depthRange(float $zNear, float $zFar): void
    {
        $this->info->ffi->glDepthRange($zNear, $zFar);
    }

    /**
     * {@see GL46::glEnable} and {@see GL46::glDisable} enable and disable various capabilities. Use
     * {@see GL46::glIsEnabled} or {@see GL46::glGet} to determine the current setting of any capability. The initial
     * value for each capability with the exception of {@see GL46::GL_DITHER} and {@see GL46::GL_MULTISAMPLE} is
     * {@see GL46::GL_FALSE}. The initial value for {@see GL46::GL_DITHER} and {@see GL46::GL_MULTISAMPLE} is
     * {@see GL46::GL_TRUE}.
     *
     * Both {@see GL46::glEnable} and {@see GL46::glDisable} take a single argument, $cap, which can assume one of
     * the following values:
     *
     * Some of the GL's capabilities are indexed. {@see GL46::glEnablei} and {@see GL46::glDisablei} enable and
     * disable indexed capabilities.
     *
     *  - {@see GL46::GL_BLEND}: If enabled, blend the computed fragment color
     *    values with the values in the color buffers. See
     *    {@see GL46::glBlendFunc}.
     *
     *  - {@see GL46::GL_CLIP_DISTANCEi}: If enabled, clip geometry against
     *    user-defined half space i.
     *
     *  - {@see GL46::GL_COLOR_LOGIC_OP}: If enabled, apply the currently
     *    selected logical operation to the computed fragment color and color
     *    buffer
     *    values. See {@see GL46::glLogicOp}.
     *
     *  - {@see GL46::GL_CULL_FACE}: If enabled, cull polygons based on their
     *    winding in window coordinates. See {@see GL46::glCullFace}.
     *
     *  - {@see GL46::GL_DEBUG_OUTPUT}: If enabled, debug messages are produced
     *    by a debug context. When disabled, the debug message log is
     *    silenced. Note that in a non-debug context, very few, if any messages
     *    might be produced, even when
     *    {@see GL46::GL_DEBUG_OUTPUT} is enabled.
     *
     *  - {@see GL46::GL_DEBUG_OUTPUT_SYNCHRONOUS}: If enabled, debug messages
     *    are produced synchronously by a debug context. If disabled, debug
     *    messages may
     *    be produced asynchronously. In particular, they may be delayed
     *    relative to the execution of GL commands, and
     *    the debug callback function may be called from a thread other than
     *    that in which the commands are executed.
     *    See {@see GL46::glDebugMessageCallback}.
     *
     *  - {@see GL46::GL_DEPTH_CLAMP}: If enabled, the   -wc≤zc≤wc  plane
     *    equation is ignored by view volume clipping (effectively, there is
     *    no near or far plane clipping). See {@see GL46::glDepthRange}.
     *
     *  - {@see GL46::GL_DEPTH_TEST}: If enabled, do depth comparisons and
     *    update the depth buffer. Note that even if the depth buffer exists and
     *    the depth mask is non-zero, the depth buffer is not updated if the
     *    depth test is disabled. See
     *    {@see GL46::glDepthFunc} and {@see GL46::glDepthRange}.
     *
     *  - {@see GL46::GL_DITHER}: If enabled, dither color components or indices
     *    before they are written to the color buffer.
     *
     *  - {@see GL46::GL_FRAMEBUFFER_SRGB}: If enabled and the value of {@see
     *    GL46::GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING} for the framebuffer
     *    attachment corresponding to the destination buffer is {@see
     *    GL46::GL_SRGB}, the R, G, and B destination color
     *    values (after conversion from fixed-point to floating-point) are
     *    considered to be encoded for the sRGB color
     *    space and hence are linearized prior to their use in blending.
     *
     *  - {@see GL46::GL_LINE_SMOOTH}: If enabled, draw lines with correct
     *    filtering. Otherwise, draw aliased lines. See {@see
     *    GL46::glLineWidth}.
     *
     *  - {@see GL46::GL_MULTISAMPLE}: If enabled, use multiple fragment samples
     *    in computing the final color of a pixel. See
     *    {@see GL46::glSampleCoverage}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_FILL}: If enabled, and if the polygon is
     *    rendered in {@see GL46::GL_FILL} mode, an offset is added to depth
     *    values
     *    of a polygon's fragments before the depth comparison is performed. See
     *    {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_LINE}: If enabled, and if the polygon is
     *    rendered in {@see GL46::GL_LINE} mode, an offset is added to depth
     *    values
     *    of a polygon's fragments before the depth comparison is performed. See
     *    {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_POINT}: If enabled, an offset is added
     *    to depth values of a polygon's fragments before the depth comparison
     *    is
     *    performed, if the polygon is rendered in {@see GL46::GL_POINT} mode.
     *    See {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_SMOOTH}: If enabled, draw polygons with proper
     *    filtering. Otherwise, draw aliased polygons. For correct antialiased
     *    polygons, an alpha buffer is needed and the polygons must be sorted
     *    front to back.
     *
     *  - {@see GL46::GL_PRIMITIVE_RESTART}: Enables primitive restarting. If
     *    enabled, any one of the draw commands which transfers a set of generic
     *    attribute array elements to the GL will restart the primitive when the
     *    index of the vertex is equal to the
     *    primitive restart index. See {@see GL46::glPrimitiveRestartIndex}.
     *
     *  - {@see GL46::GL_PRIMITIVE_RESTART_FIXED_INDEX}: Enables primitive
     *    restarting with a fixed index. If enabled, any one of the draw
     *    commands which transfers a
     *    set of generic attribute array elements to the GL will restart the
     *    primitive when the index of the vertex is
     *    equal to the fixed primitive index for the specified index type. The
     *    fixed index is equal to 2n−1 where n is
     *    equal to 8 for {@see GL46::GL_UNSIGNED_BYTE}, 16 for {@see
     *    GL46::GL_UNSIGNED_SHORT} and 32 for
     *    {@see GL46::GL_UNSIGNED_INT}.
     *
     *  - {@see GL46::GL_RASTERIZER_DISCARD}: If enabled, primitives are
     *    discarded after the optional transform feedback stage, but before
     *    rasterization.
     *    Furthermore, when enabled, {@see GL46::glClear}, {@see
     *    GL46::glClearBufferData},
     *    {@see GL46::glClearBufferSubData}, {@see GL46::glClearTexImage}, and
     *    {@see GL46::glClearTexSubImage} are
     *    ignored.
     *
     *  - {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE}: If enabled, compute a
     *    temporary coverage value where each bit is determined by the alpha
     *    value at the
     *    corresponding sample location. The temporary coverage value is then
     *    ANDed with the fragment coverage value.
     *
     *  - {@see GL46::GL_SAMPLE_ALPHA_TO_ONE}: If enabled, each sample alpha
     *    value is replaced by the maximum representable alpha value.
     *
     *  - {@see GL46::GL_SAMPLE_COVERAGE}: If enabled, the fragment's coverage
     *    is ANDed with the temporary coverage value. If
     *    {@see GL46::GL_SAMPLE_COVERAGE_INVERT} is set to {@see GL46::GL_TRUE},
     *    invert the coverage value. See
     *    {@see GL46::glSampleCoverage}.
     *
     *  - {@see GL46::GL_SAMPLE_SHADING}: If enabled, the active fragment shader
     *    is run once for each covered sample, or at fraction of this rate as
     *    determined by the current value of {@see
     *    GL46::GL_MIN_SAMPLE_SHADING_VALUE}. See
     *    {@see GL46::glMinSampleShading}.
     *
     *  - {@see GL46::GL_SAMPLE_MASK}: If enabled, the sample coverage mask
     *    generated for a fragment during rasterization will be ANDed with the
     *    value of {@see GL46::GL_SAMPLE_MASK_VALUE} before shading occurs. See
     *    {@see GL46::glSampleMaski}.
     *
     *  - {@see GL46::GL_SCISSOR_TEST}: If enabled, discard fragments that are
     *    outside the scissor rectangle. See {@see GL46::glScissor}.
     *
     *  - {@see GL46::GL_STENCIL_TEST}: If enabled, do stencil testing and
     *    update the stencil buffer. See {@see GL46::glStencilFunc} and
     *    {@see GL46::glStencilOp}.
     *
     *  - {@see GL46::GL_TEXTURE_CUBE_MAP_SEAMLESS}: If enabled, cubemap
     *    textures are sampled such that when linearly sampling from the border
     *    between two
     *    adjacent faces, texels from both faces are used to generate the final
     *    sample value. When disabled, texels from
     *    only a single face are used to construct the final sample value.
     *
     *  - {@see GL46::GL_PROGRAM_POINT_SIZE}: If enabled and a vertex or
     *    geometry shader is active, then the derived point size is taken from
     *    the
     *    (potentially clipped) shader builtin {@see GL46::gl_PointSize} and
     *    clamped to the implementation-dependent
     *    point size range.
     *
     * @see http://docs.gl/gl2/glEnable
     * @see http://docs.gl/gl4/glEnable
     * @since 1.1
     * @param int $cap
     * @return void
     */
    public function disable(int $cap): void
    {
        $this->info->ffi->glDisable($cap);
    }

    /**
     * {@see GL46::glEnableClientState} and {@see GL46::glDisableClientState} enable or disable individual
     * client-side capabilities. By default, all client-side capabilities are disabled. Both
     * {@see GL46::glEnableClientState} and {@see GL46::glDisableClientState} take a single argument, $cap, which can
     * assume one of the following values:
     *
     *  - {@see GL46::GL_COLOR_ARRAY}: If enabled, the color array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glColorPointer}.
     *
     *  - {@see GL46::GL_EDGE_FLAG_ARRAY}: If enabled, the edge flag array is
     *    enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glEdgeFlagPointer}.
     *
     *  - {@see GL46::GL_FOG_COORD_ARRAY}: If enabled, the fog coordinate array
     *    is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glFogCoordPointer}.
     *
     *  - {@see GL46::GL_INDEX_ARRAY}: If enabled, the index array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glIndexPointer}.
     *
     *  - {@see GL46::GL_NORMAL_ARRAY}: If enabled, the normal array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glNormalPointer}.
     *
     *  - {@see GL46::GL_SECONDARY_COLOR_ARRAY}: If enabled, the secondary color
     *    array is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glColorPointer}.
     *
     *  - {@see GL46::GL_TEXTURE_COORD_ARRAY}: If enabled, the texture
     *    coordinate array is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glTexCoordPointer}.
     *
     *  - {@see GL46::GL_VERTEX_ARRAY}: If enabled, the vertex array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glVertexPointer}.
     *
     * @see http://docs.gl/gl2/glEnableClientState
     * @since 1.1
     * @param int $array
     * @return void
     */
    public function disableClientState(int $array): void
    {
        $this->info->ffi->glDisableClientState($array);
    }

    /**
     * {@see GL46::glDrawArrays} specifies multiple geometric primitives with very few subroutine calls. Instead of
     * calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you
     * can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of
     * primitives with a single call to {@see GL46::glDrawArrays}.
     *
     * When {@see GL46::glDrawArrays} is called, it uses $count sequential elements from each enabled array to
     * construct a sequence of geometric primitives, beginning with element $first. $mode specifies what kind of
     * primitives are constructed and how the array elements construct those primitives.
     *
     * Vertex attributes that are modified by {@see GL46::glDrawArrays} have an unspecified value after
     * {@see GL46::glDrawArrays} returns. Attributes that aren't modified remain well defined.
     *
     * @see http://docs.gl/gl2/glDrawArrays
     * @see http://docs.gl/gl4/glDrawArrays
     * @since 1.1
     * @param int $mode
     * @param int $first
     * @param int $count
     * @return void
     */
    public function drawArrays(int $mode, int $first, int $count): void
    {
        $this->info->ffi->glDrawArrays($mode, $first, $count);
    }

    /**
     * When colors are written to the frame buffer, they are written into the color buffers specified by
     * {@see GL46::glDrawBuffer}. One of the following values can be used for default framebuffer:
     *
     *  - {@see GL46::GL_NONE}: No color buffers are written.
     *
     *  - {@see GL46::GL_FRONT_LEFT}: Only the front left color buffer is
     *    written.
     *
     *  - {@see GL46::GL_FRONT_RIGHT}: Only the front right color buffer is
     *    written.
     *
     *  - {@see GL46::GL_BACK_LEFT}: Only the back left color buffer is written.
     *
     *  - {@see GL46::GL_BACK_RIGHT}: Only the back right color buffer is
     *    written.
     *
     *  - {@see GL46::GL_FRONT}: Only the front left and front right color
     *    buffers are written. If there is no front right color buffer, only
     *    the front left color buffer is written.
     *
     *  - {@see GL46::GL_BACK}: Only the back left and back right color buffers
     *    are written. If there is no back right color buffer, only the
     *    back left color buffer is written.
     *
     *  - {@see GL46::GL_LEFT}: Only the front left and back left color buffers
     *    are written. If there is no back left color buffer, only the
     *    front left color buffer is written.
     *
     *  - {@see GL46::GL_RIGHT}: Only the front right and back right color
     *    buffers are written. If there is no back right color buffer, only
     *    the front right color buffer is written.
     *
     *  - {@see GL46::GL_FRONT_AND_BACK}: All the front and back color buffers
     *    (front left, front right, back left, back right) are written. If there
     *    are no back color buffers, only the front left and front right color
     *    buffers are written. If there are no
     *    right color buffers, only the front left and back left color buffers
     *    are written. If there are no right or
     *    back color buffers, only the front left color buffer is written.
     *
     * If more than one color buffer is selected for drawing, then blending or logical operations are computed and
     * applied independently for each color buffer and can produce different results in each buffer.
     *
     * Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers.
     * Likewise, single-buffered contexts include only front buffers, and double-buffered contexts include both front
     * and back buffers. The context is selected at GL initialization.
     *
     * For framebuffer objects, {@see GL46::GL_COLOR_ATTACHMENT$m$} and {@see GL46::GL_NONE} enums are accepted,
     * where {@see GL46::$m$} is a value between 0 and {@see GL46::GL_MAX_COLOR_ATTACHMENTS}. glDrawBuffer will set
     * the draw buffer for fragment colors other than zero to {@see GL46::GL_NONE}.
     *
     * @see http://docs.gl/gl2/glDrawBuffer
     * @see http://docs.gl/gl4/glDrawBuffer
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function drawBuffer(int $mode): void
    {
        $this->info->ffi->glDrawBuffer($mode);
    }

    /**
     * {@see GL46::glDrawElements} specifies multiple geometric primitives with very few subroutine calls. Instead of
     * calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can
     * prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives
     * with a single call to {@see GL46::glDrawElements}.
     *
     * When {@see GL46::glDrawElements} is called, it uses $count sequential elements from an enabled array, starting
     * at $indices to construct a sequence of geometric primitives. $mode specifies what kind of primitives are
     * constructed and how the array elements construct these primitives. If more than one array is enabled, each is
     * used.
     *
     * Vertex attributes that are modified by {@see GL46::glDrawElements} have an unspecified value after
     * {@see GL46::glDrawElements} returns. Attributes that aren't modified maintain their previous values.
     *
     * @see http://docs.gl/gl2/glDrawElements
     * @see http://docs.gl/gl4/glDrawElements
     * @since 1.1
     * @param int $mode
     * @param int $count
     * @param int $type
     * @param \FFI\CData|null $indices
     * @return void
     */
    public function drawElements(int $mode, int $count, int $type, ?\FFI\CData $indices): void
    {
        $this->info->ffi->glDrawElements($mode, $count, $type, $indices);
    }

    /**
     * {@see GL46::glDrawPixels} reads pixel data from memory and writes it into the frame buffer relative to the
     * current raster position, provided that the raster position is valid. Use {@see GL46::glRasterPos} or
     * {@see GL46::glWindowPos} to set the current raster position; use {@see GL46::glGet} with argument
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} to determine if the specified raster position is valid, and
     * {@see GL46::glGet} with argument {@see GL46::GL_CURRENT_RASTER_POSITION} to query the raster position.
     *
     * Several parameters define the encoding of pixel data in memory and control the processing of the pixel data
     * before it is placed in the frame buffer. These parameters are set with four commands:
     * {@see GL46::glPixelStore}, {@see GL46::glPixelTransfer}, {@see GL46::glPixelMap}, and
     * {@see GL46::glPixelZoom}. This reference page describes the effects on {@see GL46::glDrawPixels} of many, but
     * not all, of the parameters specified by these four commands.
     *
     * Data is read from $data as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or
     * unsigned integers, or single-precision floating-point values, depending on $type. When $type is one of
     * {@see GL46::GL_UNSIGNED_BYTE}, {@see GL46::GL_BYTE}, {@see GL46::GL_UNSIGNED_SHORT}, {@see GL46::GL_SHORT},
     * {@see GL46::GL_UNSIGNED_INT}, {@see GL46::GL_INT}, or {@see GL46::GL_FLOAT} each of these bytes, shorts,
     * integers, or floating-point values is interpreted as one color or depth component, or one index, depending on
     * $format. When $type is one of {@see GL46::GL_UNSIGNED_BYTE_3_3_2}, {@see GL46::GL_UNSIGNED_SHORT_5_6_5},
     * {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4}, {@see GL46::GL_UNSIGNED_SHORT_5_5_5_1},
     * {@see GL46::GL_UNSIGNED_INT_8_8_8_8}, or {@see GL46::GL_UNSIGNED_INT_10_10_10_2}, each unsigned value is
     * interpreted as containing all the components for a single pixel, with the color components arranged according
     * to $format. When $type is one of {@see GL46::GL_UNSIGNED_BYTE_2_3_3_REV},
     * {@see GL46::GL_UNSIGNED_SHORT_5_6_5_REV}, {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4_REV},
     * {@see GL46::GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@see GL46::GL_UNSIGNED_INT_8_8_8_8_REV}, or
     * {@see GL46::GL_UNSIGNED_INT_2_10_10_10_REV}, each unsigned value is interpreted as containing all color
     * components, specified by $format, for a single pixel in a reversed order. Indices are always treated
     * individually. Color components are treated as groups of one, two, three, or four values, again based on
     * $format. Both individual indices and groups of components are referred to as pixels. If $type is
     * {@see GL46::GL_BITMAP}, the data must be unsigned bytes, and $format must be either
     * {@see GL46::GL_COLOR_INDEX} or {@see GL46::GL_STENCIL_INDEX}. Each unsigned byte is treated as eight 1-bit
     * pixels, with bit ordering determined by {@see GL46::GL_UNPACK_LSB_FIRST} (see {@see GL46::glPixelStore}).
     *
     *    width × height   pixels are read from memory, starting at location $data. By default, these pixels are
     * taken from adjacent memory locations, except that after all $width pixels are read, the read pointer is
     * advanced to the next four-byte boundary. The four-byte row alignment is specified by {@see GL46::glPixelStore}
     * with argument {@see GL46::GL_UNPACK_ALIGNMENT}, and it can be set to one, two, four, or eight bytes. Other
     * pixel store parameters specify different read pointer advancements, both before the first pixel is read and
     * after all $width pixels are read. See the {@see GL46::glPixelStore} reference page for details on these
     * options.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a block of pixels is specified, $data is treated as a byte offset into the
     * buffer object's data store.
     *
     * The    width × height   pixels that are read from memory are each operated on in the same way, based on the
     * values of several parameters specified by {@see GL46::glPixelTransfer} and {@see GL46::glPixelMap}. The
     * details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the
     * format of the pixels, as specified by $format. $format can assume one of 13 symbolic values:
     *
     *  - {@see GL46::GL_COLOR_INDEX}: Each pixel is a single value, a color
     *    index. It is converted to fixed-point format, with an unspecified
     *    number of bits to the right of the binary point, regardless of the
     *    memory data type. Floating-point values
     *    convert to true fixed-point values. Signed and unsigned integer data
     *    is converted with all fraction bits set
     *    to 0. Bitmap data convert to either 0 or 1.   Each fixed-point index
     *    is then shifted left by
     *    {@see GL46::GL_INDEX_SHIFT} bits and added to {@see
     *    GL46::GL_INDEX_OFFSET}. If {@see GL46::GL_INDEX_SHIFT} is
     *    negative, the shift is to the right. In either case, zero bits fill
     *    otherwise unspecified bit locations in the
     *    result.   If the GL is in RGBA mode, the resulting index is converted
     *    to an RGBA pixel with the help of the
     *    {@see GL46::GL_PIXEL_MAP_I_TO_R}, {@see GL46::GL_PIXEL_MAP_I_TO_G},
     *    {@see GL46::GL_PIXEL_MAP_I_TO_B}, and
     *    {@see GL46::GL_PIXEL_MAP_I_TO_A} tables. If the GL is in color index
     *    mode, and if {@see GL46::GL_MAP_COLOR} is
     *    true, the index is replaced with the value that it references in
     *    lookup table
     *    {@see GL46::GL_PIXEL_MAP_I_TO_I}. Whether the lookup replacement of
     *    the index is done or not, the integer part
     *    of the index is then ANDed with    2 b  - 1  , where b is the number
     *    of bits in a color index buffer.   The GL
     *    then converts the resulting indices or RGBA colors to fragments by
     *    attaching the current raster position z
     *    coordinate and texture coordinates to each pixel, then assigning x and
     *    y window coordinates to the nth
     *    fragment such that    x n  =  x r  +  n % width         y n  =  y r  +
     *    &amp;LeftFloor;&amp;RightFloor;  n
     *    width           where    x r  y r    is the current raster position.
     *    These pixel fragments are then treated
     *    just like the fragments generated by rasterizing points, lines, or
     *    polygons. Texture mapping, fog, and all the
     *    fragment operations are applied before the fragments are written to
     *    the frame buffer.
     *
     *  - {@see GL46::GL_STENCIL_INDEX}: Each pixel is a single value, a stencil
     *    index. It is converted to fixed-point format, with an unspecified
     *    number of bits to the right of the binary point, regardless of the
     *    memory data type. Floating-point values
     *    convert to true fixed-point values. Signed and unsigned integer data
     *    is converted with all fraction bits set
     *    to 0. Bitmap data convert to either 0 or 1.   Each fixed-point index
     *    is then shifted left by
     *    {@see GL46::GL_INDEX_SHIFT} bits, and added to {@see
     *    GL46::GL_INDEX_OFFSET}. If {@see GL46::GL_INDEX_SHIFT} is
     *    negative, the shift is to the right. In either case, zero bits fill
     *    otherwise unspecified bit locations in the
     *    result. If {@see GL46::GL_MAP_STENCIL} is true, the index is replaced
     *    with the value that it references in
     *    lookup table {@see GL46::GL_PIXEL_MAP_S_TO_S}. Whether the lookup
     *    replacement of the index is done or not, the
     *    integer part of the index is then ANDed with    2 b  - 1  , where b is
     *    the number of bits in the stencil
     *    buffer. The resulting stencil indices are then written to the stencil
     *    buffer such that the nth index is
     *    written to location      x n  =  x r  +  n % width         y n  =  y r
     *     + &amp;LeftFloor;&amp;RightFloor;  n
     *    width         where    x r  y r    is the current raster position.
     *    Only the pixel ownership test, the scissor
     *    test, and the stencil writemask affect these write operations.
     *
     *  - {@see GL46::GL_DEPTH_COMPONENT}: Each pixel is a single-depth
     *    component. Floating-point data is converted directly to an internal
     *    floating-point format with unspecified precision. Signed integer data
     *    is mapped linearly to the internal
     *    floating-point format such that the most positive representable
     *    integer value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Unsigned integer data is
     *    mapped similarly: the largest integer
     *    value maps to 1.0, and 0 maps to 0.0. The resulting floating-point
     *    depth value is then multiplied by
     *    {@see GL46::GL_DEPTH_SCALE} and added to {@see GL46::GL_DEPTH_BIAS}.
     *    The result is clamped to the range    0 1
     *     .   The GL then converts the resulting depth components to fragments
     *    by attaching the current raster position
     *    color or color index and texture coordinates to each pixel, then
     *    assigning x and y window coordinates to the
     *    nth fragment such that      x n  =  x r  +  n % width         y n  =
     *    y r  + &amp;LeftFloor;&amp;RightFloor;
     *    n width         where    x r  y r    is the current raster position.
     *    These pixel fragments are then treated
     *    just like the fragments generated by rasterizing points, lines, or
     *    polygons. Texture mapping, fog, and all the
     *    fragment operations are applied before the fragments are written to
     *    the frame buffer.
     *
     *  - {@see GL46::GL_RGBA}:
     *
     *  - {@see GL46::GL_BGRA}: Each pixel is a four-component group: For {@see
     *    GL46::GL_RGBA}, the red component is first, followed by
     *    green, followed by blue, followed by alpha; for {@see GL46::GL_BGRA}
     *    the order is blue, green, red and then
     *    alpha. Floating-point values are converted directly to an internal
     *    floating-point format with unspecified
     *    precision. Signed integer values are mapped linearly to the internal
     *    floating-point format such that the most
     *    positive representable integer value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 .
     *    (Note that this mapping does not convert 0 precisely to 0.0.) Unsigned
     *    integer data is mapped similarly: The
     *    largest integer value maps to 1.0, and 0 maps to 0.0. The resulting
     *    floating-point color values are then
     *    multiplied by {@see GL46::GL_c_SCALE} and added to {@see
     *    GL46::GL_c_BIAS}, where c is RED, GREEN, BLUE, and
     *    ALPHA for the respective color components. The results are clamped to
     *    the range    0 1  .   If
     *    {@see GL46::GL_MAP_COLOR} is true, each color component is scaled by
     *    the size of lookup table
     *    {@see GL46::GL_PIXEL_MAP_c_TO_c}, then replaced by the value that it
     *    references in that table. c is R, G, B,
     *    or A respectively.   The GL then converts the resulting RGBA colors to
     *    fragments by attaching the current
     *    raster position z coordinate and texture coordinates to each pixel,
     *    then assigning x and y window coordinates
     *    to the nth fragment such that      x n  =  x r  +  n % width         y
     *    n  =  y r  +
     *    &amp;LeftFloor;&amp;RightFloor;  n width         where    x r  y r
     *    is the current raster position. These
     *    pixel fragments are then treated just like the fragments generated by
     *    rasterizing points, lines, or polygons.
     *    Texture mapping, fog, and all the fragment operations are applied
     *    before the fragments are written to the
     *    frame buffer.
     *
     *  - {@see GL46::GL_RED}: Each pixel is a single red component. This
     *    component is converted to the internal floating-point format in
     *    the same way the red component of an RGBA pixel is. It is then
     *    converted to an RGBA pixel with green and blue
     *    set to 0, and alpha set to 1. After this conversion, the pixel is
     *    treated as if it had been read as an RGBA
     *    pixel.
     *
     *  - {@see GL46::GL_GREEN}: Each pixel is a single green component. This
     *    component is converted to the internal floating-point format in
     *    the same way the green component of an RGBA pixel is. It is then
     *    converted to an RGBA pixel with red and blue
     *    set to 0, and alpha set to 1. After this conversion, the pixel is
     *    treated as if it had been read as an RGBA
     *    pixel.
     *
     *  - {@see GL46::GL_BLUE}: Each pixel is a single blue component. This
     *    component is converted to the internal floating-point format in
     *    the same way the blue component of an RGBA pixel is. It is then
     *    converted to an RGBA pixel with red and green
     *    set to 0, and alpha set to 1. After this conversion, the pixel is
     *    treated as if it had been read as an RGBA
     *    pixel.
     *
     *  - {@see GL46::GL_ALPHA}: Each pixel is a single alpha component. This
     *    component is converted to the internal floating-point format in
     *    the same way the alpha component of an RGBA pixel is. It is then
     *    converted to an RGBA pixel with red, green,
     *    and blue set to 0. After this conversion, the pixel is treated as if
     *    it had been read as an RGBA pixel.
     *
     *  - {@see GL46::GL_RGB}:
     *
     *  - {@see GL46::GL_BGR}: Each pixel is a three-component group: red first,
     *    followed by green, followed by blue; for
     *    {@see GL46::GL_BGR}, the first component is blue, followed by green
     *    and then red. Each component is converted
     *    to the internal floating-point format in the same way the red, green,
     *    and blue components of an RGBA pixel
     *    are. The color triple is converted to an RGBA pixel with alpha set to
     *    1. After this conversion, the pixel is
     *    treated as if it had been read as an RGBA pixel.
     *
     *  - {@see GL46::GL_LUMINANCE}: Each pixel is a single luminance component.
     *    This component is converted to the internal floating-point format
     *    in the same way the red component of an RGBA pixel is. It is then
     *    converted to an RGBA pixel with red, green,
     *    and blue set to the converted luminance value, and alpha set to 1.
     *    After this conversion, the pixel is treated
     *    as if it had been read as an RGBA pixel.
     *
     *  - {@see GL46::GL_LUMINANCE_ALPHA}: Each pixel is a two-component group:
     *    luminance first, followed by alpha. The two components are converted
     *    to
     *    the internal floating-point format in the same way the red component
     *    of an RGBA pixel is. They are then
     *    converted to an RGBA pixel with red, green, and blue set to the
     *    converted luminance value, and alpha set to
     *    the converted alpha value. After this conversion, the pixel is treated
     *    as if it had been read as an RGBA
     *    pixel.
     *
     * The following table summarizes the meaning of the valid constants for the type parameter:
     *
     *        Type   Corresponding Type       {@see GL46::GL_UNSIGNED_BYTE}   unsigned 8-bit integer
     * {@see GL46::GL_BYTE}   signed 8-bit integer     {@see GL46::GL_BITMAP}   single bits in unsigned 8-bit
     * integers     {@see GL46::GL_UNSIGNED_SHORT}   unsigned 16-bit integer     {@see GL46::GL_SHORT}   signed
     * 16-bit integer     {@see GL46::GL_UNSIGNED_INT}   unsigned 32-bit integer     {@see GL46::GL_INT}   32-bit
     * integer     {@see GL46::GL_FLOAT}   single-precision floating-point     {@see GL46::GL_UNSIGNED_BYTE_3_3_2}
     * unsigned 8-bit integer     {@see GL46::GL_UNSIGNED_BYTE_2_3_3_REV}   unsigned 8-bit integer with reversed
     * component ordering     {@see GL46::GL_UNSIGNED_SHORT_5_6_5}   unsigned 16-bit integer
     * {@see GL46::GL_UNSIGNED_SHORT_5_6_5_REV}   unsigned 16-bit integer with reversed component ordering
     * {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4}   unsigned 16-bit integer
     * {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4_REV}   unsigned 16-bit integer with reversed component ordering
     * {@see GL46::GL_UNSIGNED_SHORT_5_5_5_1}   unsigned 16-bit integer
     * {@see GL46::GL_UNSIGNED_SHORT_1_5_5_5_REV}   unsigned 16-bit integer with reversed component ordering
     * {@see GL46::GL_UNSIGNED_INT_8_8_8_8}   unsigned 32-bit integer     {@see GL46::GL_UNSIGNED_INT_8_8_8_8_REV}
     * unsigned 32-bit integer with reversed component ordering     {@see GL46::GL_UNSIGNED_INT_10_10_10_2}
     * unsigned 32-bit integer     {@see GL46::GL_UNSIGNED_INT_2_10_10_10_REV}   unsigned 32-bit integer with
     * reversed component ordering
     *
     * The rasterization described so far assumes pixel zoom factors of 1. If {@see GL46::glPixelZoom} is used to
     * change the x and y pixel zoom factors, pixels are converted to fragments as follows. If    x r  y r    is the
     * current raster position, and a given pixel is in the nth column and mth row of the pixel rectangle, then
     * fragments are generated for pixels whose centers are in the rectangle with corners at
     *
     *     x r  +  zoom x   &amp;it; n   y r  +  zoom y   &amp;it; m         x r  +   zoom x   &amp;af;   n + 1
     * y r  +   zoom y   &amp;af;   m + 1
     *
     * where   zoom x   is the value of {@see GL46::GL_ZOOM_X} and   zoom y   is the value of {@see GL46::GL_ZOOM_Y}.
     *
     * @see http://docs.gl/gl2/glDrawPixels
     * @since 1.1
     * @param int $width
     * @param int $height
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function drawPixels(int $width, int $height, int $format, int $type, ?\FFI\CData $pixels): void
    {
        $this->info->ffi->glDrawPixels($width, $height, $format, $type, $pixels);
    }

    /**
     * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a
     * {@see GL46::glBegin}/{@see GL46::glEnd} pair is marked as the start of either a boundary or nonboundary edge.
     * If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary
     * edge. Otherwise, the vertex is marked as the start of a nonboundary edge. {@see GL46::glEdgeFlag} sets the
     * edge flag bit to {@see GL46::GL_TRUE} if $flag is {@see GL46::GL_TRUE} and to {@see GL46::GL_FALSE} otherwise.
     *
     * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of
     * the value of the edge flag.
     *
     * Boundary and nonboundary edge flags on vertices are significant only if {@see GL46::GL_POLYGON_MODE} is set to
     * {@see GL46::GL_POINT} or {@see GL46::GL_LINE}. See {@see GL46::glPolygonMode}.
     *
     * @see http://docs.gl/gl2/glEdgeFlag
     * @since 1.1
     * @param int $flag
     * @return void
     */
    public function edgeFlag(int $flag): void
    {
        $this->info->ffi->glEdgeFlag($flag);
    }

    /**
     * {@see GL46::glEdgeFlagPointer} specifies the location and data format of an array of boolean edge flags to use
     * when rendering. $stride specifies the byte stride from one edge flag to the next, allowing vertices and
     * attributes to be packed into a single array or stored in separate arrays.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while an edge flag array is specified, $pointer is treated as a byte offset into
     * the buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is
     * saved as edge flag vertex array client-side state ({@see GL46::GL_EDGE_FLAG_ARRAY_BUFFER_BINDING}).
     *
     * When an edge flag array is specified, $stride and $pointer are saved as client-side state, in addition to the
     * current vertex array buffer object binding.
     *
     * To enable and disable the edge flag array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_EDGE_FLAG_ARRAY}. If enabled, the edge flag
     * array is used when {@see GL46::glDrawArrays}, {@see GL46::glMultiDrawArrays}, {@see GL46::glDrawElements},
     * {@see GL46::glMultiDrawElements}, {@see GL46::glDrawRangeElements}, or {@see GL46::glArrayElement} is called.
     *
     * @see http://docs.gl/gl2/glEdgeFlagPointer
     * @since 1.1
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function edgeFlagPointer(int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glEdgeFlagPointer($stride, $pointer);
    }

    /**
     * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a
     * {@see GL46::glBegin}/{@see GL46::glEnd} pair is marked as the start of either a boundary or nonboundary edge.
     * If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary
     * edge. Otherwise, the vertex is marked as the start of a nonboundary edge. {@see GL46::glEdgeFlag} sets the
     * edge flag bit to {@see GL46::GL_TRUE} if $flag is {@see GL46::GL_TRUE} and to {@see GL46::GL_FALSE} otherwise.
     *
     * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of
     * the value of the edge flag.
     *
     * Boundary and nonboundary edge flags on vertices are significant only if {@see GL46::GL_POLYGON_MODE} is set to
     * {@see GL46::GL_POINT} or {@see GL46::GL_LINE}. See {@see GL46::glPolygonMode}.
     *
     * @see http://docs.gl/gl2/glEdgeFlag
     * @since 1.1
     * @param \FFI\CData|null $flag
     * @return void
     */
    public function edgeFlagv(?\FFI\CData $flag): void
    {
        $this->info->ffi->glEdgeFlagv($flag);
    }

    /**
     * {@see GL46::glEnable} and {@see GL46::glDisable} enable and disable various capabilities. Use
     * {@see GL46::glIsEnabled} or {@see GL46::glGet} to determine the current setting of any capability. The initial
     * value for each capability with the exception of {@see GL46::GL_DITHER} and {@see GL46::GL_MULTISAMPLE} is
     * {@see GL46::GL_FALSE}. The initial value for {@see GL46::GL_DITHER} and {@see GL46::GL_MULTISAMPLE} is
     * {@see GL46::GL_TRUE}.
     *
     * Both {@see GL46::glEnable} and {@see GL46::glDisable} take a single argument, $cap, which can assume one of
     * the following values:
     *
     * Some of the GL's capabilities are indexed. {@see GL46::glEnablei} and {@see GL46::glDisablei} enable and
     * disable indexed capabilities.
     *
     *  - {@see GL46::GL_BLEND}: If enabled, blend the computed fragment color
     *    values with the values in the color buffers. See
     *    {@see GL46::glBlendFunc}.
     *
     *  - {@see GL46::GL_CLIP_DISTANCEi}: If enabled, clip geometry against
     *    user-defined half space i.
     *
     *  - {@see GL46::GL_COLOR_LOGIC_OP}: If enabled, apply the currently
     *    selected logical operation to the computed fragment color and color
     *    buffer
     *    values. See {@see GL46::glLogicOp}.
     *
     *  - {@see GL46::GL_CULL_FACE}: If enabled, cull polygons based on their
     *    winding in window coordinates. See {@see GL46::glCullFace}.
     *
     *  - {@see GL46::GL_DEBUG_OUTPUT}: If enabled, debug messages are produced
     *    by a debug context. When disabled, the debug message log is
     *    silenced. Note that in a non-debug context, very few, if any messages
     *    might be produced, even when
     *    {@see GL46::GL_DEBUG_OUTPUT} is enabled.
     *
     *  - {@see GL46::GL_DEBUG_OUTPUT_SYNCHRONOUS}: If enabled, debug messages
     *    are produced synchronously by a debug context. If disabled, debug
     *    messages may
     *    be produced asynchronously. In particular, they may be delayed
     *    relative to the execution of GL commands, and
     *    the debug callback function may be called from a thread other than
     *    that in which the commands are executed.
     *    See {@see GL46::glDebugMessageCallback}.
     *
     *  - {@see GL46::GL_DEPTH_CLAMP}: If enabled, the   -wc≤zc≤wc  plane
     *    equation is ignored by view volume clipping (effectively, there is
     *    no near or far plane clipping). See {@see GL46::glDepthRange}.
     *
     *  - {@see GL46::GL_DEPTH_TEST}: If enabled, do depth comparisons and
     *    update the depth buffer. Note that even if the depth buffer exists and
     *    the depth mask is non-zero, the depth buffer is not updated if the
     *    depth test is disabled. See
     *    {@see GL46::glDepthFunc} and {@see GL46::glDepthRange}.
     *
     *  - {@see GL46::GL_DITHER}: If enabled, dither color components or indices
     *    before they are written to the color buffer.
     *
     *  - {@see GL46::GL_FRAMEBUFFER_SRGB}: If enabled and the value of {@see
     *    GL46::GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING} for the framebuffer
     *    attachment corresponding to the destination buffer is {@see
     *    GL46::GL_SRGB}, the R, G, and B destination color
     *    values (after conversion from fixed-point to floating-point) are
     *    considered to be encoded for the sRGB color
     *    space and hence are linearized prior to their use in blending.
     *
     *  - {@see GL46::GL_LINE_SMOOTH}: If enabled, draw lines with correct
     *    filtering. Otherwise, draw aliased lines. See {@see
     *    GL46::glLineWidth}.
     *
     *  - {@see GL46::GL_MULTISAMPLE}: If enabled, use multiple fragment samples
     *    in computing the final color of a pixel. See
     *    {@see GL46::glSampleCoverage}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_FILL}: If enabled, and if the polygon is
     *    rendered in {@see GL46::GL_FILL} mode, an offset is added to depth
     *    values
     *    of a polygon's fragments before the depth comparison is performed. See
     *    {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_LINE}: If enabled, and if the polygon is
     *    rendered in {@see GL46::GL_LINE} mode, an offset is added to depth
     *    values
     *    of a polygon's fragments before the depth comparison is performed. See
     *    {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_OFFSET_POINT}: If enabled, an offset is added
     *    to depth values of a polygon's fragments before the depth comparison
     *    is
     *    performed, if the polygon is rendered in {@see GL46::GL_POINT} mode.
     *    See {@see GL46::glPolygonOffset}.
     *
     *  - {@see GL46::GL_POLYGON_SMOOTH}: If enabled, draw polygons with proper
     *    filtering. Otherwise, draw aliased polygons. For correct antialiased
     *    polygons, an alpha buffer is needed and the polygons must be sorted
     *    front to back.
     *
     *  - {@see GL46::GL_PRIMITIVE_RESTART}: Enables primitive restarting. If
     *    enabled, any one of the draw commands which transfers a set of generic
     *    attribute array elements to the GL will restart the primitive when the
     *    index of the vertex is equal to the
     *    primitive restart index. See {@see GL46::glPrimitiveRestartIndex}.
     *
     *  - {@see GL46::GL_PRIMITIVE_RESTART_FIXED_INDEX}: Enables primitive
     *    restarting with a fixed index. If enabled, any one of the draw
     *    commands which transfers a
     *    set of generic attribute array elements to the GL will restart the
     *    primitive when the index of the vertex is
     *    equal to the fixed primitive index for the specified index type. The
     *    fixed index is equal to 2n−1 where n is
     *    equal to 8 for {@see GL46::GL_UNSIGNED_BYTE}, 16 for {@see
     *    GL46::GL_UNSIGNED_SHORT} and 32 for
     *    {@see GL46::GL_UNSIGNED_INT}.
     *
     *  - {@see GL46::GL_RASTERIZER_DISCARD}: If enabled, primitives are
     *    discarded after the optional transform feedback stage, but before
     *    rasterization.
     *    Furthermore, when enabled, {@see GL46::glClear}, {@see
     *    GL46::glClearBufferData},
     *    {@see GL46::glClearBufferSubData}, {@see GL46::glClearTexImage}, and
     *    {@see GL46::glClearTexSubImage} are
     *    ignored.
     *
     *  - {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE}: If enabled, compute a
     *    temporary coverage value where each bit is determined by the alpha
     *    value at the
     *    corresponding sample location. The temporary coverage value is then
     *    ANDed with the fragment coverage value.
     *
     *  - {@see GL46::GL_SAMPLE_ALPHA_TO_ONE}: If enabled, each sample alpha
     *    value is replaced by the maximum representable alpha value.
     *
     *  - {@see GL46::GL_SAMPLE_COVERAGE}: If enabled, the fragment's coverage
     *    is ANDed with the temporary coverage value. If
     *    {@see GL46::GL_SAMPLE_COVERAGE_INVERT} is set to {@see GL46::GL_TRUE},
     *    invert the coverage value. See
     *    {@see GL46::glSampleCoverage}.
     *
     *  - {@see GL46::GL_SAMPLE_SHADING}: If enabled, the active fragment shader
     *    is run once for each covered sample, or at fraction of this rate as
     *    determined by the current value of {@see
     *    GL46::GL_MIN_SAMPLE_SHADING_VALUE}. See
     *    {@see GL46::glMinSampleShading}.
     *
     *  - {@see GL46::GL_SAMPLE_MASK}: If enabled, the sample coverage mask
     *    generated for a fragment during rasterization will be ANDed with the
     *    value of {@see GL46::GL_SAMPLE_MASK_VALUE} before shading occurs. See
     *    {@see GL46::glSampleMaski}.
     *
     *  - {@see GL46::GL_SCISSOR_TEST}: If enabled, discard fragments that are
     *    outside the scissor rectangle. See {@see GL46::glScissor}.
     *
     *  - {@see GL46::GL_STENCIL_TEST}: If enabled, do stencil testing and
     *    update the stencil buffer. See {@see GL46::glStencilFunc} and
     *    {@see GL46::glStencilOp}.
     *
     *  - {@see GL46::GL_TEXTURE_CUBE_MAP_SEAMLESS}: If enabled, cubemap
     *    textures are sampled such that when linearly sampling from the border
     *    between two
     *    adjacent faces, texels from both faces are used to generate the final
     *    sample value. When disabled, texels from
     *    only a single face are used to construct the final sample value.
     *
     *  - {@see GL46::GL_PROGRAM_POINT_SIZE}: If enabled and a vertex or
     *    geometry shader is active, then the derived point size is taken from
     *    the
     *    (potentially clipped) shader builtin {@see GL46::gl_PointSize} and
     *    clamped to the implementation-dependent
     *    point size range.
     *
     * @see http://docs.gl/gl2/glEnable
     * @see http://docs.gl/gl4/glEnable
     * @since 1.1
     * @param int $cap
     * @return void
     */
    public function enable(int $cap): void
    {
        $this->info->ffi->glEnable($cap);
    }

    /**
     * {@see GL46::glEnableClientState} and {@see GL46::glDisableClientState} enable or disable individual
     * client-side capabilities. By default, all client-side capabilities are disabled. Both
     * {@see GL46::glEnableClientState} and {@see GL46::glDisableClientState} take a single argument, $cap, which can
     * assume one of the following values:
     *
     *  - {@see GL46::GL_COLOR_ARRAY}: If enabled, the color array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glColorPointer}.
     *
     *  - {@see GL46::GL_EDGE_FLAG_ARRAY}: If enabled, the edge flag array is
     *    enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glEdgeFlagPointer}.
     *
     *  - {@see GL46::GL_FOG_COORD_ARRAY}: If enabled, the fog coordinate array
     *    is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glFogCoordPointer}.
     *
     *  - {@see GL46::GL_INDEX_ARRAY}: If enabled, the index array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glIndexPointer}.
     *
     *  - {@see GL46::GL_NORMAL_ARRAY}: If enabled, the normal array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glNormalPointer}.
     *
     *  - {@see GL46::GL_SECONDARY_COLOR_ARRAY}: If enabled, the secondary color
     *    array is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glColorPointer}.
     *
     *  - {@see GL46::GL_TEXTURE_COORD_ARRAY}: If enabled, the texture
     *    coordinate array is enabled for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glTexCoordPointer}.
     *
     *  - {@see GL46::GL_VERTEX_ARRAY}: If enabled, the vertex array is enabled
     *    for writing and used during rendering when
     *    {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see
     *    GL46::glDrawElements},
     *    {@see GL46::glDrawRangeElements} {@see GL46::glMultiDrawArrays}, or
     *    {@see GL46::glMultiDrawElements} is
     *    called. See {@see GL46::glVertexPointer}.
     *
     * @see http://docs.gl/gl2/glEnableClientState
     * @since 1.1
     * @param int $array
     * @return void
     */
    public function enableClientState(int $array): void
    {
        $this->info->ffi->glEnableClientState($array);
    }

    /**
     * {@see GL46::round} returns a value equal to the nearest integer to $x. The fraction 0.5 will round in a
     * direction chosen by the implementation, presumably the direction that is fastest. This includes the
     * possibility that {@see GL46::round}($x) returns the same value as {@see GL46::roundEven}($x) for all values of
     * $x.
     *
     * @see http://docs.gl/gl2/glFog
     * @see http://docs.gl/gl2/glGet
     * @see http://docs.gl/gl2/glHint
     * @see http://docs.gl/gl2/glIndex
     * @see http://docs.gl/gl4/glGet
     * @see http://docs.gl/gl4/glHint
     * @see http://docs.gl/gl4/round
     * @since 1.1
     * @return void
     */
    public function end(): void
    {
        $this->info->ffi->glEnd();
    }

    /**
     * Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are
     * created with {@see GL46::glNewList}. All subsequent commands are placed in the display list, in the order
     * issued, until {@see GL46::glEndList} is called.
     *
     * {@see GL46::glNewList} has two arguments. The first argument, $list, is a positive integer that becomes the
     * unique name for the display list. Names can be created and reserved with {@see GL46::glGenLists} and tested
     * for uniqueness with {@see GL46::glIsList}. The second argument, $mode, is a symbolic constant that can assume
     * one of two values:
     *
     *  - {@see GL46::GL_COMPILE}: Commands are merely compiled.
     *
     *  - {@see GL46::GL_COMPILE_AND_EXECUTE}: Commands are executed as they are
     *    compiled into the display list.
     *
     * Certain commands are not compiled into the display list but are executed immediately, regardless of the
     * display-list mode. These commands are {@see GL46::glAreTexturesResident}, {@see GL46::glColorPointer},
     * {@see GL46::glDeleteLists}, {@see GL46::glDeleteTextures}, {@see GL46::glDisableClientState},
     * {@see GL46::glEdgeFlagPointer}, {@see GL46::glEnableClientState}, {@see GL46::glFeedbackBuffer},
     * {@see GL46::glFinish}, {@see GL46::glFlush}, {@see GL46::glGenLists}, {@see GL46::glGenTextures},
     * {@see GL46::glIndexPointer}, {@see GL46::glInterleavedArrays}, {@see GL46::glIsEnabled},
     * {@see GL46::glIsList}, {@see GL46::glIsTexture}, {@see GL46::glNormalPointer}, {@see GL46::glPopClientAttrib},
     * {@see GL46::glPixelStore}, {@see GL46::glPushClientAttrib}, {@see GL46::glReadPixels},
     * {@see GL46::glRenderMode}, {@see GL46::glSelectBuffer}, {@see GL46::glTexCoordPointer},
     * {@see GL46::glVertexPointer}, and all of the {@see GL46::glGet} commands.
     *
     * Similarly, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, and {@see GL46::glTexImage3D} are executed
     * immediately and not compiled into the display list when their first argument is
     * {@see GL46::GL_PROXY_TEXTURE_1D}, {@see GL46::GL_PROXY_TEXTURE_1D}, or {@see GL46::GL_PROXY_TEXTURE_3D},
     * respectively.
     *
     * When the `ARB_imaging` extension is supported, {@see GL46::glHistogram} executes immediately when its argument
     * is {@see GL46::GL_PROXY_HISTOGRAM}. Similarly, {@see GL46::glColorTable} executes immediately when its first
     * argument is {@see GL46::GL_PROXY_COLOR_TABLE}, {@see GL46::GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or
     * {@see GL46::GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.
     *
     * For OpenGL versions 1.3 and greater, or when the `ARB_multitexture` extension is supported,
     * {@see GL46::glClientActiveTexture} is not compiled into display lists, but executed immediately.
     *
     * When {@see GL46::glEndList} is encountered, the display-list definition is completed by associating the list
     * with the unique name $list (specified in the {@see GL46::glNewList} command). If a display list with name
     * $list already exists, it is replaced only when {@see GL46::glEndList} is called.
     *
     * @see http://docs.gl/gl2/glIsList
     * @see http://docs.gl/gl2/glNewList
     * @since 1.1
     * @return void
     */
    public function endList(): void
    {
        $this->info->ffi->glEndList();
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param float $u
     * @return void
     */
    public function evalCoord1d(float $u): void
    {
        $this->info->ffi->glEvalCoord1d($u);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param \FFI\CData|null $u
     * @return void
     */
    public function evalCoord1dv(?\FFI\CData $u): void
    {
        $this->info->ffi->glEvalCoord1dv($u);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param float $u
     * @return void
     */
    public function evalCoord1f(float $u): void
    {
        $this->info->ffi->glEvalCoord1f($u);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param \FFI\CData|null $u
     * @return void
     */
    public function evalCoord1fv(?\FFI\CData $u): void
    {
        $this->info->ffi->glEvalCoord1fv($u);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param float $u
     * @param float $v
     * @return void
     */
    public function evalCoord2d(float $u, float $v): void
    {
        $this->info->ffi->glEvalCoord2d($u, $v);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param \FFI\CData|null $u
     * @return void
     */
    public function evalCoord2dv(?\FFI\CData $u): void
    {
        $this->info->ffi->glEvalCoord2dv($u);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param float $u
     * @param float $v
     * @return void
     */
    public function evalCoord2f(float $u, float $v): void
    {
        $this->info->ffi->glEvalCoord2f($u, $v);
    }

    /**
     * {@see GL46::glEvalCoord1} evaluates enabled one-dimensional maps at argument $u. {@see GL46::glEvalCoord2}
     * does the same for two-dimensional maps using two domain values, $u and $v. To define a map, call
     * {@see GL46::glMap1} and {@see GL46::glMap2}; to enable and disable it, call {@see GL46::glEnable} and
     * {@see GL46::glDisable}.
     *
     * When one of the {@see GL46::glEvalCoord} commands is issued, all currently enabled maps of the indicated
     * dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued
     * with the computed value. That is, if {@see GL46::GL_MAP1_INDEX} or {@see GL46::GL_MAP2_INDEX} is enabled, a
     * {@see GL46::glIndex} command is simulated. If {@see GL46::GL_MAP1_COLOR_4} or {@see GL46::GL_MAP2_COLOR_4} is
     * enabled, a {@see GL46::glColor} command is simulated. If {@see GL46::GL_MAP1_NORMAL} or
     * {@see GL46::GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of
     * {@see GL46::GL_MAP1_TEXTURE_COORD_1}, {@see GL46::GL_MAP1_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP1_TEXTURE_COORD_3}, {@see GL46::GL_MAP1_TEXTURE_COORD_4},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_1}, {@see GL46::GL_MAP2_TEXTURE_COORD_2},
     * {@see GL46::GL_MAP2_TEXTURE_COORD_3}, or {@see GL46::GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate
     * {@see GL46::glTexCoord} command is simulated.
     *
     * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values
     * for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not
     * update the current values. Thus, if {@see GL46::glVertex} commands are interspersed with
     * {@see GL46::glEvalCoord} commands, the color, normal, and texture coordinates associated with the
     * {@see GL46::glVertex} commands are not affected by the values generated by the {@see GL46::glEvalCoord}
     * commands, but only by the most recent {@see GL46::glColor}, {@see GL46::glIndex}, {@see GL46::glNormal}, and
     * {@see GL46::glTexCoord} commands.
     *
     * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a
     * particular dimension (for example, {@see GL46::GL_MAP2_TEXTURE_COORD_1} and
     * {@see GL46::GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of
     * coordinates (in this case, {@see GL46::GL_MAP2_TEXTURE_COORD_2}) is carried out. {@see GL46::GL_MAP1_VERTEX_4}
     * overrides {@see GL46::GL_MAP1_VERTEX_3}, and {@see GL46::GL_MAP2_VERTEX_4} overrides
     * {@see GL46::GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is
     * enabled for the specified dimension, the {@see GL46::glEvalCoord} command is ignored.
     *
     * If you have enabled automatic normal generation, by calling {@see GL46::glEnable} with argument
     * {@see GL46::GL_AUTO_NORMAL}, {@see GL46::glEvalCoord2} generates surface normals analytically, regardless of
     * the contents or enabling of the {@see GL46::GL_MAP2_NORMAL} map. Let
     *
     *    m =      &amp;PartialD; p     &amp;PartialD; u     ×     &amp;PartialD; p     &amp;PartialD; v
     *
     * Then the generated normal   n  is    n =  m  &amp;DoubleVerticalBar;&amp;DoubleVerticalBar; m
     *
     * If automatic normal generation is disabled, the corresponding normal map {@see GL46::GL_MAP2_NORMAL}, if
     * enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no
     * normal is generated for {@see GL46::glEvalCoord2} commands.
     *
     * @see http://docs.gl/gl2/glEvalCoord
     * @since 1.1
     * @param \FFI\CData|null $u
     * @return void
     */
    public function evalCoord2fv(?\FFI\CData $u): void
    {
        $this->info->ffi->glEvalCoord2fv($u);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used in tandem to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}. $mode determines whether the resulting vertices are connected as points, lines, or filled
     * polygons.
     *
     * In the one-dimensional case, {@see GL46::glEvalMesh1}, the mesh is generated as if the following code fragment
     * were executed:
     *
     * <code>
     *
     * glBegin( <parameter>type</parameter> );
     * for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *    glEvalCoord1( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub></mrow></math> );
     * glEnd();
     *
     * </code>
     *
     *     Δ u  =     u 2  -  u 1    n
     *
     * and n,   u 1  , and   u 2   are the arguments to the most recent {@see GL46::glMapGrid1} command. type is
     * {@see GL46::GL_POINTS} if $mode is {@see GL46::GL_POINT}, or {@see GL46::GL_LINES} if $mode is
     * {@see GL46::GL_LINE}.
     *
     * The one absolute numeric requirement is that if    i = n  , then the value computed from     i &amp;CenterDot;
     *  Δ u   + u 1    is exactly   u 2  .
     *
     * In the two-dimensional case, {@see GL46::glEvalMesh2}, let .cp     Δ u  =    u 2  - u 1    n
     *
     *     Δ v  =    v 2  - v 1    m
     *
     * where n,   u 1  ,   u 2  , m,   v 1  , and   v 2   are the arguments to the most recent
     * {@see GL46::glMapGrid2} command. Then, if $mode is {@see GL46::GL_FILL}, the {@see GL46::glEvalMesh2} command
     * is equivalent to:
     *
     * <code>
     *
     * for ( j = <parameter>j1</parameter>; j < <parameter>j2</parameter>; j += 1 ) {
     *    glBegin( GL_QUAD_STRIP );
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 ) {
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mrow><mfenced close=")" open="("><mrow><mn>j</mn><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    }
     *    glEnd();
     * }
     *
     * </code>
     *
     * If $mode is {@see GL46::GL_LINE}, then a call to {@see GL46::glEvalMesh2} is equivalent to:
     *
     * <code>
     *
     * for ( j = <parameter>j1</parameter>; j <= <parameter>j2</parameter>; j += 1 ) {
     *    glBegin( GL_LINE_STRIP );
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    glEnd();
     * }
     *
     * for ( i = <parameter>i1</parameter>;  i <= <parameter>i2</parameter>; i += 1 ) {
     *    glBegin( GL_LINE_STRIP );
     *    for ( j = <parameter>j1</parameter>; j <= <parameter>j1</parameter>; j += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    glEnd();
     * }
     *
     * </code>
     *
     * And finally, if $mode is {@see GL46::GL_POINT}, then a call to {@see GL46::glEvalMesh2} is equivalent to:
     *
     * <code>
     *
     * glBegin( GL_POINTS );
     * for ( j = <parameter>j1</parameter>; j <= <parameter>j2</parameter>; j += 1 )
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     * glEnd();
     *
     * </code>
     *
     * In all three cases, the only absolute numeric requirements are that if    i = n  , then the value computed
     * from     i &amp;CenterDot;  Δ u   + u 1    is exactly   u 2  , and if    j = m  , then the value computed
     * from     j &amp;CenterDot;  Δ v   + v 1    is exactly   v 2  .
     *
     * @see http://docs.gl/gl2/glEvalMesh
     * @since 1.1
     * @param int $mode
     * @param int $i1
     * @param int $i2
     * @return void
     */
    public function evalMesh1(int $mode, int $i1, int $i2): void
    {
        $this->info->ffi->glEvalMesh1($mode, $i1, $i2);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used in tandem to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}. $mode determines whether the resulting vertices are connected as points, lines, or filled
     * polygons.
     *
     * In the one-dimensional case, {@see GL46::glEvalMesh1}, the mesh is generated as if the following code fragment
     * were executed:
     *
     * <code>
     *
     * glBegin( <parameter>type</parameter> );
     * for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *    glEvalCoord1( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub></mrow></math> );
     * glEnd();
     *
     * </code>
     *
     *     Δ u  =     u 2  -  u 1    n
     *
     * and n,   u 1  , and   u 2   are the arguments to the most recent {@see GL46::glMapGrid1} command. type is
     * {@see GL46::GL_POINTS} if $mode is {@see GL46::GL_POINT}, or {@see GL46::GL_LINES} if $mode is
     * {@see GL46::GL_LINE}.
     *
     * The one absolute numeric requirement is that if    i = n  , then the value computed from     i &amp;CenterDot;
     *  Δ u   + u 1    is exactly   u 2  .
     *
     * In the two-dimensional case, {@see GL46::glEvalMesh2}, let .cp     Δ u  =    u 2  - u 1    n
     *
     *     Δ v  =    v 2  - v 1    m
     *
     * where n,   u 1  ,   u 2  , m,   v 1  , and   v 2   are the arguments to the most recent
     * {@see GL46::glMapGrid2} command. Then, if $mode is {@see GL46::GL_FILL}, the {@see GL46::glEvalMesh2} command
     * is equivalent to:
     *
     * <code>
     *
     * for ( j = <parameter>j1</parameter>; j < <parameter>j2</parameter>; j += 1 ) {
     *    glBegin( GL_QUAD_STRIP );
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 ) {
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mrow><mfenced close=")" open="("><mrow><mn>j</mn><mo>+</mo><mn>1</mn></mrow></mfenced></mrow><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    }
     *    glEnd();
     * }
     *
     * </code>
     *
     * If $mode is {@see GL46::GL_LINE}, then a call to {@see GL46::glEvalMesh2} is equivalent to:
     *
     * <code>
     *
     * for ( j = <parameter>j1</parameter>; j <= <parameter>j2</parameter>; j += 1 ) {
     *    glBegin( GL_LINE_STRIP );
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    glEnd();
     * }
     *
     * for ( i = <parameter>i1</parameter>;  i <= <parameter>i2</parameter>; i += 1 ) {
     *    glBegin( GL_LINE_STRIP );
     *    for ( j = <parameter>j1</parameter>; j <= <parameter>j1</parameter>; j += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *    glEnd();
     * }
     *
     * </code>
     *
     * And finally, if $mode is {@see GL46::GL_POINT}, then a call to {@see GL46::glEvalMesh2} is equivalent to:
     *
     * <code>
     *
     * glBegin( GL_POINTS );
     * for ( j = <parameter>j1</parameter>; j <= <parameter>j2</parameter>; j += 1 )
     *    for ( i = <parameter>i1</parameter>; i <= <parameter>i2</parameter>; i += 1 )
     *       glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     * glEnd();
     *
     * </code>
     *
     * In all three cases, the only absolute numeric requirements are that if    i = n  , then the value computed
     * from     i &amp;CenterDot;  Δ u   + u 1    is exactly   u 2  , and if    j = m  , then the value computed
     * from     j &amp;CenterDot;  Δ v   + v 1    is exactly   v 2  .
     *
     * @see http://docs.gl/gl2/glEvalMesh
     * @since 1.1
     * @param int $mode
     * @param int $i1
     * @param int $i2
     * @param int $j1
     * @param int $j2
     * @return void
     */
    public function evalMesh2(int $mode, int $i1, int $i2, int $j1, int $j2): void
    {
        $this->info->ffi->glEvalMesh2($mode, $i1, $i2, $j1, $j2);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used in tandem to efficiently generate and evaluate a
     * series of evenly spaced map domain values. {@see GL46::glEvalPoint} can be used to evaluate a single grid
     * point in the same gridspace that is traversed by {@see GL46::glEvalMesh}. Calling {@see GL46::glEvalPoint1} is
     * equivalent to calling <code>
     *
     * glEvalCoord1( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">u</mi><mn>1</mn></msub></mrow></math> );
     *
     * </code>
     *
     *  where     Δ u  =    u 2  - u 1    n
     *
     * and n,   u 1  , and   u 2   are the arguments to the most recent {@see GL46::glMapGrid1} command. The one
     * absolute numeric requirement is that if    i = n  , then the value computed from     i &amp;CenterDot;  Δ u
     * + u 1    is exactly   u 2  .
     *
     * In the two-dimensional case, {@see GL46::glEvalPoint2}, let
     *
     *     Δ u  =    u 2  - u 1    n         Δ v  =    v 2  - v 1    m
     *
     * where n,   u 1  ,   u 2  , m,   v 1  , and   v 2   are the arguments to the most recent
     * {@see GL46::glMapGrid2} command. Then the {@see GL46::glEvalPoint2} command is equivalent to calling
     *
     * <code>
     *
     * glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *
     * </code>
     *
     *  The only absolute numeric requirements are that if    i = n  , then the value computed from     i
     * &amp;CenterDot;  Δ u   + u 1    is exactly   u 2  , and if    j = m  , then the value computed from     j
     * &amp;CenterDot;  Δ v   + v 1    is exactly   v 2  .
     *
     * @see http://docs.gl/gl2/glEvalPoint
     * @since 1.1
     * @param int $i
     * @return void
     */
    public function evalPoint1(int $i): void
    {
        $this->info->ffi->glEvalPoint1($i);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used in tandem to efficiently generate and evaluate a
     * series of evenly spaced map domain values. {@see GL46::glEvalPoint} can be used to evaluate a single grid
     * point in the same gridspace that is traversed by {@see GL46::glEvalMesh}. Calling {@see GL46::glEvalPoint1} is
     * equivalent to calling <code>
     *
     * glEvalCoord1( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">u</mi><mn>1</mn></msub></mrow></math> );
     *
     * </code>
     *
     *  where     Δ u  =    u 2  - u 1    n
     *
     * and n,   u 1  , and   u 2   are the arguments to the most recent {@see GL46::glMapGrid1} command. The one
     * absolute numeric requirement is that if    i = n  , then the value computed from     i &amp;CenterDot;  Δ u
     * + u 1    is exactly   u 2  .
     *
     * In the two-dimensional case, {@see GL46::glEvalPoint2}, let
     *
     *     Δ u  =    u 2  - u 1    n         Δ v  =    v 2  - v 1    m
     *
     * where n,   u 1  ,   u 2  , m,   v 1  , and   v 2   are the arguments to the most recent
     * {@see GL46::glMapGrid2} command. Then the {@see GL46::glEvalPoint2} command is equivalent to calling
     *
     * <code>
     *
     * glEvalCoord2( <math><mrow><mrow><mn>i</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">u</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">u</mi><mn>1</mn></msub><mo>,</mo><mrow><mn>j</mn><mo>&CenterDot;</mo><mo>Δ</mo><mi
     * mathvariant="italic">v</mi></mrow><mo>+</mo><msub><mi
     * mathvariant="italic">v</mi><mn>1</mn></msub></mrow></math> );
     *
     * </code>
     *
     *  The only absolute numeric requirements are that if    i = n  , then the value computed from     i
     * &amp;CenterDot;  Δ u   + u 1    is exactly   u 2  , and if    j = m  , then the value computed from     j
     * &amp;CenterDot;  Δ v   + v 1    is exactly   v 2  .
     *
     * @see http://docs.gl/gl2/glEvalPoint
     * @since 1.1
     * @param int $i
     * @param int $j
     * @return void
     */
    public function evalPoint2(int $i, int $j): void
    {
        $this->info->ffi->glEvalPoint2($i, $j);
    }

    /**
     * The {@see GL46::glFeedbackBuffer} function controls feedback. Feedback, like selection, is a GL mode. The mode
     * is selected by calling {@see GL46::glRenderMode} with {@see GL46::GL_FEEDBACK}. When the GL is in feedback
     * mode, no pixels are produced by rasterization. Instead, information about primitives that would have been
     * rasterized is fed back to the application using the GL.
     *
     * {@see GL46::glFeedbackBuffer} has three arguments: $buffer is a pointer to an array of floating-point values
     * into which feedback information is placed. $size indicates the size of the array. $type is a symbolic constant
     * describing the information that is fed back for each vertex. {@see GL46::glFeedbackBuffer} must be issued
     * before feedback mode is enabled (by calling {@see GL46::glRenderMode} with argument {@see GL46::GL_FEEDBACK}).
     * Setting {@see GL46::GL_FEEDBACK} without establishing the feedback buffer, or calling
     * {@see GL46::glFeedbackBuffer} while the GL is in feedback mode, is an error.
     *
     * When {@see GL46::glRenderMode} is called while in feedback mode, it returns the number of entries placed in
     * the feedback array and resets the feedback array pointer to the base of the feedback buffer. The returned
     * value never exceeds $size. If the feedback data required more room than was available in $buffer,
     * {@see GL46::glRenderMode} returns a negative value. To take the GL out of feedback mode, call
     * {@see GL46::glRenderMode} with a parameter value other than {@see GL46::GL_FEEDBACK}.
     *
     * While in feedback mode, each primitive, bitmap, or pixel rectangle that would be rasterized generates a block
     * of values that are copied into the feedback array. If doing so would cause the number of entries to exceed the
     * maximum, the block is partially written so as to fill the array (if there is any room left at all), and an
     * overflow flag is set. Each block begins with a code indicating the primitive type, followed by values that
     * describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel
     * rectangles. Feedback occurs after polygon culling and {@see GL46::glPolygonMode} interpretation of polygons
     * has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after
     * polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by
     * performing this decomposition.
     *
     * The {@see GL46::glPassThrough} command can be used to insert a marker into the feedback buffer. See
     * {@see GL46::glPassThrough}.
     *
     * Following is the grammar for the blocks of values written into the feedback buffer. Each primitive is
     * indicated with a unique identifying value followed by some number of vertices. Polygon entries include an
     * integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point
     * values, as determined by $type. Colors are fed back as four values in RGBA mode and one value in color index
     * mode.
     *
     *  feedbackList ← feedbackItem feedbackList | feedbackItem   feedbackItem ← point | lineSegment | polygon |
     * bitmap | pixelRectangle | passThru   point ← {@see GL46::GL_POINT_TOKEN} vertex   lineSegment ←
     * {@see GL46::GL_LINE_TOKEN} vertex vertex | {@see GL46::GL_LINE_RESET_TOKEN} vertex vertex   polygon ←
     * {@see GL46::GL_POLYGON_TOKEN} n polySpec   polySpec ← polySpec vertex | vertex vertex vertex   bitmap ←
     * {@see GL46::GL_BITMAP_TOKEN} vertex   pixelRectangle ← {@see GL46::GL_DRAW_PIXEL_TOKEN} vertex |
     * {@see GL46::GL_COPY_PIXEL_TOKEN} vertex   passThru ← {@see GL46::GL_PASS_THROUGH_TOKEN} value   vertex ←
     * 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture   2d ← value value   3d ← value value value   3dColor
     * ← value value value color   3dColorTexture ← value value value color tex   4dColorTexture ← value value
     * value value color tex   color ← rgba | index   rgba ← value value value value   index ← value   tex ←
     * value value value value
     *
     * value is a floating-point number, and n is a floating-point integer giving the number of vertices in the
     * polygon. {@see GL46::GL_POINT_TOKEN}, {@see GL46::GL_LINE_TOKEN}, {@see GL46::GL_LINE_RESET_TOKEN},
     * {@see GL46::GL_POLYGON_TOKEN}, {@see GL46::GL_BITMAP_TOKEN}, {@see GL46::GL_DRAW_PIXEL_TOKEN},
     * {@see GL46::GL_COPY_PIXEL_TOKEN} and {@see GL46::GL_PASS_THROUGH_TOKEN} are symbolic floating-point constants.
     * {@see GL46::GL_LINE_RESET_TOKEN} is returned whenever the line stipple pattern is reset. The data returned as
     * a vertex depends on the feedback $type.
     *
     * The following table gives the correspondence between $type and the number of values per vertex. k is 1 in
     * color index mode and 4 in RGBA mode.
     *
     * | {@see GL46::GL_2D}               | x, y       |   |   | 2        |
     * | {@see GL46::GL_3D}               | x, y, z    |   |   | 3        |
     * | {@see GL46::GL_3D_COLOR}         | x, y, z    | k |   |    3 + k |
     * | {@see GL46::GL_3D_COLOR_TEXTURE} | x, y, z    | k | 4 |    7 + k |
     * | {@see GL46::GL_4D_COLOR_TEXTURE} | x, y, z, w | k | 4 |    8 + k |
     * Feedback vertex coordinates are in window coordinates, except w, which is in clip coordinates. Feedback colors
     * are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate
     * generation is enabled. They are always transformed by the texture matrix.
     *
     * @see http://docs.gl/gl2/glFeedbackBuffer
     * @since 1.1
     * @param int $size
     * @param int $type
     * @param float|null $buffer
     * @return void
     */
    public function feedbackBuffer(int $size, int $type, ?float &$buffer): void
    {
        $bufferCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glFeedbackBuffer($size, $type, \FFI::addr($bufferCType));
        } finally {
            $buffer = $bufferCType->cdata;
            \FFI::free($bufferCType);
        }
    }

    /**
     * {@see GL46::glFinish} does not return until the effects of all previously called GL commands are complete.
     * Such effects include all changes to GL state, all changes to connection state, and all changes to the frame
     * buffer contents.
     *
     * @see http://docs.gl/gl2/glFinish
     * @see http://docs.gl/gl4/glFinish
     * @since 1.1
     * @return void
     */
    public function finish(): void
    {
        $this->info->ffi->glFinish();
    }

    /**
     * Different GL implementations buffer commands in several different locations, including network buffers and the
     * graphics accelerator itself. {@see GL46::glFlush} empties all of these buffers, causing all issued commands to
     * be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be
     * completed in any particular time period, it does complete in finite time.
     *
     * Because any GL program might be executed over a network, or on an accelerator that buffers commands, all
     * programs should call {@see GL46::glFlush} whenever they count on having all of their previously issued
     * commands completed. For example, call {@see GL46::glFlush} before waiting for user input that depends on the
     * generated image.
     *
     * @see http://docs.gl/gl2/glFlush
     * @see http://docs.gl/gl4/glFlush
     * @since 1.1
     * @return void
     */
    public function flush(): void
    {
        $this->info->ffi->glFlush();
    }

    /**
     * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not
     * buffer clear operations. To enable and disable fog, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_FOG}.
     *
     * {@see GL46::glFog} assigns the value or values in $params to the fog parameter specified by $pname. The
     * following values are accepted for $pname:
     *
     *  - {@see GL46::GL_FOG_MODE}: $params is a single integer or
     *    floating-point value that specifies the equation to be used to compute
     *    the fog
     *    blend factor, f. Three symbolic constants are accepted: {@see
     *    GL46::GL_LINEAR}, {@see GL46::GL_EXP}, and
     *    {@see GL46::GL_EXP2}. The equations corresponding to these symbolic
     *    constants are defined below. The initial
     *    fog mode is {@see GL46::GL_EXP}.
     *
     *  - {@see GL46::GL_FOG_DENSITY}: $params is a single integer or
     *    floating-point value that specifies density, the fog density used in
     *    both
     *    exponential fog equations. Only nonnegative densities are accepted.
     *    The initial fog density is 1.
     *
     *  - {@see GL46::GL_FOG_START}: $params is a single integer or
     *    floating-point value that specifies start, the near distance used in
     *    the
     *    linear fog equation. The initial near distance is 0.
     *
     *  - {@see GL46::GL_FOG_END}: $params is a single integer or floating-point
     *    value that specifies end, the far distance used in the linear
     *    fog equation. The initial far distance is 1.
     *
     *  - {@see GL46::GL_FOG_INDEX}: $params is a single integer or
     *    floating-point value that specifies   i f  , the fog color index. The
     *    initial
     *    fog index is 0.
     *
     *  - {@see GL46::GL_FOG_COLOR}: $params contains four integer or
     *    floating-point values that specify   C f  , the fog color. Integer
     *    values
     *    are mapped linearly such that the most positive representable value
     *    maps to 1.0, and the most negative
     *    representable value maps to   -1.0 . Floating-point values are mapped
     *    directly. After conversion, all color
     *    components are clamped to the range    0 1  . The initial fog color is
     *    (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_FOG_COORD_SRC}: $params contains either of the
     *    following symbolic constants: {@see GL46::GL_FOG_COORD} or
     *    {@see GL46::GL_FRAGMENT_DEPTH}. {@see GL46::GL_FOG_COORD} specifies
     *    that the current fog coordinate should be
     *    used as distance value in the fog color computation. {@see
     *    GL46::GL_FRAGMENT_DEPTH} specifies that the current
     *    fragment depth should be used as distance value in the fog
     *    computation.
     *
     * Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f.
     * Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye
     * coordinate from the origin (in the case that the {@see GL46::GL_FOG_COORD_SRC} is
     * {@see GL46::GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@see GL46::GL_FOG_COORD_SRC}
     * is {@see GL46::GL_FOG_COORD}). The equation for {@see GL46::GL_LINEAR} fog is    f =    end - c     end -
     * start
     *
     * The equation for {@see GL46::GL_EXP} fog is    f = e   -   density &amp;CenterDot; c
     *
     * The equation for {@see GL46::GL_EXP2} fog is    f = e   -   density &amp;CenterDot; c     2
     *
     * Regardless of the fog mode, f is clamped to the range    0 1   after it is computed. Then, if the GL is in
     * RGBA color mode, the fragment's red, green, and blue colors, represented by   C r  , are replaced by
     *
     *     C r   ″  =   f × C r   +    1 - f   × C f
     *
     * Fog does not affect a fragment's alpha component.
     *
     * In color index mode, the fragment's color index   i r   is replaced by
     *
     *     i r   ″  =  i r  +    1 - f   × i f
     *
     * @see http://docs.gl/gl2/glFog
     * @since 1.1
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function fogf(int $pname, float $param): void
    {
        $this->info->ffi->glFogf($pname, $param);
    }

    /**
     * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not
     * buffer clear operations. To enable and disable fog, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_FOG}.
     *
     * {@see GL46::glFog} assigns the value or values in $params to the fog parameter specified by $pname. The
     * following values are accepted for $pname:
     *
     *  - {@see GL46::GL_FOG_MODE}: $params is a single integer or
     *    floating-point value that specifies the equation to be used to compute
     *    the fog
     *    blend factor, f. Three symbolic constants are accepted: {@see
     *    GL46::GL_LINEAR}, {@see GL46::GL_EXP}, and
     *    {@see GL46::GL_EXP2}. The equations corresponding to these symbolic
     *    constants are defined below. The initial
     *    fog mode is {@see GL46::GL_EXP}.
     *
     *  - {@see GL46::GL_FOG_DENSITY}: $params is a single integer or
     *    floating-point value that specifies density, the fog density used in
     *    both
     *    exponential fog equations. Only nonnegative densities are accepted.
     *    The initial fog density is 1.
     *
     *  - {@see GL46::GL_FOG_START}: $params is a single integer or
     *    floating-point value that specifies start, the near distance used in
     *    the
     *    linear fog equation. The initial near distance is 0.
     *
     *  - {@see GL46::GL_FOG_END}: $params is a single integer or floating-point
     *    value that specifies end, the far distance used in the linear
     *    fog equation. The initial far distance is 1.
     *
     *  - {@see GL46::GL_FOG_INDEX}: $params is a single integer or
     *    floating-point value that specifies   i f  , the fog color index. The
     *    initial
     *    fog index is 0.
     *
     *  - {@see GL46::GL_FOG_COLOR}: $params contains four integer or
     *    floating-point values that specify   C f  , the fog color. Integer
     *    values
     *    are mapped linearly such that the most positive representable value
     *    maps to 1.0, and the most negative
     *    representable value maps to   -1.0 . Floating-point values are mapped
     *    directly. After conversion, all color
     *    components are clamped to the range    0 1  . The initial fog color is
     *    (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_FOG_COORD_SRC}: $params contains either of the
     *    following symbolic constants: {@see GL46::GL_FOG_COORD} or
     *    {@see GL46::GL_FRAGMENT_DEPTH}. {@see GL46::GL_FOG_COORD} specifies
     *    that the current fog coordinate should be
     *    used as distance value in the fog color computation. {@see
     *    GL46::GL_FRAGMENT_DEPTH} specifies that the current
     *    fragment depth should be used as distance value in the fog
     *    computation.
     *
     * Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f.
     * Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye
     * coordinate from the origin (in the case that the {@see GL46::GL_FOG_COORD_SRC} is
     * {@see GL46::GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@see GL46::GL_FOG_COORD_SRC}
     * is {@see GL46::GL_FOG_COORD}). The equation for {@see GL46::GL_LINEAR} fog is    f =    end - c     end -
     * start
     *
     * The equation for {@see GL46::GL_EXP} fog is    f = e   -   density &amp;CenterDot; c
     *
     * The equation for {@see GL46::GL_EXP2} fog is    f = e   -   density &amp;CenterDot; c     2
     *
     * Regardless of the fog mode, f is clamped to the range    0 1   after it is computed. Then, if the GL is in
     * RGBA color mode, the fragment's red, green, and blue colors, represented by   C r  , are replaced by
     *
     *     C r   ″  =   f × C r   +    1 - f   × C f
     *
     * Fog does not affect a fragment's alpha component.
     *
     * In color index mode, the fragment's color index   i r   is replaced by
     *
     *     i r   ″  =  i r  +    1 - f   × i f
     *
     * @see http://docs.gl/gl2/glFog
     * @since 1.1
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function fogfv(int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glFogfv($pname, $params);
    }

    /**
     * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not
     * buffer clear operations. To enable and disable fog, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_FOG}.
     *
     * {@see GL46::glFog} assigns the value or values in $params to the fog parameter specified by $pname. The
     * following values are accepted for $pname:
     *
     *  - {@see GL46::GL_FOG_MODE}: $params is a single integer or
     *    floating-point value that specifies the equation to be used to compute
     *    the fog
     *    blend factor, f. Three symbolic constants are accepted: {@see
     *    GL46::GL_LINEAR}, {@see GL46::GL_EXP}, and
     *    {@see GL46::GL_EXP2}. The equations corresponding to these symbolic
     *    constants are defined below. The initial
     *    fog mode is {@see GL46::GL_EXP}.
     *
     *  - {@see GL46::GL_FOG_DENSITY}: $params is a single integer or
     *    floating-point value that specifies density, the fog density used in
     *    both
     *    exponential fog equations. Only nonnegative densities are accepted.
     *    The initial fog density is 1.
     *
     *  - {@see GL46::GL_FOG_START}: $params is a single integer or
     *    floating-point value that specifies start, the near distance used in
     *    the
     *    linear fog equation. The initial near distance is 0.
     *
     *  - {@see GL46::GL_FOG_END}: $params is a single integer or floating-point
     *    value that specifies end, the far distance used in the linear
     *    fog equation. The initial far distance is 1.
     *
     *  - {@see GL46::GL_FOG_INDEX}: $params is a single integer or
     *    floating-point value that specifies   i f  , the fog color index. The
     *    initial
     *    fog index is 0.
     *
     *  - {@see GL46::GL_FOG_COLOR}: $params contains four integer or
     *    floating-point values that specify   C f  , the fog color. Integer
     *    values
     *    are mapped linearly such that the most positive representable value
     *    maps to 1.0, and the most negative
     *    representable value maps to   -1.0 . Floating-point values are mapped
     *    directly. After conversion, all color
     *    components are clamped to the range    0 1  . The initial fog color is
     *    (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_FOG_COORD_SRC}: $params contains either of the
     *    following symbolic constants: {@see GL46::GL_FOG_COORD} or
     *    {@see GL46::GL_FRAGMENT_DEPTH}. {@see GL46::GL_FOG_COORD} specifies
     *    that the current fog coordinate should be
     *    used as distance value in the fog color computation. {@see
     *    GL46::GL_FRAGMENT_DEPTH} specifies that the current
     *    fragment depth should be used as distance value in the fog
     *    computation.
     *
     * Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f.
     * Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye
     * coordinate from the origin (in the case that the {@see GL46::GL_FOG_COORD_SRC} is
     * {@see GL46::GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@see GL46::GL_FOG_COORD_SRC}
     * is {@see GL46::GL_FOG_COORD}). The equation for {@see GL46::GL_LINEAR} fog is    f =    end - c     end -
     * start
     *
     * The equation for {@see GL46::GL_EXP} fog is    f = e   -   density &amp;CenterDot; c
     *
     * The equation for {@see GL46::GL_EXP2} fog is    f = e   -   density &amp;CenterDot; c     2
     *
     * Regardless of the fog mode, f is clamped to the range    0 1   after it is computed. Then, if the GL is in
     * RGBA color mode, the fragment's red, green, and blue colors, represented by   C r  , are replaced by
     *
     *     C r   ″  =   f × C r   +    1 - f   × C f
     *
     * Fog does not affect a fragment's alpha component.
     *
     * In color index mode, the fragment's color index   i r   is replaced by
     *
     *     i r   ″  =  i r  +    1 - f   × i f
     *
     * @see http://docs.gl/gl2/glFog
     * @since 1.1
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function fogi(int $pname, int $param): void
    {
        $this->info->ffi->glFogi($pname, $param);
    }

    /**
     * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not
     * buffer clear operations. To enable and disable fog, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_FOG}.
     *
     * {@see GL46::glFog} assigns the value or values in $params to the fog parameter specified by $pname. The
     * following values are accepted for $pname:
     *
     *  - {@see GL46::GL_FOG_MODE}: $params is a single integer or
     *    floating-point value that specifies the equation to be used to compute
     *    the fog
     *    blend factor, f. Three symbolic constants are accepted: {@see
     *    GL46::GL_LINEAR}, {@see GL46::GL_EXP}, and
     *    {@see GL46::GL_EXP2}. The equations corresponding to these symbolic
     *    constants are defined below. The initial
     *    fog mode is {@see GL46::GL_EXP}.
     *
     *  - {@see GL46::GL_FOG_DENSITY}: $params is a single integer or
     *    floating-point value that specifies density, the fog density used in
     *    both
     *    exponential fog equations. Only nonnegative densities are accepted.
     *    The initial fog density is 1.
     *
     *  - {@see GL46::GL_FOG_START}: $params is a single integer or
     *    floating-point value that specifies start, the near distance used in
     *    the
     *    linear fog equation. The initial near distance is 0.
     *
     *  - {@see GL46::GL_FOG_END}: $params is a single integer or floating-point
     *    value that specifies end, the far distance used in the linear
     *    fog equation. The initial far distance is 1.
     *
     *  - {@see GL46::GL_FOG_INDEX}: $params is a single integer or
     *    floating-point value that specifies   i f  , the fog color index. The
     *    initial
     *    fog index is 0.
     *
     *  - {@see GL46::GL_FOG_COLOR}: $params contains four integer or
     *    floating-point values that specify   C f  , the fog color. Integer
     *    values
     *    are mapped linearly such that the most positive representable value
     *    maps to 1.0, and the most negative
     *    representable value maps to   -1.0 . Floating-point values are mapped
     *    directly. After conversion, all color
     *    components are clamped to the range    0 1  . The initial fog color is
     *    (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_FOG_COORD_SRC}: $params contains either of the
     *    following symbolic constants: {@see GL46::GL_FOG_COORD} or
     *    {@see GL46::GL_FRAGMENT_DEPTH}. {@see GL46::GL_FOG_COORD} specifies
     *    that the current fog coordinate should be
     *    used as distance value in the fog color computation. {@see
     *    GL46::GL_FRAGMENT_DEPTH} specifies that the current
     *    fragment depth should be used as distance value in the fog
     *    computation.
     *
     * Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f.
     * Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye
     * coordinate from the origin (in the case that the {@see GL46::GL_FOG_COORD_SRC} is
     * {@see GL46::GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@see GL46::GL_FOG_COORD_SRC}
     * is {@see GL46::GL_FOG_COORD}). The equation for {@see GL46::GL_LINEAR} fog is    f =    end - c     end -
     * start
     *
     * The equation for {@see GL46::GL_EXP} fog is    f = e   -   density &amp;CenterDot; c
     *
     * The equation for {@see GL46::GL_EXP2} fog is    f = e   -   density &amp;CenterDot; c     2
     *
     * Regardless of the fog mode, f is clamped to the range    0 1   after it is computed. Then, if the GL is in
     * RGBA color mode, the fragment's red, green, and blue colors, represented by   C r  , are replaced by
     *
     *     C r   ″  =   f × C r   +    1 - f   × C f
     *
     * Fog does not affect a fragment's alpha component.
     *
     * In color index mode, the fragment's color index   i r   is replaced by
     *
     *     i r   ″  =  i r  +    1 - f   × i f
     *
     * @see http://docs.gl/gl2/glFog
     * @since 1.1
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function fogiv(int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glFogiv($pname, $params);
    }

    /**
     * In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating
     * these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and
     * disable elimination of back-facing polygons, call {@see GL46::glEnable} and  {@see GL46::glDisable} with
     * argument {@see GL46::GL_CULL_FACE}.
     *
     * The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object
     * following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back
     * to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding
     * is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise
     * direction about the interior of the polygon. {@see GL46::glFrontFace} specifies whether polygons with
     * clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be
     * front-facing. Passing {@see GL46::GL_CCW} to $mode selects counterclockwise polygons as front-facing;
     * {@see GL46::GL_CW} selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken
     * to be front-facing.
     *
     * @see http://docs.gl/gl2/glFrontFace
     * @see http://docs.gl/gl4/glFrontFace
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function frontFace(int $mode): void
    {
        $this->info->ffi->glFrontFace($mode);
    }

    /**
     * {@see GL46::glFrustum} describes a perspective matrix that produces a perspective projection. The current
     * matrix (see {@see GL46::glMatrixMode}) is multiplied by this matrix and the result replaces the current
     * matrix, as if {@see GL46::glMultMatrix} were called with the following matrix as its argument:
     *
     *           2 &amp;it; nearVal     right - left       0   A   0     0       2 &amp;it; nearVal     top - bottom
     *      B   0     0   0   C   D     0   0   -1   0
     *
     *    A =    right + left     right - left
     *
     *    B =    top + bottom     top - bottom
     *
     *    C =  -     farVal + nearVal     farVal - nearVal
     *
     *    D =  -     2 &amp;it; farVal &amp;it; nearVal     farVal - nearVal
     *
     * Typically, the matrix mode is {@see GL46::GL_PROJECTION}, and    left bottom  - nearVal    and    right top  -
     * nearVal    specify the points on the near clipping plane that are mapped to the lower left and upper right
     * corners of the window, assuming that the eye is located at (0, 0, 0).    - farVal   specifies the location of
     * the far clipping plane. Both $nearVal and $farVal must be positive.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the current matrix stack.
     *
     * @see http://docs.gl/gl2/glFrustum
     * @since 1.1
     * @param float $left
     * @param float $right
     * @param float $bottom
     * @param float $top
     * @param float $zNear
     * @param float $zFar
     * @return void
     */
    public function frustum(float $left, float $right, float $bottom, float $top, float $zNear, float $zFar): void
    {
        $this->info->ffi->glFrustum($left, $right, $bottom, $top, $zNear, $zFar);
    }

    /**
     * {@see GL46::glGenLists} has one argument, $range. It returns an integer n such that $range contiguous empty
     * display lists, named n,    n + 1  ,   ... ,    n + range - 1  , are created. If $range is 0, if there is no
     * group of $range contiguous names available, or if any error is generated, no display lists are generated, and
     * 0 is returned.
     *
     * @see http://docs.gl/gl2/glGenLists
     * @since 1.1
     * @param int $range
     * @return int
     */
    public function genLists(int $range): int
    {
        return $this->info->ffi->glGenLists($range);
    }

    /**
     * {@see GL46::glGenTextures} returns $n texture names in $textures. There is no guarantee that the names form a
     * contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately
     * before the call to {@see GL46::glGenTextures}.
     *
     * The generated textures have no dimensionality; they assume the dimensionality of the texture target to which
     * they are first bound (see {@see GL46::glBindTexture}).
     *
     * Texture names returned by a call to {@see GL46::glGenTextures} are not returned by subsequent calls, unless
     * they are first deleted with {@see GL46::glDeleteTextures}.
     *
     * @see http://docs.gl/gl2/glGenTextures
     * @see http://docs.gl/gl4/glGenTextures
     * @since 1.1
     * @param int $n
     * @param int|null $textures
     * @return void
     */
    public function genTextures(int $n, ?int &$textures): void
    {
        $texturesCType = $this->info->ffi->new('GLuint', false);
        try {
            $this->info->ffi->glGenTextures($n, \FFI::addr($texturesCType));
        } finally {
            $textures = $texturesCType->cdata;
            \FFI::free($texturesCType);
        }
    }

    /**
     * {@see GL46::glGetProgram} returns in $params the value of a parameter for a specific program object. The
     * following parameters are defined:
     *
     *  - {@see GL46::GL_DELETE_STATUS}: $params returns {@see GL46::GL_TRUE} if
     *    $program is currently flagged for deletion, and
     *    {@see GL46::GL_FALSE} otherwise.
     *
     *  - {@see GL46::GL_LINK_STATUS}: $params returns {@see GL46::GL_TRUE} if
     *    the last link operation on $program was successful, and
     *    {@see GL46::GL_FALSE} otherwise.
     *
     *  - {@see GL46::GL_VALIDATE_STATUS}: $params returns {@see GL46::GL_TRUE}
     *    or if the last validation operation on $program was successful, and
     *    {@see GL46::GL_FALSE} otherwise.
     *
     *  - {@see GL46::GL_INFO_LOG_LENGTH}: $params returns the number of
     *    characters in the information log for $program including the null
     *    termination
     *    character (i.e., the size of the character buffer required to store
     *    the information log). If $program has no
     *    information log, a value of 0 is returned.
     *
     *  - {@see GL46::GL_ATTACHED_SHADERS}: $params returns the number of shader
     *    objects attached to $program.
     *
     *  - {@see GL46::GL_ACTIVE_ATOMIC_COUNTER_BUFFERS}: $params returns the
     *    number of active attribute atomic counter buffers used by $program.
     *
     *  - {@see GL46::GL_ACTIVE_ATTRIBUTES}: $params returns the number of
     *    active attribute variables for $program.
     *
     *  - {@see GL46::GL_ACTIVE_ATTRIBUTE_MAX_LENGTH}: $params returns the
     *    length of the longest active attribute name for $program, including
     *    the null
     *    termination character (i.e., the size of the character buffer required
     *    to store the longest attribute name).
     *    If no active attributes exist, 0 is returned.
     *
     *  - {@see GL46::GL_ACTIVE_UNIFORMS}: $params returns the number of active
     *    uniform variables for $program.
     *
     *  - {@see GL46::GL_ACTIVE_UNIFORM_MAX_LENGTH}: $params returns the length
     *    of the longest active uniform variable name for $program, including
     *    the null
     *    termination character (i.e., the size of the character buffer required
     *    to store the longest uniform variable
     *    name). If no active uniform variables exist, 0 is returned.
     *
     *  - {@see GL46::GL_PROGRAM_BINARY_LENGTH}: $params returns the length of
     *    the program binary, in bytes that will be returned by a call to
     *    {@see GL46::glGetProgramBinary}. When a progam's {@see
     *    GL46::GL_LINK_STATUS} is {@see GL46::GL_FALSE}, its
     *    program binary length is zero.
     *
     *  - {@see GL46::GL_COMPUTE_WORK_GROUP_SIZE}: $params returns an array of
     *    three integers containing the local work group size of the compute
     *    program as
     *    specified by its input layout qualifier(s). $program must be the name
     *    of a program object that has been
     *    previously linked successfully and contains a binary for the compute
     *    shader stage.
     *
     *  - {@see GL46::GL_TRANSFORM_FEEDBACK_BUFFER_MODE}: $params returns a
     *    symbolic constant indicating the buffer mode used when transform
     *    feedback is active. This
     *    may be {@see GL46::GL_SEPARATE_ATTRIBS} or {@see
     *    GL46::GL_INTERLEAVED_ATTRIBS}.
     *
     *  - {@see GL46::GL_TRANSFORM_FEEDBACK_VARYINGS}: $params returns the
     *    number of varying variables to capture in transform feedback mode for
     *    the program.
     *
     *  - {@see GL46::GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH}: $params returns
     *    the length of the longest variable name to be used for transform
     *    feedback, including the
     *    null-terminator.
     *
     *  - {@see GL46::GL_GEOMETRY_VERTICES_OUT}: $params returns the maximum
     *    number of vertices that the geometry shader in $program will output.
     *
     *  - {@see GL46::GL_GEOMETRY_INPUT_TYPE}: $params returns a symbolic
     *    constant indicating the primitive type accepted as input to the
     *    geometry shader
     *    contained in $program.
     *
     *  - {@see GL46::GL_GEOMETRY_OUTPUT_TYPE}: $params returns a symbolic
     *    constant indicating the primitive type that will be output by the
     *    geometry
     *    shader contained in $program.
     *
     * @see http://docs.gl/gl2/glGetPointerv
     * @see http://docs.gl/gl2/glGetProgram
     * @see http://docs.gl/gl2/glGetTexEnv
     * @see http://docs.gl/gl2/glGetTexGen
     * @see http://docs.gl/gl4/glGetPointerv
     * @see http://docs.gl/gl4/glGetProgram
     * @since 1.1
     * @param int $pname
     * @param bool|null $params
     * @return void
     */
    public function getBooleanv(int $pname, ?bool &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLboolean', false);
        try {
            $this->info->ffi->glGetBooleanv($pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata !== 0;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetClipPlane} returns in $equation the four coefficients of the plane equation for $plane.
     *
     * @see http://docs.gl/gl2/glGetClipPlane
     * @since 1.1
     * @param int $plane
     * @param float|null $equation
     * @return void
     */
    public function getClipPlane(int $plane, ?float &$equation): void
    {
        $equationCType = $this->info->ffi->new('GLdouble', false);
        try {
            $this->info->ffi->glGetClipPlane($plane, \FFI::addr($equationCType));
        } finally {
            $equation = $equationCType->cdata;
            \FFI::free($equationCType);
        }
    }

    /**
     * {@see GL46::glGetPointerv} returns pointer information. $pname indicates the pointer to be returned, and
     * $params is a pointer to a location in which to place the returned data. The parameters that may be queried
     * include:
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_FUNCTION}: Returns the current callback
     *    function set with the $callback argument of {@see
     *    GL46::glDebugMessageCallback}.
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_USER_PARAM}: Returns the user parameter
     *    to the current callback function set with the $userParam argument of
     *    {@see GL46::glDebugMessageCallback}.
     *
     * @see http://docs.gl/gl2/glGetPointerv
     * @see http://docs.gl/gl4/glGetPointerv
     * @since 1.1
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getDoublev(int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLdouble', false);
        try {
            $this->info->ffi->glGetDoublev($pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetError} returns the value of the error flag. Each detectable error is assigned a numeric code
     * and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other
     * errors are recorded until {@see GL46::glGetError} is called, the error code is returned, and the flag is reset
     * to {@see GL46::GL_NO_ERROR}. If a call to {@see GL46::glGetError} returns {@see GL46::GL_NO_ERROR}, there has
     * been no detectable error since the last call to {@see GL46::glGetError}, or since the GL was initialized.
     *
     * To allow for distributed implementations, there may be several error flags. If any single error flag has
     * recorded an error, the value of that flag is returned and that flag is reset to {@see GL46::GL_NO_ERROR} when
     * {@see GL46::glGetError} is called. If more than one flag has recorded an error, {@see GL46::glGetError}
     * returns and clears an arbitrary error flag value. Thus, {@see GL46::glGetError} should always be called in a
     * loop, until it returns {@see GL46::GL_NO_ERROR}, if all error flags are to be reset.
     *
     * Initially, all error flags are set to {@see GL46::GL_NO_ERROR}.
     *
     * The following errors are currently defined:
     *
     *  - {@see GL46::GL_NO_ERROR}: No error has been recorded. The value of
     *    this symbolic constant is guaranteed to be 0.
     *
     *  - {@see GL46::GL_INVALID_ENUM}: An unacceptable value is specified for
     *    an enumerated argument. The offending command is ignored and has no
     *    other side effect than to set the error flag.
     *
     *  - {@see GL46::GL_INVALID_VALUE}: A numeric argument is out of range. The
     *    offending command is ignored and has no other side effect than to set
     *    the error flag.
     *
     *  - {@see GL46::GL_INVALID_OPERATION}: The specified operation is not
     *    allowed in the current state. The offending command is ignored and has
     *    no
     *    other side effect than to set the error flag.
     *
     *  - {@see GL46::GL_INVALID_FRAMEBUFFER_OPERATION}: The framebuffer object
     *    is not complete. The offending command is ignored and has no other
     *    side effect than to
     *    set the error flag.
     *
     *  - {@see GL46::GL_OUT_OF_MEMORY}: There is not enough memory left to
     *    execute the command. The state of the GL is undefined, except for the
     *    state of the error flags, after this error is recorded.
     *
     *  - {@see GL46::GL_STACK_UNDERFLOW}: An attempt has been made to perform
     *    an operation that would cause an internal stack to underflow.
     *
     *  - {@see GL46::GL_STACK_OVERFLOW}: An attempt has been made to perform an
     *    operation that would cause an internal stack to overflow.
     *
     * When an error flag is set, results of a GL operation are undefined only if {@see GL46::GL_OUT_OF_MEMORY} has
     * occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or
     * frame buffer contents. If the generating command returns a value, it returns 0. If {@see GL46::glGetError}
     * itself generates an error, it returns 0.
     *
     * @see http://docs.gl/gl2/glGetError
     * @see http://docs.gl/gl4/glGetError
     * @since 1.1
     * @return int
     */
    public function getError(): int
    {
        return $this->info->ffi->glGetError();
    }

    /**
     * {@see GL46::glGetTexEnv} returns in $params selected values of a texture environment that was specified with
     * {@see GL46::glTexEnv}. $target specifies a texture environment.
     *
     * When $target is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When
     * $target is {@see GL46::GL_POINT_SPRITE}, $pname must be {@see GL46::GL_COORD_REPLACE}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * $pname names a specific texture environment parameter, as follows:
     *
     *  - {@see GL46::GL_TEXTURE_ENV_MODE}: $params returns the single-valued
     *    texture environment mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_TEXTURE_ENV_COLOR}: $params returns four integer or
     *    floating-point values that are the texture environment color. Integer
     *    values,
     *    when requested, are linearly mapped from the internal floating-point
     *    representation such that 1.0 maps to the
     *    most positive representable integer, and   -1.0  maps to the most
     *    negative representable integer. The initial
     *    value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params returns a single
     *    floating-point value that is the texture level-of-detail bias. The
     *    initial value is
     *    0.
     *
     *  - {@see GL46::GL_COMBINE_RGB}: $params returns a single symbolic
     *    constant value representing the current RGB combine mode. The initial
     *    value
     *    is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_COMBINE_ALPHA}: $params returns a single symbolic
     *    constant value representing the current alpha combine mode. The
     *    initial
     *    value is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_SRC0_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's RGB source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner one's RGB source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner two's RGB source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_SRC0_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's alpha source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner one's alpha source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner two's alpha source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_OPERAND0_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND1_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner one's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND2_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner two's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND0_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND1_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner one's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND2_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner two's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_RGB_SCALE}: $params returns a single floating-point
     *    value representing the current RGB texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_ALPHA_SCALE}: $params returns a single floating-point
     *    value representing the current alpha texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_COORD_REPLACE}: $params returns a single boolean value
     *    representing the current point sprite texture coordinate replacement
     *    enable state. The initial value is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glGetLight
     * @see http://docs.gl/gl2/glGetMap
     * @see http://docs.gl/gl2/glGetTexEnv
     * @since 1.1
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getFloatv(int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetFloatv($pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetPointerv} returns pointer information. $pname indicates the pointer to be returned, and
     * $params is a pointer to a location in which to place the returned data. The parameters that may be queried
     * include:
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_FUNCTION}: Returns the current callback
     *    function set with the $callback argument of {@see
     *    GL46::glDebugMessageCallback}.
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_USER_PARAM}: Returns the user parameter
     *    to the current callback function set with the $userParam argument of
     *    {@see GL46::glDebugMessageCallback}.
     *
     * @see http://docs.gl/gl2/glGetPointerv
     * @see http://docs.gl/gl4/glGetPointerv
     * @since 1.1
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getIntegerv(int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetIntegerv($pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetLight} returns in $params the value or values of a light source parameter. $light names the
     * light and is a symbolic name of the form {@see GL46::GL_LIGHT} i where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. {@see GL46::GL_MAX_LIGHTS} is an implementation dependent constant that is
     * greater than or equal to eight. $pname specifies one of ten light source parameters, again by symbolic name.
     *
     * The following parameters are defined:
     *
     *  - {@see GL46::GL_AMBIENT}: $params returns four integer or
     *    floating-point values representing the ambient intensity of the light
     *    source.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params returns four integer or
     *    floating-point values representing the diffuse intensity of the light
     *    source.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value for {@see GL46::GL_LIGHT0} is (1, 1, 1,
     *    1); for other lights, the initial value
     *    is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params returns four integer or
     *    floating-point values representing the specular intensity of the light
     *    source. Integer values, when requested, are linearly mapped from the
     *    internal floating-point representation
     *    such that 1.0 maps to the most positive representable integer value,
     *    and   -1.0  maps to the most negative
     *    representable integer value. If the internal value is outside the
     *    range    -1 1  , the corresponding integer
     *    return value is undefined. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other lights, the
     *    initial value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_POSITION}: $params returns four integer or
     *    floating-point values representing the position of the light source.
     *    Integer
     *    values, when requested, are computed by rounding the internal
     *    floating-point values to the nearest integer
     *    value. The returned values are those maintained in eye coordinates.
     *    They will not be equal to the values
     *    specified using {@see GL46::glLight}, unless the modelview matrix was
     *    identity at the time
     *    {@see GL46::glLight} was called. The initial value is (0, 0, 1, 0).
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params returns three integer or
     *    floating-point values representing the direction of the light source.
     *    Integer values, when requested, are computed by rounding the internal
     *    floating-point values to the nearest
     *    integer value. The returned values are those maintained in eye
     *    coordinates. They will not be equal to the
     *    values specified using {@see GL46::glLight}, unless the modelview
     *    matrix was identity at the time
     *    {@see GL46::glLight} was called. Although spot direction is normalized
     *    before being used in the lighting
     *    equation, the returned values are the transformed versions of the
     *    specified values prior to normalization. The
     *    initial value is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params returns a single integer or
     *    floating-point value representing the spot exponent of the light. An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params returns a single integer or
     *    floating-point value representing the spot cutoff angle of the light.
     *    An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 180.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}: $params returns a single integer
     *    or floating-point value representing the constant (not
     *    distance-related)
     *    attenuation of the light. An integer value, when requested, is
     *    computed by rounding the internal
     *    floating-point representation to the nearest integer. The initial
     *    value is 1.
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}: $params returns a single integer
     *    or floating-point value representing the linear attenuation of the
     *    light. An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params returns a single
     *    integer or floating-point value representing the quadratic attenuation
     *    of the light.
     *    An integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     * @see http://docs.gl/gl2/glGetLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getLightfv(int $light, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetLightfv($light, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetLight} returns in $params the value or values of a light source parameter. $light names the
     * light and is a symbolic name of the form {@see GL46::GL_LIGHT} i where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. {@see GL46::GL_MAX_LIGHTS} is an implementation dependent constant that is
     * greater than or equal to eight. $pname specifies one of ten light source parameters, again by symbolic name.
     *
     * The following parameters are defined:
     *
     *  - {@see GL46::GL_AMBIENT}: $params returns four integer or
     *    floating-point values representing the ambient intensity of the light
     *    source.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params returns four integer or
     *    floating-point values representing the diffuse intensity of the light
     *    source.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value for {@see GL46::GL_LIGHT0} is (1, 1, 1,
     *    1); for other lights, the initial value
     *    is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params returns four integer or
     *    floating-point values representing the specular intensity of the light
     *    source. Integer values, when requested, are linearly mapped from the
     *    internal floating-point representation
     *    such that 1.0 maps to the most positive representable integer value,
     *    and   -1.0  maps to the most negative
     *    representable integer value. If the internal value is outside the
     *    range    -1 1  , the corresponding integer
     *    return value is undefined. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other lights, the
     *    initial value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_POSITION}: $params returns four integer or
     *    floating-point values representing the position of the light source.
     *    Integer
     *    values, when requested, are computed by rounding the internal
     *    floating-point values to the nearest integer
     *    value. The returned values are those maintained in eye coordinates.
     *    They will not be equal to the values
     *    specified using {@see GL46::glLight}, unless the modelview matrix was
     *    identity at the time
     *    {@see GL46::glLight} was called. The initial value is (0, 0, 1, 0).
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params returns three integer or
     *    floating-point values representing the direction of the light source.
     *    Integer values, when requested, are computed by rounding the internal
     *    floating-point values to the nearest
     *    integer value. The returned values are those maintained in eye
     *    coordinates. They will not be equal to the
     *    values specified using {@see GL46::glLight}, unless the modelview
     *    matrix was identity at the time
     *    {@see GL46::glLight} was called. Although spot direction is normalized
     *    before being used in the lighting
     *    equation, the returned values are the transformed versions of the
     *    specified values prior to normalization. The
     *    initial value is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params returns a single integer or
     *    floating-point value representing the spot exponent of the light. An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params returns a single integer or
     *    floating-point value representing the spot cutoff angle of the light.
     *    An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 180.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}: $params returns a single integer
     *    or floating-point value representing the constant (not
     *    distance-related)
     *    attenuation of the light. An integer value, when requested, is
     *    computed by rounding the internal
     *    floating-point representation to the nearest integer. The initial
     *    value is 1.
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}: $params returns a single integer
     *    or floating-point value representing the linear attenuation of the
     *    light. An
     *    integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params returns a single
     *    integer or floating-point value representing the quadratic attenuation
     *    of the light.
     *    An integer value, when requested, is computed by rounding the internal
     *    floating-point representation to the
     *    nearest integer. The initial value is 0.
     *
     * @see http://docs.gl/gl2/glGetLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getLightiv(int $light, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetLightiv($light, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glMap1} and {@see GL46::glMap2} define evaluators. {@see GL46::glGetMap} returns evaluator
     * parameters. $target chooses a map, $query selects a specific parameter, and $v points to storage where the
     * values will be returned.
     *
     * The acceptable values for the $target parameter are described in the {@see GL46::glMap1} and
     * {@see GL46::glMap2} reference pages.
     *
     * $query can assume the following values:
     *
     *  - {@see GL46::GL_COEFF}: $v returns the control points for the evaluator
     *    function. One-dimensional evaluators return order control
     *    points, and two-dimensional evaluators return    uorder × vorder
     *    control points. Each control point
     *    consists of one, two, three, or four integer, single-precision
     *    floating-point, or double-precision
     *    floating-point values, depending on the type of the evaluator. The GL
     *    returns two-dimensional control points
     *    in row-major order, incrementing the uorder index quickly and the
     *    vorder index after each row. Integer values,
     *    when requested, are computed by rounding the internal floating-point
     *    values to the nearest integer values.
     *
     *  - {@see GL46::GL_ORDER}: $v returns the order of the evaluator function.
     *    One-dimensional evaluators return a single value, order. The
     *    initial value is 1. Two-dimensional evaluators return two values,
     *    uorder and vorder. The initial value is 1,1.
     *
     *  - {@see GL46::GL_DOMAIN}: $v returns the linear u and v mapping
     *    parameters. One-dimensional evaluators return two values, u1 and u2,
     *    as
     *    specified by {@see GL46::glMap1}. Two-dimensional evaluators return
     *    four values (u1, u2, v1, and v2) as
     *    specified by {@see GL46::glMap2}. Integer values, when requested, are
     *    computed by rounding the internal
     *    floating-point values to the nearest integer values.
     *
     * @see http://docs.gl/gl2/glGetMap
     * @since 1.1
     * @param int $target
     * @param int $query
     * @param float|null $v
     * @return void
     */
    public function getMapdv(int $target, int $query, ?float &$v): void
    {
        $vCType = $this->info->ffi->new('GLdouble', false);
        try {
            $this->info->ffi->glGetMapdv($target, $query, \FFI::addr($vCType));
        } finally {
            $v = $vCType->cdata;
            \FFI::free($vCType);
        }
    }

    /**
     * {@see GL46::glMap1} and {@see GL46::glMap2} define evaluators. {@see GL46::glGetMap} returns evaluator
     * parameters. $target chooses a map, $query selects a specific parameter, and $v points to storage where the
     * values will be returned.
     *
     * The acceptable values for the $target parameter are described in the {@see GL46::glMap1} and
     * {@see GL46::glMap2} reference pages.
     *
     * $query can assume the following values:
     *
     *  - {@see GL46::GL_COEFF}: $v returns the control points for the evaluator
     *    function. One-dimensional evaluators return order control
     *    points, and two-dimensional evaluators return    uorder × vorder
     *    control points. Each control point
     *    consists of one, two, three, or four integer, single-precision
     *    floating-point, or double-precision
     *    floating-point values, depending on the type of the evaluator. The GL
     *    returns two-dimensional control points
     *    in row-major order, incrementing the uorder index quickly and the
     *    vorder index after each row. Integer values,
     *    when requested, are computed by rounding the internal floating-point
     *    values to the nearest integer values.
     *
     *  - {@see GL46::GL_ORDER}: $v returns the order of the evaluator function.
     *    One-dimensional evaluators return a single value, order. The
     *    initial value is 1. Two-dimensional evaluators return two values,
     *    uorder and vorder. The initial value is 1,1.
     *
     *  - {@see GL46::GL_DOMAIN}: $v returns the linear u and v mapping
     *    parameters. One-dimensional evaluators return two values, u1 and u2,
     *    as
     *    specified by {@see GL46::glMap1}. Two-dimensional evaluators return
     *    four values (u1, u2, v1, and v2) as
     *    specified by {@see GL46::glMap2}. Integer values, when requested, are
     *    computed by rounding the internal
     *    floating-point values to the nearest integer values.
     *
     * @see http://docs.gl/gl2/glGetMap
     * @since 1.1
     * @param int $target
     * @param int $query
     * @param float|null $v
     * @return void
     */
    public function getMapfv(int $target, int $query, ?float &$v): void
    {
        $vCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetMapfv($target, $query, \FFI::addr($vCType));
        } finally {
            $v = $vCType->cdata;
            \FFI::free($vCType);
        }
    }

    /**
     * {@see GL46::glMap1} and {@see GL46::glMap2} define evaluators. {@see GL46::glGetMap} returns evaluator
     * parameters. $target chooses a map, $query selects a specific parameter, and $v points to storage where the
     * values will be returned.
     *
     * The acceptable values for the $target parameter are described in the {@see GL46::glMap1} and
     * {@see GL46::glMap2} reference pages.
     *
     * $query can assume the following values:
     *
     *  - {@see GL46::GL_COEFF}: $v returns the control points for the evaluator
     *    function. One-dimensional evaluators return order control
     *    points, and two-dimensional evaluators return    uorder × vorder
     *    control points. Each control point
     *    consists of one, two, three, or four integer, single-precision
     *    floating-point, or double-precision
     *    floating-point values, depending on the type of the evaluator. The GL
     *    returns two-dimensional control points
     *    in row-major order, incrementing the uorder index quickly and the
     *    vorder index after each row. Integer values,
     *    when requested, are computed by rounding the internal floating-point
     *    values to the nearest integer values.
     *
     *  - {@see GL46::GL_ORDER}: $v returns the order of the evaluator function.
     *    One-dimensional evaluators return a single value, order. The
     *    initial value is 1. Two-dimensional evaluators return two values,
     *    uorder and vorder. The initial value is 1,1.
     *
     *  - {@see GL46::GL_DOMAIN}: $v returns the linear u and v mapping
     *    parameters. One-dimensional evaluators return two values, u1 and u2,
     *    as
     *    specified by {@see GL46::glMap1}. Two-dimensional evaluators return
     *    four values (u1, u2, v1, and v2) as
     *    specified by {@see GL46::glMap2}. Integer values, when requested, are
     *    computed by rounding the internal
     *    floating-point values to the nearest integer values.
     *
     * @see http://docs.gl/gl2/glGetMap
     * @since 1.1
     * @param int $target
     * @param int $query
     * @param int|null $v
     * @return void
     */
    public function getMapiv(int $target, int $query, ?int &$v): void
    {
        $vCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetMapiv($target, $query, \FFI::addr($vCType));
        } finally {
            $v = $vCType->cdata;
            \FFI::free($vCType);
        }
    }

    /**
     * {@see GL46::glGetMaterial} returns in $params the value or values of parameter $pname of material $face. Six
     * parameters are defined:
     *
     *  - {@see GL46::GL_AMBIENT}: $params returns four integer or
     *    floating-point values representing the ambient reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0.2, 0.2, 0.2, 1.0)
     *
     *  - {@see GL46::GL_DIFFUSE}: $params returns four integer or
     *    floating-point values representing the diffuse reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params returns four integer or
     *    floating-point values representing the specular reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params returns four integer or
     *    floating-point values representing the emitted light intensity of the
     *    material. Integer values, when requested, are linearly mapped from the
     *    internal floating-point representation
     *    such that 1.0 maps to the most positive representable integer value,
     *    and   -1.0  maps to the most negative
     *    representable integer value. If the internal value is outside the
     *    range    -1 1  , the corresponding integer
     *    return value is undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params returns one integer or
     *    floating-point value representing the specular exponent of the
     *    material.
     *    Integer values, when requested, are computed by rounding the internal
     *    floating-point value to the nearest
     *    integer value. The initial value is 0.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params returns three integer or
     *    floating-point values representing the ambient, diffuse, and specular
     *    indices of the material. These indices are used only for color index
     *    lighting. (All the other parameters are
     *    used only for RGBA lighting.) Integer values, when requested, are
     *    computed by rounding the internal
     *    floating-point values to the nearest integer values.
     *
     * @see http://docs.gl/gl2/glGetMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getMaterialfv(int $face, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetMaterialfv($face, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetMaterial} returns in $params the value or values of parameter $pname of material $face. Six
     * parameters are defined:
     *
     *  - {@see GL46::GL_AMBIENT}: $params returns four integer or
     *    floating-point values representing the ambient reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0.2, 0.2, 0.2, 1.0)
     *
     *  - {@see GL46::GL_DIFFUSE}: $params returns four integer or
     *    floating-point values representing the diffuse reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params returns four integer or
     *    floating-point values representing the specular reflectance of the
     *    material.
     *    Integer values, when requested, are linearly mapped from the internal
     *    floating-point representation such that
     *    1.0 maps to the most positive representable integer value, and   -1.0
     *    maps to the most negative representable
     *    integer value. If the internal value is outside the range    -1 1  ,
     *    the corresponding integer return value is
     *    undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params returns four integer or
     *    floating-point values representing the emitted light intensity of the
     *    material. Integer values, when requested, are linearly mapped from the
     *    internal floating-point representation
     *    such that 1.0 maps to the most positive representable integer value,
     *    and   -1.0  maps to the most negative
     *    representable integer value. If the internal value is outside the
     *    range    -1 1  , the corresponding integer
     *    return value is undefined. The initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params returns one integer or
     *    floating-point value representing the specular exponent of the
     *    material.
     *    Integer values, when requested, are computed by rounding the internal
     *    floating-point value to the nearest
     *    integer value. The initial value is 0.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params returns three integer or
     *    floating-point values representing the ambient, diffuse, and specular
     *    indices of the material. These indices are used only for color index
     *    lighting. (All the other parameters are
     *    used only for RGBA lighting.) Integer values, when requested, are
     *    computed by rounding the internal
     *    floating-point values to the nearest integer values.
     *
     * @see http://docs.gl/gl2/glGetMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getMaterialiv(int $face, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetMaterialiv($face, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * See the {@see GL46::glPixelMap} reference page for a description of the acceptable values for the $map
     * parameter. {@see GL46::glGetPixelMap} returns in $data the contents of the pixel map specified in $map. Pixel
     * maps are used during the execution of {@see GL46::glReadPixels}, {@see GL46::glDrawPixels},
     * {@see GL46::glCopyPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, {@see GL46::glTexSubImage3D},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, and {@see GL46::glCopyTexSubImage3D}. to map color indices, stencil indices,
     * color components, and depth components to other values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel map is requested, $data is treated as a byte offset into the buffer
     * object's data store.
     *
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point
     * representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return
     * unsigned integer values are undefined if the map value was not in the range [0,1].
     *
     * To determine the required size of $map, call {@see GL46::glGet} with the appropriate symbolic constant.
     *
     * @see http://docs.gl/gl2/glGetPixelMap
     * @since 1.1
     * @param int $map
     * @param float|null $values
     * @return void
     */
    public function getPixelMapfv(int $map, ?float &$values): void
    {
        $valuesCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetPixelMapfv($map, \FFI::addr($valuesCType));
        } finally {
            $values = $valuesCType->cdata;
            \FFI::free($valuesCType);
        }
    }

    /**
     * See the {@see GL46::glPixelMap} reference page for a description of the acceptable values for the $map
     * parameter. {@see GL46::glGetPixelMap} returns in $data the contents of the pixel map specified in $map. Pixel
     * maps are used during the execution of {@see GL46::glReadPixels}, {@see GL46::glDrawPixels},
     * {@see GL46::glCopyPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, {@see GL46::glTexSubImage3D},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, and {@see GL46::glCopyTexSubImage3D}. to map color indices, stencil indices,
     * color components, and depth components to other values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel map is requested, $data is treated as a byte offset into the buffer
     * object's data store.
     *
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point
     * representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return
     * unsigned integer values are undefined if the map value was not in the range [0,1].
     *
     * To determine the required size of $map, call {@see GL46::glGet} with the appropriate symbolic constant.
     *
     * @see http://docs.gl/gl2/glGetPixelMap
     * @since 1.1
     * @param int $map
     * @param int|null $values
     * @return void
     */
    public function getPixelMapuiv(int $map, ?int &$values): void
    {
        $valuesCType = $this->info->ffi->new('GLuint', false);
        try {
            $this->info->ffi->glGetPixelMapuiv($map, \FFI::addr($valuesCType));
        } finally {
            $values = $valuesCType->cdata;
            \FFI::free($valuesCType);
        }
    }

    /**
     * See the {@see GL46::glPixelMap} reference page for a description of the acceptable values for the $map
     * parameter. {@see GL46::glGetPixelMap} returns in $data the contents of the pixel map specified in $map. Pixel
     * maps are used during the execution of {@see GL46::glReadPixels}, {@see GL46::glDrawPixels},
     * {@see GL46::glCopyPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, {@see GL46::glTexSubImage3D},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, and {@see GL46::glCopyTexSubImage3D}. to map color indices, stencil indices,
     * color components, and depth components to other values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel map is requested, $data is treated as a byte offset into the buffer
     * object's data store.
     *
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point
     * representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return
     * unsigned integer values are undefined if the map value was not in the range [0,1].
     *
     * To determine the required size of $map, call {@see GL46::glGet} with the appropriate symbolic constant.
     *
     * @see http://docs.gl/gl2/glGetPixelMap
     * @since 1.1
     * @param int $map
     * @param int|null $values
     * @return void
     */
    public function getPixelMapusv(int $map, ?int &$values): void
    {
        $valuesCType = $this->info->ffi->new('GLushort', false);
        try {
            $this->info->ffi->glGetPixelMapusv($map, \FFI::addr($valuesCType));
        } finally {
            $values = $valuesCType->cdata;
            \FFI::free($valuesCType);
        }
    }

    /**
     * {@see GL46::glGetPointerv} returns pointer information. $pname indicates the pointer to be returned, and
     * $params is a pointer to a location in which to place the returned data. The parameters that may be queried
     * include:
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_FUNCTION}: Returns the current callback
     *    function set with the $callback argument of {@see
     *    GL46::glDebugMessageCallback}.
     *
     *  - {@see GL46::GL_DEBUG_CALLBACK_USER_PARAM}: Returns the user parameter
     *    to the current callback function set with the $userParam argument of
     *    {@see GL46::glDebugMessageCallback}.
     *
     * @see http://docs.gl/gl2/glGetPointerv
     * @see http://docs.gl/gl4/glGetPointerv
     * @since 1.1
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function getPointerv(int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glGetPointerv($pname, $params);
    }

    /**
     * {@see GL46::glGetPolygonStipple} returns to $pattern a    32 × 32   polygon stipple pattern. The pattern is
     * packed into memory as if {@see GL46::glReadPixels} with both height and width of 32, type of
     * {@see GL46::GL_BITMAP}, and format of {@see GL46::GL_COLOR_INDEX} were called, and the stipple pattern were
     * stored in an internal    32 × 32   color index buffer. Unlike {@see GL46::glReadPixels}, however, pixel
     * transfer operations (shift, offset, pixel map) are not applied to the returned stipple image.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a polygon stipple pattern is requested, $pattern is treated as a byte offset
     * into the buffer object's data store.
     *
     * @see http://docs.gl/gl2/glGetPolygonStipple
     * @since 1.1
     * @param int|null $mask
     * @return void
     */
    public function getPolygonStipple(?int &$mask): void
    {
        $maskCType = $this->info->ffi->new('GLubyte', false);
        try {
            $this->info->ffi->glGetPolygonStipple(\FFI::addr($maskCType));
        } finally {
            $mask = $maskCType->cdata;
            \FFI::free($maskCType);
        }
    }

    /**
     * {@see GL46::glGetString} returns a pointer to a static string describing some aspect of the current GL
     * connection. $name can be one of the following:
     *
     *  - {@see GL46::GL_VENDOR}: Returns the company responsible for this GL
     *    implementation. This name does not change from release to
     *    release.
     *
     *  - {@see GL46::GL_RENDERER}: Returns the name of the renderer. This name
     *    is typically specific to a particular configuration of a hardware
     *    platform. It does not change from release to release.
     *
     *  - {@see GL46::GL_VERSION}: Returns a version or release number.
     *
     *  - {@see GL46::GL_SHADING_LANGUAGE_VERSION}: Returns a version or release
     *    number for the shading language.
     *
     * {@see GL46::glGetStringi} returns a pointer to a static string indexed by $index. $name can be one of the
     * following:
     *
     *  - {@see GL46::GL_EXTENSIONS}: For {@see GL46::glGetStringi} only,
     *    returns the extension string supported by the implementation at
     *    $index.
     *
     * Strings {@see GL46::GL_VENDOR} and {@see GL46::GL_RENDERER} together uniquely specify a platform. They do not
     * change from release to release and should be used by platform-recognition algorithms.
     *
     * The {@see GL46::GL_VERSION} and {@see GL46::GL_SHADING_LANGUAGE_VERSION} strings begin with a version number.
     * The version number uses one of these forms:
     *
     * major_number.minor_number major_number.minor_number.release_number
     *
     * Vendor-specific information may follow the version number. Its format depends on the implementation, but a
     * space always separates the version number and the vendor-specific information.
     *
     * All strings are null-terminated.
     *
     * @see http://docs.gl/gl2/glGetString
     * @see http://docs.gl/gl4/glGetString
     * @since 1.1
     * @param int $name
     * @return string
     */
    public function getString(int $name): string
    {
        return \FFI::string(\FFI::cast('char*', $this->info->ffi->glGetString($name)));
    }

    /**
     * {@see GL46::glGetTexEnv} returns in $params selected values of a texture environment that was specified with
     * {@see GL46::glTexEnv}. $target specifies a texture environment.
     *
     * When $target is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When
     * $target is {@see GL46::GL_POINT_SPRITE}, $pname must be {@see GL46::GL_COORD_REPLACE}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * $pname names a specific texture environment parameter, as follows:
     *
     *  - {@see GL46::GL_TEXTURE_ENV_MODE}: $params returns the single-valued
     *    texture environment mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_TEXTURE_ENV_COLOR}: $params returns four integer or
     *    floating-point values that are the texture environment color. Integer
     *    values,
     *    when requested, are linearly mapped from the internal floating-point
     *    representation such that 1.0 maps to the
     *    most positive representable integer, and   -1.0  maps to the most
     *    negative representable integer. The initial
     *    value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params returns a single
     *    floating-point value that is the texture level-of-detail bias. The
     *    initial value is
     *    0.
     *
     *  - {@see GL46::GL_COMBINE_RGB}: $params returns a single symbolic
     *    constant value representing the current RGB combine mode. The initial
     *    value
     *    is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_COMBINE_ALPHA}: $params returns a single symbolic
     *    constant value representing the current alpha combine mode. The
     *    initial
     *    value is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_SRC0_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's RGB source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner one's RGB source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner two's RGB source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_SRC0_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's alpha source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner one's alpha source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner two's alpha source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_OPERAND0_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND1_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner one's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND2_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner two's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND0_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND1_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner one's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND2_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner two's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_RGB_SCALE}: $params returns a single floating-point
     *    value representing the current RGB texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_ALPHA_SCALE}: $params returns a single floating-point
     *    value representing the current alpha texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_COORD_REPLACE}: $params returns a single boolean value
     *    representing the current point sprite texture coordinate replacement
     *    enable state. The initial value is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glGetTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getTexEnvfv(int $target, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetTexEnvfv($target, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexEnv} returns in $params selected values of a texture environment that was specified with
     * {@see GL46::glTexEnv}. $target specifies a texture environment.
     *
     * When $target is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When
     * $target is {@see GL46::GL_POINT_SPRITE}, $pname must be {@see GL46::GL_COORD_REPLACE}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * $pname names a specific texture environment parameter, as follows:
     *
     *  - {@see GL46::GL_TEXTURE_ENV_MODE}: $params returns the single-valued
     *    texture environment mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_TEXTURE_ENV_COLOR}: $params returns four integer or
     *    floating-point values that are the texture environment color. Integer
     *    values,
     *    when requested, are linearly mapped from the internal floating-point
     *    representation such that 1.0 maps to the
     *    most positive representable integer, and   -1.0  maps to the most
     *    negative representable integer. The initial
     *    value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params returns a single
     *    floating-point value that is the texture level-of-detail bias. The
     *    initial value is
     *    0.
     *
     *  - {@see GL46::GL_COMBINE_RGB}: $params returns a single symbolic
     *    constant value representing the current RGB combine mode. The initial
     *    value
     *    is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_COMBINE_ALPHA}: $params returns a single symbolic
     *    constant value representing the current alpha combine mode. The
     *    initial
     *    value is {@see GL46::GL_MODULATE}.
     *
     *  - {@see GL46::GL_SRC0_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's RGB source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner one's RGB source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_RGB}: $params returns a single symbolic constant
     *    value representing the texture combiner two's RGB source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_SRC0_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner zero's alpha source. The
     *    initial value is {@see GL46::GL_TEXTURE}.
     *
     *  - {@see GL46::GL_SRC1_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner one's alpha source. The
     *    initial value is {@see GL46::GL_PREVIOUS}.
     *
     *  - {@see GL46::GL_SRC2_ALPHA}: $params returns a single symbolic constant
     *    value representing the texture combiner two's alpha source. The
     *    initial value is {@see GL46::GL_CONSTANT}.
     *
     *  - {@see GL46::GL_OPERAND0_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND1_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner one's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_COLOR}.
     *
     *  - {@see GL46::GL_OPERAND2_RGB}: $params returns a single symbolic
     *    constant value representing the texture combiner two's RGB operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND0_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner zero's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND1_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner one's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_OPERAND2_ALPHA}: $params returns a single symbolic
     *    constant value representing the texture combiner two's alpha operand.
     *    The
     *    initial value is {@see GL46::GL_SRC_ALPHA}.
     *
     *  - {@see GL46::GL_RGB_SCALE}: $params returns a single floating-point
     *    value representing the current RGB texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_ALPHA_SCALE}: $params returns a single floating-point
     *    value representing the current alpha texture combiner scaling factor.
     *    The initial value is 1.0.
     *
     *  - {@see GL46::GL_COORD_REPLACE}: $params returns a single boolean value
     *    representing the current point sprite texture coordinate replacement
     *    enable state. The initial value is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glGetTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getTexEnviv(int $target, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetTexEnviv($target, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexGen} returns in $params selected parameters of a texture coordinate generation function
     * that was specified using {@see GL46::glTexGen}. $coord names one of the (s, t, r, q) texture coordinates,
     * using the symbolic constant {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}.
     *
     * $pname specifies one of three symbolic names:
     *
     *  - {@see GL46::GL_TEXTURE_GEN_MODE}: $params returns the single-valued
     *    texture generation function, a symbolic constant. The initial value is
     *    {@see GL46::GL_EYE_LINEAR}.
     *
     *  - {@see GL46::GL_OBJECT_PLANE}: $params returns the four plane equation
     *    coefficients that specify object linear-coordinate generation.
     *    Integer values, when requested, are mapped directly from the internal
     *    floating-point representation.
     *
     *  - {@see GL46::GL_EYE_PLANE}: $params returns the four plane equation
     *    coefficients that specify eye linear-coordinate generation. Integer
     *    values, when requested, are mapped directly from the internal
     *    floating-point representation. The returned
     *    values are those maintained in eye coordinates. They are not equal to
     *    the values specified using
     *    {@see GL46::glTexGen}, unless the modelview matrix was identity when
     *    {@see GL46::glTexGen} was called.
     *
     * @see http://docs.gl/gl2/glGetTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getTexGendv(int $coord, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLdouble', false);
        try {
            $this->info->ffi->glGetTexGendv($coord, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexGen} returns in $params selected parameters of a texture coordinate generation function
     * that was specified using {@see GL46::glTexGen}. $coord names one of the (s, t, r, q) texture coordinates,
     * using the symbolic constant {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}.
     *
     * $pname specifies one of three symbolic names:
     *
     *  - {@see GL46::GL_TEXTURE_GEN_MODE}: $params returns the single-valued
     *    texture generation function, a symbolic constant. The initial value is
     *    {@see GL46::GL_EYE_LINEAR}.
     *
     *  - {@see GL46::GL_OBJECT_PLANE}: $params returns the four plane equation
     *    coefficients that specify object linear-coordinate generation.
     *    Integer values, when requested, are mapped directly from the internal
     *    floating-point representation.
     *
     *  - {@see GL46::GL_EYE_PLANE}: $params returns the four plane equation
     *    coefficients that specify eye linear-coordinate generation. Integer
     *    values, when requested, are mapped directly from the internal
     *    floating-point representation. The returned
     *    values are those maintained in eye coordinates. They are not equal to
     *    the values specified using
     *    {@see GL46::glTexGen}, unless the modelview matrix was identity when
     *    {@see GL46::glTexGen} was called.
     *
     * @see http://docs.gl/gl2/glGetTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getTexGenfv(int $coord, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetTexGenfv($coord, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexGen} returns in $params selected parameters of a texture coordinate generation function
     * that was specified using {@see GL46::glTexGen}. $coord names one of the (s, t, r, q) texture coordinates,
     * using the symbolic constant {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}.
     *
     * $pname specifies one of three symbolic names:
     *
     *  - {@see GL46::GL_TEXTURE_GEN_MODE}: $params returns the single-valued
     *    texture generation function, a symbolic constant. The initial value is
     *    {@see GL46::GL_EYE_LINEAR}.
     *
     *  - {@see GL46::GL_OBJECT_PLANE}: $params returns the four plane equation
     *    coefficients that specify object linear-coordinate generation.
     *    Integer values, when requested, are mapped directly from the internal
     *    floating-point representation.
     *
     *  - {@see GL46::GL_EYE_PLANE}: $params returns the four plane equation
     *    coefficients that specify eye linear-coordinate generation. Integer
     *    values, when requested, are mapped directly from the internal
     *    floating-point representation. The returned
     *    values are those maintained in eye coordinates. They are not equal to
     *    the values specified using
     *    {@see GL46::glTexGen}, unless the modelview matrix was identity when
     *    {@see GL46::glTexGen} was called.
     *
     * @see http://docs.gl/gl2/glGetTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getTexGeniv(int $coord, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetTexGeniv($coord, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexImage}, {@see GL46::glGetnTexImage} and {@see GL46::glGetTextureImage} functions return a
     * texture image into $pixels. For {@see GL46::glGetTexImage} and {@see GL46::glGetnTexImage}, $target specifies
     * whether the desired texture image is one specified by {@see GL46::glTexImage1D} ({@see GL46::GL_TEXTURE_1D}),
     * {@see GL46::glTexImage2D} ({@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_RECTANGLE},
     * {@see GL46::GL_TEXTURE_2D} or any of {@see GL46::GL_TEXTURE_CUBE_MAP_*}), or {@see GL46::glTexImage3D}
     * ({@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}). For
     * {@see GL46::glGetTextureImage}, $texture specifies the texture object name. In addition to types of textures
     * accepted by {@see GL46::glGetTexImage} and {@see GL46::glGetnTexImage}, the function also accepts cube map
     * texture objects (with effective target {@see GL46::GL_TEXTURE_CUBE_MAP}). $level specifies the level-of-detail
     * number of the desired image. $format and $type specify the format and type of the desired image array. See the
     * reference page for {@see GL46::glTexImage1D}  for a description of the acceptable values for the $format and
     * $type parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of
     * the buffer to receive the retrieved pixel data. {@see GL46::glGetnTexImage} and {@see GL46::glGetTextureImage}
     * do not write more than $bufSize bytes into $pixels.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture image is requested, $pixels is treated as a byte offset into the
     * buffer object's data store.
     *
     * To understand the operation of {@see GL46::glGetTexImage}, consider the selected internal four-component
     * texture image to be an RGBA color buffer the size of the image. The semantics of {@see GL46::glGetTexImage}
     * are then identical to those of {@see GL46::glReadPixels}, with the exception that no pixel transfer operations
     * are performed, when called with the same $format and $type, with x and y set to 0, width set to the width of
     * the texture image and height set to 1 for 1D images, or to the height of the texture image for 2D images.
     *
     * If the selected texture image does not contain four components, the following mappings are applied.
     * Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to
     * 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the
     * value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally,
     * three-component textures are treated as RGBA buffers with red set to component zero, green set to component
     * one, blue set to component two, and alpha set to 1.
     *
     * To determine the required size of $pixels, use {@see GL46::glGetTexLevelParameter} to determine the dimensions
     * of the internal texture image, then scale the required number of pixels by the storage required for each
     * pixel, based on $format and $type. Be sure to take the pixel storage parameters into account, especially
     * {@see GL46::GL_PACK_ALIGNMENT}.
     *
     * If {@see GL46::glGetTextureImage} is used against a cube map texture object, the texture is treated as a
     * three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order
     * presented in the table below:
     *
     * | 0 | GL_TEXTURE_CUBE_MAP_POSITIVE_X |
     * | 1 | GL_TEXTURE_CUBE_MAP_NEGATIVE_X |
     * | 2 | GL_TEXTURE_CUBE_MAP_POSITIVE_Y |
     * | 3 | GL_TEXTURE_CUBE_MAP_NEGATIVE_Y |
     * | 4 | GL_TEXTURE_CUBE_MAP_POSITIVE_Z |
     * | 5 | GL_TEXTURE_CUBE_MAP_NEGATIVE_Z |
     * @see http://docs.gl/gl2/glGetTexImage
     * @see http://docs.gl/gl4/glGetTexImage
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function getTexImage(int $target, int $level, int $format, int $type, ?\FFI\CData $pixels): void
    {
        $this->info->ffi->glGetTexImage($target, $level, $format, $type, $pixels);
    }

    /**
     * {@see GL46::glGetTexLevelParameterfv}, {@see GL46::glGetTexLevelParameteriv},
     * {@see GL46::glGetTextureLevelParameterfv} and {@see GL46::glGetTextureLevelParameteriv} return in $params
     * texture parameter values for a specific level-of-detail value, specified as $level. For the first two
     * functions, $target defines the target texture, either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_PROXY_TEXTURE_1D}, {@see GL46::GL_PROXY_TEXTURE_2D},
     * {@see GL46::GL_PROXY_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_X},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@see GL46::GL_PROXY_TEXTURE_CUBE_MAP}. The remaining two take
     * a $texture argument which specifies the name of the texture object.
     *
     * {@see GL46::GL_MAX_TEXTURE_SIZE}, and {@see GL46::GL_MAX_3D_TEXTURE_SIZE} are not really descriptive enough.
     * It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny
     * texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to
     * more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot
     * be accommodated, the texture state variables, which may be queried with {@see GL46::glGetTexLevelParameter}
     * and {@see GL46::glGetTextureLevelParameter}, are set to 0. If the texture can be accommodated, the texture
     * state values will be set as they would be set for a non-proxy target.
     *
     * $pname specifies the texture parameter whose value or values will be returned.
     *
     * The accepted parameter names are as follows:
     *
     *  - {@see GL46::GL_TEXTURE_WIDTH}: $params returns a single value, the
     *    width of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_HEIGHT}: $params returns a single value, the
     *    height of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_DEPTH}: $params returns a single value, the
     *    depth of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_INTERNAL_FORMAT}: $params returns a single
     *    value, the internal format of the texture image.
     *
     *  - {@see GL46::GL_TEXTURE_RED_TYPE, GL_TEXTURE_GREEN_TYPE,
     *    GL_TEXTURE_BLUE_TYPE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_DEPTH_TYPE}:
     *    The data type used to store the component. The types {@see
     *    GL46::GL_NONE}, {@see GL46::GL_SIGNED_NORMALIZED},
     *    {@see GL46::GL_UNSIGNED_NORMALIZED}, {@see GL46::GL_FLOAT}, {@see
     *    GL46::GL_INT}, and
     *    {@see GL46::GL_UNSIGNED_INT} may be returned to indicate signed
     *    normalized fixed-point, unsigned normalized
     *    fixed-point, floating-point, integer unnormalized, and unsigned
     *    integer unnormalized components, respectively.
     *
     *  - {@see GL46::GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
     *    GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE}:
     *    The internal storage resolution of an individual component. The
     *    resolution chosen by the GL will be a close
     *    match for the resolution requested by the user with the component
     *    argument of {@see GL46::glTexImage1D},
     *    {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D}, {@see
     *    GL46::glCopyTexImage1D}, and
     *    {@see GL46::glCopyTexImage2D}. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_COMPRESSED}: $params returns a single boolean
     *    value indicating if the texture image is stored in a compressed
     *    internal
     *    format. The initiali value is {@see GL46::GL_FALSE}.
     *
     *  - {@see GL46::GL_TEXTURE_COMPRESSED_IMAGE_SIZE}: $params returns a
     *    single integer value, the number of unsigned bytes of the compressed
     *    texture image that
     *    would be returned from {@see GL46::glGetCompressedTexImage}.
     *
     *  - {@see GL46::GL_TEXTURE_BUFFER_OFFSET}: $params returns a single
     *    integer value, the offset into the data store of the buffer bound to a
     *    buffer
     *    texture. {@see GL46::glTexBufferRange}.
     *
     *  - {@see GL46::GL_TEXTURE_BUFFER_SIZE}: $params returns a single integer
     *    value, the size of the range of a data store of the buffer bound to a
     *    buffer
     *    texture. {@see GL46::glTexBufferRange}.
     *
     * @see http://docs.gl/gl2/glGetTexLevelParameter
     * @see http://docs.gl/gl4/glGetTexLevelParameter
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getTexLevelParameterfv(int $target, int $level, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetTexLevelParameterfv($target, $level, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexLevelParameterfv}, {@see GL46::glGetTexLevelParameteriv},
     * {@see GL46::glGetTextureLevelParameterfv} and {@see GL46::glGetTextureLevelParameteriv} return in $params
     * texture parameter values for a specific level-of-detail value, specified as $level. For the first two
     * functions, $target defines the target texture, either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_PROXY_TEXTURE_1D}, {@see GL46::GL_PROXY_TEXTURE_2D},
     * {@see GL46::GL_PROXY_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_X},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_Y},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@see GL46::GL_TEXTURE_CUBE_MAP_POSITIVE_Z},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@see GL46::GL_PROXY_TEXTURE_CUBE_MAP}. The remaining two take
     * a $texture argument which specifies the name of the texture object.
     *
     * {@see GL46::GL_MAX_TEXTURE_SIZE}, and {@see GL46::GL_MAX_3D_TEXTURE_SIZE} are not really descriptive enough.
     * It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny
     * texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to
     * more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot
     * be accommodated, the texture state variables, which may be queried with {@see GL46::glGetTexLevelParameter}
     * and {@see GL46::glGetTextureLevelParameter}, are set to 0. If the texture can be accommodated, the texture
     * state values will be set as they would be set for a non-proxy target.
     *
     * $pname specifies the texture parameter whose value or values will be returned.
     *
     * The accepted parameter names are as follows:
     *
     *  - {@see GL46::GL_TEXTURE_WIDTH}: $params returns a single value, the
     *    width of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_HEIGHT}: $params returns a single value, the
     *    height of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_DEPTH}: $params returns a single value, the
     *    depth of the texture image. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_INTERNAL_FORMAT}: $params returns a single
     *    value, the internal format of the texture image.
     *
     *  - {@see GL46::GL_TEXTURE_RED_TYPE, GL_TEXTURE_GREEN_TYPE,
     *    GL_TEXTURE_BLUE_TYPE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_DEPTH_TYPE}:
     *    The data type used to store the component. The types {@see
     *    GL46::GL_NONE}, {@see GL46::GL_SIGNED_NORMALIZED},
     *    {@see GL46::GL_UNSIGNED_NORMALIZED}, {@see GL46::GL_FLOAT}, {@see
     *    GL46::GL_INT}, and
     *    {@see GL46::GL_UNSIGNED_INT} may be returned to indicate signed
     *    normalized fixed-point, unsigned normalized
     *    fixed-point, floating-point, integer unnormalized, and unsigned
     *    integer unnormalized components, respectively.
     *
     *  - {@see GL46::GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
     *    GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE}:
     *    The internal storage resolution of an individual component. The
     *    resolution chosen by the GL will be a close
     *    match for the resolution requested by the user with the component
     *    argument of {@see GL46::glTexImage1D},
     *    {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D}, {@see
     *    GL46::glCopyTexImage1D}, and
     *    {@see GL46::glCopyTexImage2D}. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_COMPRESSED}: $params returns a single boolean
     *    value indicating if the texture image is stored in a compressed
     *    internal
     *    format. The initiali value is {@see GL46::GL_FALSE}.
     *
     *  - {@see GL46::GL_TEXTURE_COMPRESSED_IMAGE_SIZE}: $params returns a
     *    single integer value, the number of unsigned bytes of the compressed
     *    texture image that
     *    would be returned from {@see GL46::glGetCompressedTexImage}.
     *
     *  - {@see GL46::GL_TEXTURE_BUFFER_OFFSET}: $params returns a single
     *    integer value, the offset into the data store of the buffer bound to a
     *    buffer
     *    texture. {@see GL46::glTexBufferRange}.
     *
     *  - {@see GL46::GL_TEXTURE_BUFFER_SIZE}: $params returns a single integer
     *    value, the size of the range of a data store of the buffer bound to a
     *    buffer
     *    texture. {@see GL46::glTexBufferRange}.
     *
     * @see http://docs.gl/gl2/glGetTexLevelParameter
     * @see http://docs.gl/gl4/glGetTexLevelParameter
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getTexLevelParameteriv(int $target, int $level, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetTexLevelParameteriv($target, $level, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexParameter} and {@see GL46::glGetTextureParameter} return in $params the value or values of
     * the texture parameter specified as $pname. $target defines the target texture. {@see GL46::GL_TEXTURE_1D},
     * {@see GL46::GL_TEXTURE_2D}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_1D_ARRAY},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_RECTANGLE}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE}, or
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY} specify one-, two-, or three-dimensional, one-dimensional array,
     * two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or
     * two-dimensional multisample array texturing, respectively. $pname accepts the same symbols as
     * {@see GL46::glTexParameter}, with the same interpretations:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Returns the single-value
     *    depth stencil texture mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: Returns the single-valued texture
     *    magnification filter, a symbolic constant. The initial value is
     *    {@see GL46::GL_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: Returns the single-valued texture
     *    minification filter, a symbolic constant. The initial value is
     *    {@see GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Returns the single-valued texture
     *    minimum level-of-detail value. The initial value is   -1000  .
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Returns the single-valued texture
     *    maximum level-of-detail value. The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Returns the single-valued base
     *    texture mipmap level. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Returns the single-valued maximum
     *    texture mipmap array level. The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Returns the red component swizzle.
     *    The initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Returns the green component
     *    swizzle. The initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Returns the blue component swizzle.
     *    The initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Returns the alpha component
     *    swizzle. The initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Returns the component swizzle
     *    for all channels in a single query.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Returns the single-valued wrapping
     *    function for texture coordinate s, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Returns the single-valued wrapping
     *    function for texture coordinate t, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Returns the single-valued wrapping
     *    function for texture coordinate r, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: Returns four integer or
     *    floating-point numbers that comprise the RGBA color of the texture
     *    border.
     *    Floating-point values are returned in the range    0 1  . Integer
     *    values are returned as a linear mapping of
     *    the internal floating-point representation such that 1.0 maps to the
     *    most positive representable integer and
     *    -1.0  maps to the most negative representable integer. The initial
     *    value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Returns a single-valued texture
     *    comparison mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_NONE}. See {@see GL46::glTexParameter}.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Returns a single-valued texture
     *    comparison function, a symbolic constant. The initial value is
     *    {@see GL46::GL_LEQUAL}. See {@see GL46::glTexParameter}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_MIN_LEVEL}: Returns a single-valued base
     *    level of a texture view relative to its parent. The initial value is
     *    0. See
     *    {@see GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_NUM_LEVELS}: Returns a single-valued
     *    number of levels of detail of a texture view. See {@see
     *    GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_MIN_LAYER}: Returns a single-valued first
     *    level of a texture array view relative to its parent. See
     *    {@see GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_NUM_LAYERS}: Returns a single-valued
     *    number of layers in a texture array view. See {@see
     *    GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_IMMUTABLE_LEVELS}: Returns a single-valued
     *    number of immutable texture levels in a texture view. See {@see
     *    GL46::glTextureView}.
     *
     * In addition to the parameters that may be set with {@see GL46::glTexParameter}, {@see GL46::glGetTexParameter}
     * and {@see GL46::glGetTextureParameter} accept the following read-only parameters:
     *
     *  - {@see GL46::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE}: Returns the matching
     *    criteria use for the texture when used as an image texture. Can return
     *    {@see GL46::GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE}, {@see
     *    GL46::GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS} or
     *    {@see GL46::GL_NONE}.
     *
     *  - {@see GL46::GL_TEXTURE_IMMUTABLE_FORMAT}: Returns non-zero if the
     *    texture has an immutable format. Textures become immutable if their
     *    storage is
     *    specified with {@see GL46::glTexStorage1D}, {@see
     *    GL46::glTexStorage2D} or {@see GL46::glTexStorage3D}. The
     *    initial value is {@see GL46::GL_FALSE}.
     *
     *  - {@see GL46::GL_TEXTURE_TARGET}: Returns the effective target of the
     *    texture object. For {@see GL46::glGetTex*Parameter} functions, this is
     *    the
     *    target parameter. For {@see GL46::glGetTextureParameter*}, it is the
     *    target to which the texture was initially
     *    bound when it was created, or the value of the target parameter to the
     *    call to {@see GL46::glCreateTextures}
     *    which created the texture.
     *
     * @see http://docs.gl/gl2/glGetTexParameter
     * @see http://docs.gl/gl4/glGetTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param float|null $params
     * @return void
     */
    public function getTexParameterfv(int $target, int $pname, ?float &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLfloat', false);
        try {
            $this->info->ffi->glGetTexParameterfv($target, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * {@see GL46::glGetTexParameter} and {@see GL46::glGetTextureParameter} return in $params the value or values of
     * the texture parameter specified as $pname. $target defines the target texture. {@see GL46::GL_TEXTURE_1D},
     * {@see GL46::GL_TEXTURE_2D}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_1D_ARRAY},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_RECTANGLE}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE}, or
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY} specify one-, two-, or three-dimensional, one-dimensional array,
     * two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or
     * two-dimensional multisample array texturing, respectively. $pname accepts the same symbols as
     * {@see GL46::glTexParameter}, with the same interpretations:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Returns the single-value
     *    depth stencil texture mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: Returns the single-valued texture
     *    magnification filter, a symbolic constant. The initial value is
     *    {@see GL46::GL_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: Returns the single-valued texture
     *    minification filter, a symbolic constant. The initial value is
     *    {@see GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Returns the single-valued texture
     *    minimum level-of-detail value. The initial value is   -1000  .
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Returns the single-valued texture
     *    maximum level-of-detail value. The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Returns the single-valued base
     *    texture mipmap level. The initial value is 0.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Returns the single-valued maximum
     *    texture mipmap array level. The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Returns the red component swizzle.
     *    The initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Returns the green component
     *    swizzle. The initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Returns the blue component swizzle.
     *    The initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Returns the alpha component
     *    swizzle. The initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Returns the component swizzle
     *    for all channels in a single query.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Returns the single-valued wrapping
     *    function for texture coordinate s, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Returns the single-valued wrapping
     *    function for texture coordinate t, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Returns the single-valued wrapping
     *    function for texture coordinate r, a symbolic constant. The initial
     *    value
     *    is {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: Returns four integer or
     *    floating-point numbers that comprise the RGBA color of the texture
     *    border.
     *    Floating-point values are returned in the range    0 1  . Integer
     *    values are returned as a linear mapping of
     *    the internal floating-point representation such that 1.0 maps to the
     *    most positive representable integer and
     *    -1.0  maps to the most negative representable integer. The initial
     *    value is (0, 0, 0, 0).
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Returns a single-valued texture
     *    comparison mode, a symbolic constant. The initial value is
     *    {@see GL46::GL_NONE}. See {@see GL46::glTexParameter}.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Returns a single-valued texture
     *    comparison function, a symbolic constant. The initial value is
     *    {@see GL46::GL_LEQUAL}. See {@see GL46::glTexParameter}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_MIN_LEVEL}: Returns a single-valued base
     *    level of a texture view relative to its parent. The initial value is
     *    0. See
     *    {@see GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_NUM_LEVELS}: Returns a single-valued
     *    number of levels of detail of a texture view. See {@see
     *    GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_MIN_LAYER}: Returns a single-valued first
     *    level of a texture array view relative to its parent. See
     *    {@see GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_VIEW_NUM_LAYERS}: Returns a single-valued
     *    number of layers in a texture array view. See {@see
     *    GL46::glTextureView}.
     *
     *  - {@see GL46::GL_TEXTURE_IMMUTABLE_LEVELS}: Returns a single-valued
     *    number of immutable texture levels in a texture view. See {@see
     *    GL46::glTextureView}.
     *
     * In addition to the parameters that may be set with {@see GL46::glTexParameter}, {@see GL46::glGetTexParameter}
     * and {@see GL46::glGetTextureParameter} accept the following read-only parameters:
     *
     *  - {@see GL46::GL_IMAGE_FORMAT_COMPATIBILITY_TYPE}: Returns the matching
     *    criteria use for the texture when used as an image texture. Can return
     *    {@see GL46::GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE}, {@see
     *    GL46::GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS} or
     *    {@see GL46::GL_NONE}.
     *
     *  - {@see GL46::GL_TEXTURE_IMMUTABLE_FORMAT}: Returns non-zero if the
     *    texture has an immutable format. Textures become immutable if their
     *    storage is
     *    specified with {@see GL46::glTexStorage1D}, {@see
     *    GL46::glTexStorage2D} or {@see GL46::glTexStorage3D}. The
     *    initial value is {@see GL46::GL_FALSE}.
     *
     *  - {@see GL46::GL_TEXTURE_TARGET}: Returns the effective target of the
     *    texture object. For {@see GL46::glGetTex*Parameter} functions, this is
     *    the
     *    target parameter. For {@see GL46::glGetTextureParameter*}, it is the
     *    target to which the texture was initially
     *    bound when it was created, or the value of the target parameter to the
     *    call to {@see GL46::glCreateTextures}
     *    which created the texture.
     *
     * @see http://docs.gl/gl2/glGetTexParameter
     * @see http://docs.gl/gl4/glGetTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param int|null $params
     * @return void
     */
    public function getTexParameteriv(int $target, int $pname, ?int &$params): void
    {
        $paramsCType = $this->info->ffi->new('GLint', false);
        try {
            $this->info->ffi->glGetTexParameteriv($target, $pname, \FFI::addr($paramsCType));
        } finally {
            $params = $paramsCType->cdata;
            \FFI::free($paramsCType);
        }
    }

    /**
     * Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is
     * specified with two arguments. $target is a symbolic constant indicating the behavior to be controlled, and
     * $mode is another symbolic constant indicating the desired behavior. The initial value for each $target is
     * {@see GL46::GL_DONT_CARE}. $mode can be one of the following:
     *
     *  - {@see GL46::GL_FASTEST}: The most efficient option should be chosen.
     *
     *  - {@see GL46::GL_NICEST}: The most correct, or highest quality, option
     *    should be chosen.
     *
     *  - {@see GL46::GL_DONT_CARE}: No preference.
     *
     * Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends
     * on the implementation. The hint aspects that can be specified with $target, along with suggested semantics,
     * are as follows:
     *
     *  - {@see GL46::GL_FRAGMENT_SHADER_DERIVATIVE_HINT}: Indicates the
     *    accuracy of the derivative calculation for the GL shading language
     *    fragment processing
     *    built-in functions: {@see GL46::dFdx}, {@see GL46::dFdy}, and {@see
     *    GL46::fwidth}.
     *
     *  - {@see GL46::GL_LINE_SMOOTH_HINT}: Indicates the sampling quality of
     *    antialiased lines. If a larger filter function is applied, hinting
     *    {@see GL46::GL_NICEST} can result in more pixel fragments being
     *    generated during rasterization.
     *
     *  - {@see GL46::GL_POLYGON_SMOOTH_HINT}: Indicates the sampling quality of
     *    antialiased polygons. Hinting {@see GL46::GL_NICEST} can result in
     *    more
     *    pixel fragments being generated during rasterization, if a larger
     *    filter function is applied.
     *
     *  - {@see GL46::GL_TEXTURE_COMPRESSION_HINT}: Indicates the quality and
     *    performance of the compressing texture images. Hinting {@see
     *    GL46::GL_FASTEST}
     *    indicates that texture images should be compressed as quickly as
     *    possible, while {@see GL46::GL_NICEST}
     *    indicates that texture images should be compressed with as little
     *    image quality loss as possible.
     *    {@see GL46::GL_NICEST} should be selected if the texture is to be
     *    retrieved by
     *    {@see GL46::glGetCompressedTexImage} for reuse.
     *
     * @see http://docs.gl/gl2/glHint
     * @see http://docs.gl/gl4/glHint
     * @since 1.1
     * @param int $target
     * @param int $mode
     * @return void
     */
    public function hint(int $target, int $mode): void
    {
        $this->info->ffi->glHint($target, $mode);
    }

    /**
     * {@see GL46::glIndexMask} controls the writing of individual bits in the color index buffers. The least
     * significant n bits of $mask, where n is the number of bits in a color index buffer, specify a mask. Where a 1
     * (one) appears in the mask, it's possible to write to the corresponding bit in the color index buffer (or
     * buffers). Where a 0 (zero) appears, the corresponding bit is write-protected.
     *
     * This mask is used only in color index mode, and it affects only the buffers currently selected for writing
     * (see {@see GL46::glDrawBuffer}). Initially, all bits are enabled for writing.
     *
     * @see http://docs.gl/gl2/glIndexMask
     * @since 1.1
     * @param int $mask
     * @return void
     */
    public function indexMask(int $mask): void
    {
        $this->info->ffi->glIndexMask($mask);
    }

    /**
     * {@see GL46::glIndexPointer} specifies the location and data format of an array of color indexes to use when
     * rendering. $type specifies the data type of each color index and $stride specifies the byte stride from one
     * color index to the next, allowing vertices and attributes to be packed into a single array or stored in
     * separate arrays.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a color index array is specified, $pointer is treated as a byte offset into
     * the buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is
     * saved as color index vertex array client-side state ({@see GL46::GL_INDEX_ARRAY_BUFFER_BINDING}).
     *
     * When a color index array is specified, $type, $stride, and $pointer are saved as client-side state, in
     * addition to the current vertex array buffer object binding.
     *
     * To enable and disable the color index array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_INDEX_ARRAY}. If enabled, the color index
     * array is used when {@see GL46::glDrawArrays}, {@see GL46::glMultiDrawArrays}, {@see GL46::glDrawElements},
     * {@see GL46::glMultiDrawElements}, {@see GL46::glDrawRangeElements}, or {@see GL46::glArrayElement} is called.
     *
     * @see http://docs.gl/gl2/glIndexPointer
     * @since 1.1
     * @param int $type
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function indexPointer(int $type, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glIndexPointer($type, $stride, $pointer);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param float $c
     * @return void
     */
    public function indexd(float $c): void
    {
        $this->info->ffi->glIndexd($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param \FFI\CData|null $c
     * @return void
     */
    public function indexdv(?\FFI\CData $c): void
    {
        $this->info->ffi->glIndexdv($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param float $c
     * @return void
     */
    public function indexf(float $c): void
    {
        $this->info->ffi->glIndexf($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param \FFI\CData|null $c
     * @return void
     */
    public function indexfv(?\FFI\CData $c): void
    {
        $this->info->ffi->glIndexfv($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param int $c
     * @return void
     */
    public function indexi(int $c): void
    {
        $this->info->ffi->glIndexi($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param \FFI\CData|null $c
     * @return void
     */
    public function indexiv(?\FFI\CData $c): void
    {
        $this->info->ffi->glIndexiv($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param int $c
     * @return void
     */
    public function indexs(int $c): void
    {
        $this->info->ffi->glIndexs($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param \FFI\CData|null $c
     * @return void
     */
    public function indexsv(?\FFI\CData $c): void
    {
        $this->info->ffi->glIndexsv($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param int $c
     * @return void
     */
    public function indexub(int $c): void
    {
        $this->info->ffi->glIndexub($c);
    }

    /**
     * {@see GL46::glIndex} updates the current (single-valued) color index. It takes one argument, the new value for
     * the current color index.
     *
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point
     * values, with no special mapping. The initial value is 1.
     *
     * Index values outside the representable range of the color index buffer are not clamped. However, before an
     * index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any
     * bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame
     * buffer are masked out.
     *
     * @see http://docs.gl/gl2/glIndex
     * @since 1.1
     * @param \FFI\CData|null $c
     * @return void
     */
    public function indexubv(?\FFI\CData $c): void
    {
        $this->info->ffi->glIndexubv($c);
    }

    /**
     * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It
     * consists of an ordered set of unsigned integers. {@see GL46::glInitNames} causes the name stack to be
     * initialized to its default empty state.
     *
     * The name stack is always empty while the render mode is not {@see GL46::GL_SELECT}. Calls to
     * {@see GL46::glInitNames} while the render mode is not {@see GL46::GL_SELECT} are ignored.
     *
     * @see http://docs.gl/gl2/glInitNames
     * @since 1.1
     * @return void
     */
    public function initNames(): void
    {
        $this->info->ffi->glInitNames();
    }

    /**
     * {@see GL46::glInterleavedArrays} lets you specify and enable individual color, normal, texture and vertex
     * arrays whose elements are part of a larger aggregate array element. For some implementations, this is more
     * efficient than specifying the arrays separately.
     *
     * If $stride is 0, the aggregate elements are stored consecutively. Otherwise, $stride bytes occur between the
     * beginning of one aggregate array element and the beginning of the next aggregate array element.
     *
     * $format serves as a ``key'' describing the extraction of individual arrays from the aggregate array. If
     * $format contains a T, then texture coordinates are extracted from the interleaved array. If C is present,
     * color values are extracted. If N is present, normal coordinates are extracted. Vertex coordinates are always
     * extracted.
     *
     * The digits 2, 3, and 4 denote how many values are extracted. F indicates that values are extracted as
     * floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C. If a color is
     * extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible
     * floating-point aligned address.
     *
     * @see http://docs.gl/gl2/glInterleavedArrays
     * @since 1.1
     * @param int $format
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function interleavedArrays(int $format, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glInterleavedArrays($format, $stride, $pointer);
    }

    /**
     * {@see GL46::glIsEnabled} returns {@see GL46::GL_TRUE} if $cap is an enabled capability and returns
     * {@see GL46::GL_FALSE} otherwise. Boolean states that are indexed may be tested with {@see GL46::glIsEnabledi}.
     * For {@see GL46::glIsEnabledi}, $index specifies the index of the capability to test. $index must be between
     * zero and the count of indexed capabilities for $cap. Initially all capabilities except {@see GL46::GL_DITHER}
     * are disabled; {@see GL46::GL_DITHER} is initially enabled.
     *
     * The following capabilities are accepted for $cap:
     *
     * | {@see GL46::GL_BLEND}                     | {@see GL46::glBlendFunc}, {@see GL46::glLogicOp}            |
     * | {@see GL46::GL_CLIP_DISTANCE}i            | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_COLOR_LOGIC_OP}            | {@see GL46::glLogicOp}                                      |
     * | {@see GL46::GL_CULL_FACE}                 | {@see GL46::glCullFace}                                     |
     * | {@see GL46::GL_DEPTH_CLAMP}               | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_DEBUG_OUTPUT}              | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_DEBUG_OUTPUT_SYNCHRONOUS}  | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_DEPTH_TEST}                | {@see GL46::glDepthFunc}, {@see GL46::glDepthRange}         |
     * | {@see GL46::GL_DITHER}                    | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_FRAMEBUFFER_SRGB}          | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_LINE_SMOOTH}               | {@see GL46::glLineWidth}                                    |
     * | {@see GL46::GL_MULTISAMPLE}               | {@see GL46::glSampleCoverage}                               |
     * | {@see GL46::GL_POLYGON_SMOOTH}            | {@see GL46::glPolygonMode}                                  |
     * | {@see GL46::GL_POLYGON_OFFSET_FILL}       | {@see GL46::glPolygonOffset}                                |
     * | {@see GL46::GL_POLYGON_OFFSET_LINE}       | {@see GL46::glPolygonOffset}                                |
     * | {@see GL46::GL_POLYGON_OFFSET_POINT}      | {@see GL46::glPolygonOffset}                                |
     * | {@see GL46::GL_PROGRAM_POINT_SIZE}        | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_PRIMITIVE_RESTART}         | {@see GL46::glEnable}, {@see GL46::glPrimitiveRestartIndex} |
     * | {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE}  | {@see GL46::glSampleCoverage}                               |
     * | {@see GL46::GL_SAMPLE_ALPHA_TO_ONE}       | {@see GL46::glSampleCoverage}                               |
     * | {@see GL46::GL_SAMPLE_COVERAGE}           | {@see GL46::glSampleCoverage}                               |
     * | {@see GL46::GL_SAMPLE_MASK}               | {@see GL46::glEnable}                                       |
     * | {@see GL46::GL_SCISSOR_TEST}              | {@see GL46::glScissor}                                      |
     * | {@see GL46::GL_STENCIL_TEST}              | {@see GL46::glStencilFunc}, {@see GL46::glStencilOp}        |
     * | {@see GL46::GL_TEXTURE_CUBE_MAP_SEAMLESS} | {@see GL46::glEnable}                                       |
     * @see http://docs.gl/gl2/glIsEnabled
     * @see http://docs.gl/gl4/glIsEnabled
     * @since 1.1
     * @param int $cap
     * @return bool
     */
    public function isEnabled(int $cap): bool
    {
        return $this->info->ffi->glIsEnabled($cap) !== 0;
    }

    /**
     * {@see GL46::glIsList} returns {@see GL46::GL_TRUE} if $list is the name of a display list and returns
     * {@see GL46::GL_FALSE} if it is not, or if an error occurs.
     *
     * A name returned by {@see GL46::glGenLists}, but not yet associated with a display list by calling
     * {@see GL46::glNewList}, is not the name of a display list.
     *
     * @see http://docs.gl/gl2/glIsList
     * @since 1.1
     * @param int $list
     * @return bool
     */
    public function isList(int $list): bool
    {
        return $this->info->ffi->glIsList($list) !== 0;
    }

    /**
     * {@see GL46::glIsTexture} returns {@see GL46::GL_TRUE} if $texture is currently the name of a texture. If
     * $texture is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs,
     * {@see GL46::glIsTexture} returns {@see GL46::GL_FALSE}.
     *
     * A name returned by {@see GL46::glGenTextures}, but not yet associated with a texture by calling
     * {@see GL46::glBindTexture}, is not the name of a texture.
     *
     * @see http://docs.gl/gl2/glIsTexture
     * @see http://docs.gl/gl4/glIsTexture
     * @since 1.1
     * @param int $texture
     * @return bool
     */
    public function isTexture(int $texture): bool
    {
        return $this->info->ffi->glIsTexture($texture) !== 0;
    }

    /**
     * {@see GL46::glLightModel} sets the lighting model parameter. $pname names a parameter and $params gives the
     * new value. There are three lighting model parameters:
     *
     *  - {@see GL46::GL_LIGHT_MODEL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    entire scene. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0,
     *    and the most negative representable value maps to   -1.0 .
     *    Floating-point values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    scene intensity is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_LIGHT_MODEL_COLOR_CONTROL}: $params must be either
     *    {@see GL46::GL_SEPARATE_SPECULAR_COLOR} or {@see
     *    GL46::GL_SINGLE_COLOR}.
     *    {@see GL46::GL_SINGLE_COLOR} specifies that a single color is
     *    generated from the lighting computation for a
     *    vertex. {@see GL46::GL_SEPARATE_SPECULAR_COLOR} specifies that the
     *    specular color computation of lighting be
     *    stored separately from the remainder of the lighting computation. The
     *    specular color is summed into the
     *    generated fragment's color after the application of texture mapping
     *    (if enabled). The initial value is
     *    {@see GL46::GL_SINGLE_COLOR}.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER}: $params is a single integer
     *    or floating-point value that specifies how specular reflection angles
     *    are
     *    computed. If $params is 0 (or 0.0), specular reflection angles take
     *    the view direction to be parallel to and
     *    in the direction of the -z axis, regardless of the location of the
     *    vertex in eye coordinates. Otherwise,
     *    specular reflections are computed from the origin of the eye
     *    coordinate system. The initial value is 0.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_TWO_SIDE}: $params is a single integer or
     *    floating-point value that specifies whether one- or two-sided lighting
     *    calculations are done for polygons. It has no effect on the lighting
     *    calculations for points, lines, or
     *    bitmaps. If $params is 0 (or 0.0), one-sided lighting is specified,
     *    and only the front material parameters are
     *    used in the lighting equation. Otherwise, two-sided lighting is
     *    specified. In this case, vertices of
     *    back-facing polygons are lighted using the back material parameters
     *    and have their normals reversed before the
     *    lighting equation is evaluated. Vertices of front-facing polygons are
     *    always lighted using the front material
     *    parameters, with no change to their normals. The initial value is 0.
     *
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the
     * material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each
     * enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * The ambient light source contribution is the product of the material ambient reflectance and the light's
     * ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance,
     * the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the
     * vertex to the light source. The specular light source contribution is the product of the material specular
     * reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and
     * vertex-to-light vectors, raised to the power of the shininess of the material. All three light source
     * contributions are attenuated equally based on the distance from the vertex to the light source and on light
     * source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they
     * evaluate to a negative value.
     *
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse
     * reflectance.
     *
     * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values
     * passed to {@see GL46::glMaterial} using {@see GL46::GL_COLOR_INDEXES}. Diffuse and specular coefficients,
     * computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same
     * reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index
     * is.
     *
     * @see http://docs.gl/gl2/glLightModel
     * @since 1.1
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function lightModelf(int $pname, float $param): void
    {
        $this->info->ffi->glLightModelf($pname, $param);
    }

    /**
     * {@see GL46::glLightModel} sets the lighting model parameter. $pname names a parameter and $params gives the
     * new value. There are three lighting model parameters:
     *
     *  - {@see GL46::GL_LIGHT_MODEL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    entire scene. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0,
     *    and the most negative representable value maps to   -1.0 .
     *    Floating-point values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    scene intensity is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_LIGHT_MODEL_COLOR_CONTROL}: $params must be either
     *    {@see GL46::GL_SEPARATE_SPECULAR_COLOR} or {@see
     *    GL46::GL_SINGLE_COLOR}.
     *    {@see GL46::GL_SINGLE_COLOR} specifies that a single color is
     *    generated from the lighting computation for a
     *    vertex. {@see GL46::GL_SEPARATE_SPECULAR_COLOR} specifies that the
     *    specular color computation of lighting be
     *    stored separately from the remainder of the lighting computation. The
     *    specular color is summed into the
     *    generated fragment's color after the application of texture mapping
     *    (if enabled). The initial value is
     *    {@see GL46::GL_SINGLE_COLOR}.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER}: $params is a single integer
     *    or floating-point value that specifies how specular reflection angles
     *    are
     *    computed. If $params is 0 (or 0.0), specular reflection angles take
     *    the view direction to be parallel to and
     *    in the direction of the -z axis, regardless of the location of the
     *    vertex in eye coordinates. Otherwise,
     *    specular reflections are computed from the origin of the eye
     *    coordinate system. The initial value is 0.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_TWO_SIDE}: $params is a single integer or
     *    floating-point value that specifies whether one- or two-sided lighting
     *    calculations are done for polygons. It has no effect on the lighting
     *    calculations for points, lines, or
     *    bitmaps. If $params is 0 (or 0.0), one-sided lighting is specified,
     *    and only the front material parameters are
     *    used in the lighting equation. Otherwise, two-sided lighting is
     *    specified. In this case, vertices of
     *    back-facing polygons are lighted using the back material parameters
     *    and have their normals reversed before the
     *    lighting equation is evaluated. Vertices of front-facing polygons are
     *    always lighted using the front material
     *    parameters, with no change to their normals. The initial value is 0.
     *
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the
     * material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each
     * enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * The ambient light source contribution is the product of the material ambient reflectance and the light's
     * ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance,
     * the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the
     * vertex to the light source. The specular light source contribution is the product of the material specular
     * reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and
     * vertex-to-light vectors, raised to the power of the shininess of the material. All three light source
     * contributions are attenuated equally based on the distance from the vertex to the light source and on light
     * source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they
     * evaluate to a negative value.
     *
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse
     * reflectance.
     *
     * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values
     * passed to {@see GL46::glMaterial} using {@see GL46::GL_COLOR_INDEXES}. Diffuse and specular coefficients,
     * computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same
     * reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index
     * is.
     *
     * @see http://docs.gl/gl2/glLightModel
     * @since 1.1
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function lightModelfv(int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glLightModelfv($pname, $params);
    }

    /**
     * {@see GL46::glLightModel} sets the lighting model parameter. $pname names a parameter and $params gives the
     * new value. There are three lighting model parameters:
     *
     *  - {@see GL46::GL_LIGHT_MODEL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    entire scene. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0,
     *    and the most negative representable value maps to   -1.0 .
     *    Floating-point values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    scene intensity is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_LIGHT_MODEL_COLOR_CONTROL}: $params must be either
     *    {@see GL46::GL_SEPARATE_SPECULAR_COLOR} or {@see
     *    GL46::GL_SINGLE_COLOR}.
     *    {@see GL46::GL_SINGLE_COLOR} specifies that a single color is
     *    generated from the lighting computation for a
     *    vertex. {@see GL46::GL_SEPARATE_SPECULAR_COLOR} specifies that the
     *    specular color computation of lighting be
     *    stored separately from the remainder of the lighting computation. The
     *    specular color is summed into the
     *    generated fragment's color after the application of texture mapping
     *    (if enabled). The initial value is
     *    {@see GL46::GL_SINGLE_COLOR}.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER}: $params is a single integer
     *    or floating-point value that specifies how specular reflection angles
     *    are
     *    computed. If $params is 0 (or 0.0), specular reflection angles take
     *    the view direction to be parallel to and
     *    in the direction of the -z axis, regardless of the location of the
     *    vertex in eye coordinates. Otherwise,
     *    specular reflections are computed from the origin of the eye
     *    coordinate system. The initial value is 0.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_TWO_SIDE}: $params is a single integer or
     *    floating-point value that specifies whether one- or two-sided lighting
     *    calculations are done for polygons. It has no effect on the lighting
     *    calculations for points, lines, or
     *    bitmaps. If $params is 0 (or 0.0), one-sided lighting is specified,
     *    and only the front material parameters are
     *    used in the lighting equation. Otherwise, two-sided lighting is
     *    specified. In this case, vertices of
     *    back-facing polygons are lighted using the back material parameters
     *    and have their normals reversed before the
     *    lighting equation is evaluated. Vertices of front-facing polygons are
     *    always lighted using the front material
     *    parameters, with no change to their normals. The initial value is 0.
     *
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the
     * material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each
     * enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * The ambient light source contribution is the product of the material ambient reflectance and the light's
     * ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance,
     * the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the
     * vertex to the light source. The specular light source contribution is the product of the material specular
     * reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and
     * vertex-to-light vectors, raised to the power of the shininess of the material. All three light source
     * contributions are attenuated equally based on the distance from the vertex to the light source and on light
     * source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they
     * evaluate to a negative value.
     *
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse
     * reflectance.
     *
     * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values
     * passed to {@see GL46::glMaterial} using {@see GL46::GL_COLOR_INDEXES}. Diffuse and specular coefficients,
     * computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same
     * reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index
     * is.
     *
     * @see http://docs.gl/gl2/glLightModel
     * @since 1.1
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function lightModeli(int $pname, int $param): void
    {
        $this->info->ffi->glLightModeli($pname, $param);
    }

    /**
     * {@see GL46::glLightModel} sets the lighting model parameter. $pname names a parameter and $params gives the
     * new value. There are three lighting model parameters:
     *
     *  - {@see GL46::GL_LIGHT_MODEL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    entire scene. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0,
     *    and the most negative representable value maps to   -1.0 .
     *    Floating-point values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    scene intensity is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_LIGHT_MODEL_COLOR_CONTROL}: $params must be either
     *    {@see GL46::GL_SEPARATE_SPECULAR_COLOR} or {@see
     *    GL46::GL_SINGLE_COLOR}.
     *    {@see GL46::GL_SINGLE_COLOR} specifies that a single color is
     *    generated from the lighting computation for a
     *    vertex. {@see GL46::GL_SEPARATE_SPECULAR_COLOR} specifies that the
     *    specular color computation of lighting be
     *    stored separately from the remainder of the lighting computation. The
     *    specular color is summed into the
     *    generated fragment's color after the application of texture mapping
     *    (if enabled). The initial value is
     *    {@see GL46::GL_SINGLE_COLOR}.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER}: $params is a single integer
     *    or floating-point value that specifies how specular reflection angles
     *    are
     *    computed. If $params is 0 (or 0.0), specular reflection angles take
     *    the view direction to be parallel to and
     *    in the direction of the -z axis, regardless of the location of the
     *    vertex in eye coordinates. Otherwise,
     *    specular reflections are computed from the origin of the eye
     *    coordinate system. The initial value is 0.
     *
     *  - {@see GL46::GL_LIGHT_MODEL_TWO_SIDE}: $params is a single integer or
     *    floating-point value that specifies whether one- or two-sided lighting
     *    calculations are done for polygons. It has no effect on the lighting
     *    calculations for points, lines, or
     *    bitmaps. If $params is 0 (or 0.0), one-sided lighting is specified,
     *    and only the front material parameters are
     *    used in the lighting equation. Otherwise, two-sided lighting is
     *    specified. In this case, vertices of
     *    back-facing polygons are lighted using the back material parameters
     *    and have their normals reversed before the
     *    lighting equation is evaluated. Vertices of front-facing polygons are
     *    always lighted using the front material
     *    parameters, with no change to their normals. The initial value is 0.
     *
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the
     * material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each
     * enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * The ambient light source contribution is the product of the material ambient reflectance and the light's
     * ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance,
     * the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the
     * vertex to the light source. The specular light source contribution is the product of the material specular
     * reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and
     * vertex-to-light vectors, raised to the power of the shininess of the material. All three light source
     * contributions are attenuated equally based on the distance from the vertex to the light source and on light
     * source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they
     * evaluate to a negative value.
     *
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse
     * reflectance.
     *
     * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values
     * passed to {@see GL46::glMaterial} using {@see GL46::GL_COLOR_INDEXES}. Diffuse and specular coefficients,
     * computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same
     * reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index
     * is.
     *
     * @see http://docs.gl/gl2/glLightModel
     * @since 1.1
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function lightModeliv(int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glLightModeliv($pname, $params);
    }

    /**
     * {@see GL46::glLight} sets the values of individual light source parameters. $light names the light and is a
     * symbolic name of the form {@see GL46::GL_LIGHT} i, where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. $pname specifies one of ten light source parameters, again by symbolic name.
     * $params is either a single value or a pointer to an array that contains the new values.
     *
     * To enable and disable lighting calculation, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are
     * enabled contribute to the lighting calculation. Light source i is enabled and disabled using
     * {@see GL46::glEnable} and {@see GL46::glDisable} with argument {@see GL46::GL_LIGHT} i.
     *
     * The ten light parameters are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial ambient light intensity
     *    is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_POSITION}: $params contains four integer or
     *    floating-point values that specify the position of the light in
     *    homogeneous
     *    object coordinates. Both integer and floating-point values are mapped
     *    directly. Neither integer nor
     *    floating-point values are clamped.   The position is transformed by
     *    the modelview matrix when
     *    {@see GL46::glLight} is called (just as if it were a point), and it is
     *    stored in eye coordinates. If the w
     *    component of the position is 0, the light is treated as a directional
     *    source. Diffuse and specular lighting
     *    calculations take the light's direction, but not its actual position,
     *    into account, and attenuation is
     *    disabled. Otherwise, diffuse and specular lighting calculations are
     *    based on the actual location of the light
     *    in eye coordinates, and attenuation is enabled. The initial position
     *    is (0, 0, 1, 0); thus, the initial light
     *    source is directional, parallel to, and in the direction of the    - z
     *      axis.
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params contains three integer or
     *    floating-point values that specify the direction of the light in
     *    homogeneous object coordinates. Both integer and floating-point values
     *    are mapped directly. Neither integer
     *    nor floating-point values are clamped.   The spot direction is
     *    transformed by the upper 3x3 of the modelview
     *    matrix when {@see GL46::glLight} is called, and it is stored in eye
     *    coordinates. It is significant only when
     *    {@see GL46::GL_SPOT_CUTOFF} is not 180, which it is initially. The
     *    initial direction is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params is a single integer or
     *    floating-point value that specifies the intensity distribution of the
     *    light.
     *    Integer and floating-point values are mapped directly. Only values in
     *    the range    0 128   are accepted.
     *    Effective light intensity is attenuated by the cosine of the angle
     *    between the direction of the light and the
     *    direction from the light to the vertex being lighted, raised to the
     *    power of the spot exponent. Thus, higher
     *    spot exponents result in a more focused light source, regardless of
     *    the spot cutoff angle (see
     *    {@see GL46::GL_SPOT_CUTOFF}, next paragraph). The initial spot
     *    exponent is 0, resulting in uniform light
     *    distribution.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params is a single integer or
     *    floating-point value that specifies the maximum spread angle of a
     *    light
     *    source. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 90   and the
     *    special value 180 are accepted. If the angle between the direction of
     *    the light and the direction from the
     *    light to the vertex being lighted is greater than the spot cutoff
     *    angle, the light is completely masked.
     *    Otherwise, its intensity is controlled by the spot exponent and the
     *    attenuation factors. The initial spot
     *    cutoff is 180, resulting in uniform light distribution.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}:
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}:
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params is a single integer or
     *    floating-point value that specifies one of the three light attenuation
     *    factors. Integer and floating-point values are mapped directly. Only
     *    nonnegative values are accepted. If the
     *    light is positional, rather than directional, its intensity is
     *    attenuated by the reciprocal of the sum of the
     *    constant factor, the linear factor times the distance between the
     *    light and the vertex being lighted, and the
     *    quadratic factor times the square of the same distance. The initial
     *    attenuation factors are (1, 0, 0),
     *    resulting in no attenuation.
     *
     * @see http://docs.gl/gl2/glLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function lightf(int $light, int $pname, float $param): void
    {
        $this->info->ffi->glLightf($light, $pname, $param);
    }

    /**
     * {@see GL46::glLight} sets the values of individual light source parameters. $light names the light and is a
     * symbolic name of the form {@see GL46::GL_LIGHT} i, where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. $pname specifies one of ten light source parameters, again by symbolic name.
     * $params is either a single value or a pointer to an array that contains the new values.
     *
     * To enable and disable lighting calculation, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are
     * enabled contribute to the lighting calculation. Light source i is enabled and disabled using
     * {@see GL46::glEnable} and {@see GL46::glDisable} with argument {@see GL46::GL_LIGHT} i.
     *
     * The ten light parameters are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial ambient light intensity
     *    is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_POSITION}: $params contains four integer or
     *    floating-point values that specify the position of the light in
     *    homogeneous
     *    object coordinates. Both integer and floating-point values are mapped
     *    directly. Neither integer nor
     *    floating-point values are clamped.   The position is transformed by
     *    the modelview matrix when
     *    {@see GL46::glLight} is called (just as if it were a point), and it is
     *    stored in eye coordinates. If the w
     *    component of the position is 0, the light is treated as a directional
     *    source. Diffuse and specular lighting
     *    calculations take the light's direction, but not its actual position,
     *    into account, and attenuation is
     *    disabled. Otherwise, diffuse and specular lighting calculations are
     *    based on the actual location of the light
     *    in eye coordinates, and attenuation is enabled. The initial position
     *    is (0, 0, 1, 0); thus, the initial light
     *    source is directional, parallel to, and in the direction of the    - z
     *      axis.
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params contains three integer or
     *    floating-point values that specify the direction of the light in
     *    homogeneous object coordinates. Both integer and floating-point values
     *    are mapped directly. Neither integer
     *    nor floating-point values are clamped.   The spot direction is
     *    transformed by the upper 3x3 of the modelview
     *    matrix when {@see GL46::glLight} is called, and it is stored in eye
     *    coordinates. It is significant only when
     *    {@see GL46::GL_SPOT_CUTOFF} is not 180, which it is initially. The
     *    initial direction is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params is a single integer or
     *    floating-point value that specifies the intensity distribution of the
     *    light.
     *    Integer and floating-point values are mapped directly. Only values in
     *    the range    0 128   are accepted.
     *    Effective light intensity is attenuated by the cosine of the angle
     *    between the direction of the light and the
     *    direction from the light to the vertex being lighted, raised to the
     *    power of the spot exponent. Thus, higher
     *    spot exponents result in a more focused light source, regardless of
     *    the spot cutoff angle (see
     *    {@see GL46::GL_SPOT_CUTOFF}, next paragraph). The initial spot
     *    exponent is 0, resulting in uniform light
     *    distribution.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params is a single integer or
     *    floating-point value that specifies the maximum spread angle of a
     *    light
     *    source. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 90   and the
     *    special value 180 are accepted. If the angle between the direction of
     *    the light and the direction from the
     *    light to the vertex being lighted is greater than the spot cutoff
     *    angle, the light is completely masked.
     *    Otherwise, its intensity is controlled by the spot exponent and the
     *    attenuation factors. The initial spot
     *    cutoff is 180, resulting in uniform light distribution.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}:
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}:
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params is a single integer or
     *    floating-point value that specifies one of the three light attenuation
     *    factors. Integer and floating-point values are mapped directly. Only
     *    nonnegative values are accepted. If the
     *    light is positional, rather than directional, its intensity is
     *    attenuated by the reciprocal of the sum of the
     *    constant factor, the linear factor times the distance between the
     *    light and the vertex being lighted, and the
     *    quadratic factor times the square of the same distance. The initial
     *    attenuation factors are (1, 0, 0),
     *    resulting in no attenuation.
     *
     * @see http://docs.gl/gl2/glLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function lightfv(int $light, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glLightfv($light, $pname, $params);
    }

    /**
     * {@see GL46::glLight} sets the values of individual light source parameters. $light names the light and is a
     * symbolic name of the form {@see GL46::GL_LIGHT} i, where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. $pname specifies one of ten light source parameters, again by symbolic name.
     * $params is either a single value or a pointer to an array that contains the new values.
     *
     * To enable and disable lighting calculation, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are
     * enabled contribute to the lighting calculation. Light source i is enabled and disabled using
     * {@see GL46::glEnable} and {@see GL46::glDisable} with argument {@see GL46::GL_LIGHT} i.
     *
     * The ten light parameters are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial ambient light intensity
     *    is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_POSITION}: $params contains four integer or
     *    floating-point values that specify the position of the light in
     *    homogeneous
     *    object coordinates. Both integer and floating-point values are mapped
     *    directly. Neither integer nor
     *    floating-point values are clamped.   The position is transformed by
     *    the modelview matrix when
     *    {@see GL46::glLight} is called (just as if it were a point), and it is
     *    stored in eye coordinates. If the w
     *    component of the position is 0, the light is treated as a directional
     *    source. Diffuse and specular lighting
     *    calculations take the light's direction, but not its actual position,
     *    into account, and attenuation is
     *    disabled. Otherwise, diffuse and specular lighting calculations are
     *    based on the actual location of the light
     *    in eye coordinates, and attenuation is enabled. The initial position
     *    is (0, 0, 1, 0); thus, the initial light
     *    source is directional, parallel to, and in the direction of the    - z
     *      axis.
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params contains three integer or
     *    floating-point values that specify the direction of the light in
     *    homogeneous object coordinates. Both integer and floating-point values
     *    are mapped directly. Neither integer
     *    nor floating-point values are clamped.   The spot direction is
     *    transformed by the upper 3x3 of the modelview
     *    matrix when {@see GL46::glLight} is called, and it is stored in eye
     *    coordinates. It is significant only when
     *    {@see GL46::GL_SPOT_CUTOFF} is not 180, which it is initially. The
     *    initial direction is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params is a single integer or
     *    floating-point value that specifies the intensity distribution of the
     *    light.
     *    Integer and floating-point values are mapped directly. Only values in
     *    the range    0 128   are accepted.
     *    Effective light intensity is attenuated by the cosine of the angle
     *    between the direction of the light and the
     *    direction from the light to the vertex being lighted, raised to the
     *    power of the spot exponent. Thus, higher
     *    spot exponents result in a more focused light source, regardless of
     *    the spot cutoff angle (see
     *    {@see GL46::GL_SPOT_CUTOFF}, next paragraph). The initial spot
     *    exponent is 0, resulting in uniform light
     *    distribution.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params is a single integer or
     *    floating-point value that specifies the maximum spread angle of a
     *    light
     *    source. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 90   and the
     *    special value 180 are accepted. If the angle between the direction of
     *    the light and the direction from the
     *    light to the vertex being lighted is greater than the spot cutoff
     *    angle, the light is completely masked.
     *    Otherwise, its intensity is controlled by the spot exponent and the
     *    attenuation factors. The initial spot
     *    cutoff is 180, resulting in uniform light distribution.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}:
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}:
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params is a single integer or
     *    floating-point value that specifies one of the three light attenuation
     *    factors. Integer and floating-point values are mapped directly. Only
     *    nonnegative values are accepted. If the
     *    light is positional, rather than directional, its intensity is
     *    attenuated by the reciprocal of the sum of the
     *    constant factor, the linear factor times the distance between the
     *    light and the vertex being lighted, and the
     *    quadratic factor times the square of the same distance. The initial
     *    attenuation factors are (1, 0, 0),
     *    resulting in no attenuation.
     *
     * @see http://docs.gl/gl2/glLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function lighti(int $light, int $pname, int $param): void
    {
        $this->info->ffi->glLighti($light, $pname, $param);
    }

    /**
     * {@see GL46::glLight} sets the values of individual light source parameters. $light names the light and is a
     * symbolic name of the form {@see GL46::GL_LIGHT} i, where i ranges from 0 to the value of
     * {@see GL46::GL_MAX_LIGHTS} - 1. $pname specifies one of ten light source parameters, again by symbolic name.
     * $params is either a single value or a pointer to an array that contains the new values.
     *
     * To enable and disable lighting calculation, call {@see GL46::glEnable} and {@see GL46::glDisable} with
     * argument {@see GL46::GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are
     * enabled contribute to the lighting calculation. Light source i is enabled and disabled using
     * {@see GL46::glEnable} and {@see GL46::glDisable} with argument {@see GL46::GL_LIGHT} i.
     *
     * The ten light parameters are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial ambient light intensity
     *    is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA intensity of the
     *    light.
     *    Integer values are mapped linearly such that the most positive
     *    representable value maps to 1.0, and the most
     *    negative representable value maps to   -1.0 . Floating-point values
     *    are mapped directly. Neither integer nor
     *    floating-point values are clamped. The initial value for {@see
     *    GL46::GL_LIGHT0} is (1, 1, 1, 1); for other
     *    lights, the initial value is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_POSITION}: $params contains four integer or
     *    floating-point values that specify the position of the light in
     *    homogeneous
     *    object coordinates. Both integer and floating-point values are mapped
     *    directly. Neither integer nor
     *    floating-point values are clamped.   The position is transformed by
     *    the modelview matrix when
     *    {@see GL46::glLight} is called (just as if it were a point), and it is
     *    stored in eye coordinates. If the w
     *    component of the position is 0, the light is treated as a directional
     *    source. Diffuse and specular lighting
     *    calculations take the light's direction, but not its actual position,
     *    into account, and attenuation is
     *    disabled. Otherwise, diffuse and specular lighting calculations are
     *    based on the actual location of the light
     *    in eye coordinates, and attenuation is enabled. The initial position
     *    is (0, 0, 1, 0); thus, the initial light
     *    source is directional, parallel to, and in the direction of the    - z
     *      axis.
     *
     *  - {@see GL46::GL_SPOT_DIRECTION}: $params contains three integer or
     *    floating-point values that specify the direction of the light in
     *    homogeneous object coordinates. Both integer and floating-point values
     *    are mapped directly. Neither integer
     *    nor floating-point values are clamped.   The spot direction is
     *    transformed by the upper 3x3 of the modelview
     *    matrix when {@see GL46::glLight} is called, and it is stored in eye
     *    coordinates. It is significant only when
     *    {@see GL46::GL_SPOT_CUTOFF} is not 180, which it is initially. The
     *    initial direction is    0 0 -1  .
     *
     *  - {@see GL46::GL_SPOT_EXPONENT}: $params is a single integer or
     *    floating-point value that specifies the intensity distribution of the
     *    light.
     *    Integer and floating-point values are mapped directly. Only values in
     *    the range    0 128   are accepted.
     *    Effective light intensity is attenuated by the cosine of the angle
     *    between the direction of the light and the
     *    direction from the light to the vertex being lighted, raised to the
     *    power of the spot exponent. Thus, higher
     *    spot exponents result in a more focused light source, regardless of
     *    the spot cutoff angle (see
     *    {@see GL46::GL_SPOT_CUTOFF}, next paragraph). The initial spot
     *    exponent is 0, resulting in uniform light
     *    distribution.
     *
     *  - {@see GL46::GL_SPOT_CUTOFF}: $params is a single integer or
     *    floating-point value that specifies the maximum spread angle of a
     *    light
     *    source. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 90   and the
     *    special value 180 are accepted. If the angle between the direction of
     *    the light and the direction from the
     *    light to the vertex being lighted is greater than the spot cutoff
     *    angle, the light is completely masked.
     *    Otherwise, its intensity is controlled by the spot exponent and the
     *    attenuation factors. The initial spot
     *    cutoff is 180, resulting in uniform light distribution.
     *
     *  - {@see GL46::GL_CONSTANT_ATTENUATION}:
     *
     *  - {@see GL46::GL_LINEAR_ATTENUATION}:
     *
     *  - {@see GL46::GL_QUADRATIC_ATTENUATION}: $params is a single integer or
     *    floating-point value that specifies one of the three light attenuation
     *    factors. Integer and floating-point values are mapped directly. Only
     *    nonnegative values are accepted. If the
     *    light is positional, rather than directional, its intensity is
     *    attenuated by the reciprocal of the sum of the
     *    constant factor, the linear factor times the distance between the
     *    light and the vertex being lighted, and the
     *    quadratic factor times the square of the same distance. The initial
     *    attenuation factors are (1, 0, 0),
     *    resulting in no attenuation.
     *
     * @see http://docs.gl/gl2/glLight
     * @since 1.1
     * @param int $light
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function lightiv(int $light, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glLightiv($light, $pname, $params);
    }

    /**
     * Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The
     * masking is achieved by using three parameters: the 16-bit line stipple pattern $pattern, the repeat count
     * $factor, and an integer stipple counter s.
     *
     * Counter s is reset to 0 whenever {@see GL46::glBegin} is called and before each line segment of a
     * {@see GL46::glBegin}({@see GL46::GL_LINES})/{@see GL46::glEnd} sequence is generated. It is incremented after
     * each fragment of a unit width aliased line segment is generated or after each i fragments of an i width line
     * segment are generated. The i fragments associated with count s are masked out if
     *
     * $pattern bit      s factor   % 16
     *
     * is 0, otherwise these fragments are sent to the frame buffer. Bit zero of $pattern is the least significant
     * bit.
     *
     * Antialiased lines are treated as a sequence of    1 × width   rectangles for purposes of stippling. Whether
     * rectangle s is rasterized or not depends on the fragment rule described for aliased lines, counting rectangles
     * rather than groups of fragments.
     *
     * To enable and disable line stippling, call {@see GL46::glEnable} and {@see GL46::glDisable} with argument
     * {@see GL46::GL_LINE_STIPPLE}. When enabled, the line stipple pattern is applied as described above. When
     * disabled, it is as if the pattern were all 1's. Initially, line stippling is disabled.
     *
     * @see http://docs.gl/gl2/glLineStipple
     * @since 1.1
     * @param int $factor
     * @param int $pattern
     * @return void
     */
    public function lineStipple(int $factor, int $pattern): void
    {
        $this->info->ffi->glLineStipple($factor, $pattern);
    }

    /**
     * {@see GL46::glLineWidth} specifies the rasterized width of both aliased and antialiased lines. Using a line
     * width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and
     * disable line antialiasing, call {@see GL46::glEnable} and  {@see GL46::glDisable} with argument
     * {@see GL46::GL_LINE_SMOOTH}. Line antialiasing is initially disabled.
     *
     * If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest
     * integer. (If the rounding results in the value 0, it is as if the line width were 1.) If       Δ x   &gt;=
     * Δ y    , i pixels are filled in each column that is rasterized, where i is the rounded value of $width.
     * Otherwise, i pixels are filled in each row that is rasterized.
     *
     * If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the
     * region lying within the rectangle having width equal to the current line width, length equal to the actual
     * length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the
     * window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This
     * value is saved and used in the final rasterization step.
     *
     * Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the
     * nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the
     * implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported
     * widths and the size difference between supported widths within the range, call {@see GL46::glGet} with
     * arguments {@see GL46::GL_ALIASED_LINE_WIDTH_RANGE}, {@see GL46::GL_SMOOTH_LINE_WIDTH_RANGE}, and
     * {@see GL46::GL_SMOOTH_LINE_WIDTH_GRANULARITY}.
     *
     * @see http://docs.gl/gl2/glLineWidth
     * @see http://docs.gl/gl4/glLineWidth
     * @since 1.1
     * @param float $width
     * @return void
     */
    public function lineWidth(float $width): void
    {
        $this->info->ffi->glLineWidth($width);
    }

    /**
     * {@see GL46::glCallLists} specifies an array of offsets. Display-list names are generated by adding $base to
     * each offset. Names that reference valid display lists are executed; the others are ignored.
     *
     * @see http://docs.gl/gl2/glListBase
     * @since 1.1
     * @param int $base
     * @return void
     */
    public function listBase(int $base): void
    {
        $this->info->ffi->glListBase($base);
    }

    /**
     * {@see GL46::glLoadIdentity} replaces the current matrix with the identity matrix. It is semantically
     * equivalent to calling {@see GL46::glLoadMatrix} with the identity matrix
     *
     *        1   0   0   0     0   1   0   0     0   0   1   0     0   0   0   1
     *
     * but in some cases it is more efficient.
     *
     * @see http://docs.gl/gl2/glLoadIdentity
     * @since 1.1
     * @return void
     */
    public function loadIdentity(): void
    {
        $this->info->ffi->glLoadIdentity();
    }

    /**
     * {@see GL46::glLoadMatrix} replaces the current matrix with the one whose elements are specified by $m. The
     * current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix
     * mode (see {@see GL46::glMatrixMode}).
     *
     * The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview
     * matrix. If    v =   v &amp;af;  0    v &amp;af;  1    v &amp;af;  2    v &amp;af;  3      is the set of object
     * coordinates of a vertex, and $m points to an array of   16  single- or double-precision floating-point values
     *   m =   m &amp;af;  0    m &amp;af;  1   ...  m &amp;af;  15     , then the modelview transformation    M
     * &amp;af;  v    does the following:
     *
     *     M &amp;af;  v   =       m &amp;af;  0      m &amp;af;  4      m &amp;af;  8      m &amp;af;  12        m
     * &amp;af;  1      m &amp;af;  5      m &amp;af;  9      m &amp;af;  13        m &amp;af;  2      m &amp;af;  6
     *     m &amp;af;  10      m &amp;af;  14        m &amp;af;  3      m &amp;af;  7      m &amp;af;  11      m
     * &amp;af;  15       ×      v &amp;af;  0        v &amp;af;  1        v &amp;af;  2        v &amp;af;  3
     *
     * Projection and texture transformations are similarly defined.
     *
     * @see http://docs.gl/gl2/glLoadMatrix
     * @since 1.1
     * @param \FFI\CData|null $m
     * @return void
     */
    public function loadMatrixd(?\FFI\CData $m): void
    {
        $this->info->ffi->glLoadMatrixd($m);
    }

    /**
     * {@see GL46::glLoadMatrix} replaces the current matrix with the one whose elements are specified by $m. The
     * current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix
     * mode (see {@see GL46::glMatrixMode}).
     *
     * The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview
     * matrix. If    v =   v &amp;af;  0    v &amp;af;  1    v &amp;af;  2    v &amp;af;  3      is the set of object
     * coordinates of a vertex, and $m points to an array of   16  single- or double-precision floating-point values
     *   m =   m &amp;af;  0    m &amp;af;  1   ...  m &amp;af;  15     , then the modelview transformation    M
     * &amp;af;  v    does the following:
     *
     *     M &amp;af;  v   =       m &amp;af;  0      m &amp;af;  4      m &amp;af;  8      m &amp;af;  12        m
     * &amp;af;  1      m &amp;af;  5      m &amp;af;  9      m &amp;af;  13        m &amp;af;  2      m &amp;af;  6
     *     m &amp;af;  10      m &amp;af;  14        m &amp;af;  3      m &amp;af;  7      m &amp;af;  11      m
     * &amp;af;  15       ×      v &amp;af;  0        v &amp;af;  1        v &amp;af;  2        v &amp;af;  3
     *
     * Projection and texture transformations are similarly defined.
     *
     * @see http://docs.gl/gl2/glLoadMatrix
     * @since 1.1
     * @param \FFI\CData|null $m
     * @return void
     */
    public function loadMatrixf(?\FFI\CData $m): void
    {
        $this->info->ffi->glLoadMatrixf($m);
    }

    /**
     * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It
     * consists of an ordered set of unsigned integers and is initially empty.
     *
     * {@see GL46::glLoadName} causes $name to replace the value on the top of the name stack.
     *
     * The name stack is always empty while the render mode is not {@see GL46::GL_SELECT}. Calls to
     * {@see GL46::glLoadName} while the render mode is not {@see GL46::GL_SELECT} are ignored.
     *
     * @see http://docs.gl/gl2/glLoadName
     * @since 1.1
     * @param int $name
     * @return void
     */
    public function loadName(int $name): void
    {
        $this->info->ffi->glLoadName($name);
    }

    /**
     * {@see GL46::glLogicOp} specifies a logical operation that, when enabled, is applied between the incoming RGBA
     * color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical
     * operation, call {@see GL46::glEnable} and  {@see GL46::glDisable} using the symbolic constant
     * {@see GL46::GL_COLOR_LOGIC_OP}. The initial value is disabled.
     *
     * | {@see GL46::GL_CLEAR}         | 0            |
     * | {@see GL46::GL_SET}           | 1            |
     * | {@see GL46::GL_COPY}          | s            |
     * | {@see GL46::GL_COPY_INVERTED} | ~s           |
     * | {@see GL46::GL_NOOP}          | d            |
     * | {@see GL46::GL_INVERT}        | ~d           |
     * | {@see GL46::GL_AND}           | s &amp; d    |
     * | {@see GL46::GL_NAND}          | ~(s &amp; d) |
     * | {@see GL46::GL_OR}            | s | d        |
     * | {@see GL46::GL_NOR}           | ~(s | d)     |
     * | {@see GL46::GL_XOR}           | s ^ d        |
     * | {@see GL46::GL_EQUIV}         | ~(s ^ d)     |
     * | {@see GL46::GL_AND_REVERSE}   | s &amp; ~d   |
     * | {@see GL46::GL_AND_INVERTED}  | ~s &amp; d   |
     * | {@see GL46::GL_OR_REVERSE}    | s | ~d       |
     * | {@see GL46::GL_OR_INVERTED}   | ~s | d       |
     * $opcode is a symbolic constant chosen from the list above. In the explanation of the logical operations, s
     * represents the incoming color and d represents the color in the frame buffer. Standard C-language operators
     * are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair
     * of the source and destination colors.
     *
     * @see http://docs.gl/gl2/glLogicOp
     * @see http://docs.gl/gl4/glLogicOp
     * @since 1.1
     * @param int $opcode
     * @return void
     */
    public function logicOp(int $opcode): void
    {
        $this->info->ffi->glLogicOp($opcode);
    }

    /**
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals,
     * texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL
     * processing just as if they had been presented using {@see GL46::glVertex}, {@see GL46::glNormal},
     * {@see GL46::glTexCoord}, and {@see GL46::glColor} commands, except that the generated values do not update the
     * current normal, texture coordinates, or color.
     *
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL
     * implementation) can be described using evaluators. These include almost all splines used in computer graphics:
     * B-splines, Bezier curves, Hermite splines, and so on.
     *
     * Evaluators define curves based on Bernstein polynomials. Define    p &amp;af;  u&amp;Hat;    as
     *
     *     p &amp;af;  u&amp;Hat;   =   Σ  i = 0  n     B i   n  &amp;af;  u&amp;Hat;   &amp;it; R i
     *
     * where   R i   is a control point and     B i   n  &amp;af;  u&amp;Hat;    is the ith Bernstein polynomial of
     * degree n ($order =    n + 1  ):
     *
     *      B i   n  &amp;af;  u&amp;Hat;   =      n   i     &amp;it;  u&amp;Hat;  i  &amp;it;    1 - u&amp;Hat;
     * n - i
     *
     * Recall that
     *
     *    0 0  == 1   and        n   0     == 1
     *
     * {@see GL46::glMap1} is used to define the basis and to specify what kind of values are produced. Once defined,
     * a map can be enabled and disabled by calling {@see GL46::glEnable} and {@see GL46::glDisable} with the map
     * name, one of the nine predefined values for $target described below. {@see GL46::glEvalCoord1} evaluates the
     * one-dimensional maps that are enabled. When {@see GL46::glEvalCoord1} presents a value u, the Bernstein
     * functions are evaluated using   u&amp;Hat; , where    u&amp;Hat; =    u - u1     u2 - u1
     *
     * $target is a symbolic constant that indicates what kind of control points are provided in $points, and what
     * output is generated when the map is evaluated. It can assume one of nine predefined values:
     *
     *  - {@see GL46::GL_MAP1_VERTEX_3}: Each control point is three
     *    floating-point values representing x, y, and z. Internal {@see
     *    GL46::glVertex3}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP1_VERTEX_4}: Each control point is four
     *    floating-point values representing x, y, z, and w. Internal {@see
     *    GL46::glVertex4}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP1_INDEX}: Each control point is a single
     *    floating-point value representing a color index. Internal {@see
     *    GL46::glIndex}
     *    commands are generated when the map is evaluated but the current index
     *    is not updated with the value of these
     *    {@see GL46::glIndex} commands.
     *
     *  - {@see GL46::GL_MAP1_COLOR_4}: Each control point is four
     *    floating-point values representing red, green, blue, and alpha.
     *    Internal
     *    {@see GL46::glColor4} commands are generated when the map is evaluated
     *    but the current color is not updated
     *    with the value of these {@see GL46::glColor4} commands.
     *
     *  - {@see GL46::GL_MAP1_NORMAL}: Each control point is three
     *    floating-point values representing the x, y, and z components of a
     *    normal vector.
     *    Internal {@see GL46::glNormal} commands are generated when the map is
     *    evaluated but the current normal is not
     *    updated with the value of these {@see GL46::glNormal} commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_1}: Each control point is a single
     *    floating-point value representing the s texture coordinate. Internal
     *    {@see GL46::glTexCoord1} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_2}: Each control point is two
     *    floating-point values representing the s and t texture coordinates.
     *    Internal
     *    {@see GL46::glTexCoord2} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_3}: Each control point is three
     *    floating-point values representing the s, t, and r texture
     *    coordinates. Internal
     *    {@see GL46::glTexCoord3} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_4}: Each control point is four
     *    floating-point values representing the s, t, r, and q texture
     *    coordinates.
     *    Internal {@see GL46::glTexCoord4} commands are generated when the map
     *    is evaluated but the current texture
     *    coordinates are not updated with the value of these {@see
     *    GL46::glTexCoord} commands.
     *
     * $stride, $order, and $points define the array addressing for accessing the control points. $points is the
     * location of the first control point, which occupies one, two, three, or four contiguous memory locations,
     * depending on which map is being defined. $order is the number of control points in the array. $stride
     * specifies how many float or double locations to advance the internal memory pointer to reach the next control
     * point.
     *
     * @see http://docs.gl/gl2/glMap1
     * @since 1.1
     * @param int $target
     * @param float $u1
     * @param float $u2
     * @param int $stride
     * @param int $order
     * @param \FFI\CData|null $points
     * @return void
     */
    public function map1d(int $target, float $u1, float $u2, int $stride, int $order, ?\FFI\CData $points): void
    {
        $this->info->ffi->glMap1d($target, $u1, $u2, $stride, $order, $points);
    }

    /**
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals,
     * texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL
     * processing just as if they had been presented using {@see GL46::glVertex}, {@see GL46::glNormal},
     * {@see GL46::glTexCoord}, and {@see GL46::glColor} commands, except that the generated values do not update the
     * current normal, texture coordinates, or color.
     *
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL
     * implementation) can be described using evaluators. These include almost all splines used in computer graphics:
     * B-splines, Bezier curves, Hermite splines, and so on.
     *
     * Evaluators define curves based on Bernstein polynomials. Define    p &amp;af;  u&amp;Hat;    as
     *
     *     p &amp;af;  u&amp;Hat;   =   Σ  i = 0  n     B i   n  &amp;af;  u&amp;Hat;   &amp;it; R i
     *
     * where   R i   is a control point and     B i   n  &amp;af;  u&amp;Hat;    is the ith Bernstein polynomial of
     * degree n ($order =    n + 1  ):
     *
     *      B i   n  &amp;af;  u&amp;Hat;   =      n   i     &amp;it;  u&amp;Hat;  i  &amp;it;    1 - u&amp;Hat;
     * n - i
     *
     * Recall that
     *
     *    0 0  == 1   and        n   0     == 1
     *
     * {@see GL46::glMap1} is used to define the basis and to specify what kind of values are produced. Once defined,
     * a map can be enabled and disabled by calling {@see GL46::glEnable} and {@see GL46::glDisable} with the map
     * name, one of the nine predefined values for $target described below. {@see GL46::glEvalCoord1} evaluates the
     * one-dimensional maps that are enabled. When {@see GL46::glEvalCoord1} presents a value u, the Bernstein
     * functions are evaluated using   u&amp;Hat; , where    u&amp;Hat; =    u - u1     u2 - u1
     *
     * $target is a symbolic constant that indicates what kind of control points are provided in $points, and what
     * output is generated when the map is evaluated. It can assume one of nine predefined values:
     *
     *  - {@see GL46::GL_MAP1_VERTEX_3}: Each control point is three
     *    floating-point values representing x, y, and z. Internal {@see
     *    GL46::glVertex3}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP1_VERTEX_4}: Each control point is four
     *    floating-point values representing x, y, z, and w. Internal {@see
     *    GL46::glVertex4}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP1_INDEX}: Each control point is a single
     *    floating-point value representing a color index. Internal {@see
     *    GL46::glIndex}
     *    commands are generated when the map is evaluated but the current index
     *    is not updated with the value of these
     *    {@see GL46::glIndex} commands.
     *
     *  - {@see GL46::GL_MAP1_COLOR_4}: Each control point is four
     *    floating-point values representing red, green, blue, and alpha.
     *    Internal
     *    {@see GL46::glColor4} commands are generated when the map is evaluated
     *    but the current color is not updated
     *    with the value of these {@see GL46::glColor4} commands.
     *
     *  - {@see GL46::GL_MAP1_NORMAL}: Each control point is three
     *    floating-point values representing the x, y, and z components of a
     *    normal vector.
     *    Internal {@see GL46::glNormal} commands are generated when the map is
     *    evaluated but the current normal is not
     *    updated with the value of these {@see GL46::glNormal} commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_1}: Each control point is a single
     *    floating-point value representing the s texture coordinate. Internal
     *    {@see GL46::glTexCoord1} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_2}: Each control point is two
     *    floating-point values representing the s and t texture coordinates.
     *    Internal
     *    {@see GL46::glTexCoord2} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_3}: Each control point is three
     *    floating-point values representing the s, t, and r texture
     *    coordinates. Internal
     *    {@see GL46::glTexCoord3} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP1_TEXTURE_COORD_4}: Each control point is four
     *    floating-point values representing the s, t, r, and q texture
     *    coordinates.
     *    Internal {@see GL46::glTexCoord4} commands are generated when the map
     *    is evaluated but the current texture
     *    coordinates are not updated with the value of these {@see
     *    GL46::glTexCoord} commands.
     *
     * $stride, $order, and $points define the array addressing for accessing the control points. $points is the
     * location of the first control point, which occupies one, two, three, or four contiguous memory locations,
     * depending on which map is being defined. $order is the number of control points in the array. $stride
     * specifies how many float or double locations to advance the internal memory pointer to reach the next control
     * point.
     *
     * @see http://docs.gl/gl2/glMap1
     * @since 1.1
     * @param int $target
     * @param float $u1
     * @param float $u2
     * @param int $stride
     * @param int $order
     * @param \FFI\CData|null $points
     * @return void
     */
    public function map1f(int $target, float $u1, float $u2, int $stride, int $order, ?\FFI\CData $points): void
    {
        $this->info->ffi->glMap1f($target, $u1, $u2, $stride, $order, $points);
    }

    /**
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals,
     * texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL
     * processing just as if they had been presented using {@see GL46::glVertex}, {@see GL46::glNormal},
     * {@see GL46::glTexCoord}, and {@see GL46::glColor} commands, except that the generated values do not update the
     * current normal, texture coordinates, or color.
     *
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL
     * implementation) can be described using evaluators. These include almost all surfaces used in computer
     * graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
     *
     * Evaluators define surfaces based on bivariate Bernstein polynomials. Define    p &amp;af;  u&amp;Hat;
     * v&amp;Hat;    as
     *
     *     p &amp;af;  u&amp;Hat; v&amp;Hat;   =   Σ  i = 0  n    Σ  j = 0  m     B i   n  &amp;af;  u&amp;Hat;
     * &amp;it;   B j   m  &amp;af;  v&amp;Hat;   &amp;it; R ij
     *
     * where   R ij   is a control point,     B i   n  &amp;af;  u&amp;Hat;    is the ith Bernstein polynomial of
     * degree n ($uorder =    n + 1  )
     *
     *      B i   n  &amp;af;  u&amp;Hat;   =      n   i     &amp;it;  u&amp;Hat;  i  &amp;it;    1 - u&amp;Hat;
     * n - i
     *
     * and     B j   m  &amp;af;  v&amp;Hat;    is the jth Bernstein polynomial of degree m ($vorder =    m + 1  )
     *
     *      B j   m  &amp;af;  v&amp;Hat;   =      m   j     &amp;it;  v&amp;Hat;  j  &amp;it;    1 - v&amp;Hat;
     * m - j
     *
     * Recall that    0 0  == 1   and        n   0     == 1
     *
     * {@see GL46::glMap2} is used to define the basis and to specify what kind of values are produced. Once defined,
     * a map can be enabled and disabled by calling {@see GL46::glEnable} and {@see GL46::glDisable} with the map
     * name, one of the nine predefined values for $target, described below. When {@see GL46::glEvalCoord2} presents
     * values u and v, the bivariate Bernstein polynomials are evaluated using   u&amp;Hat;  and   v&amp;Hat; , where
     *
     *    u&amp;Hat; =    u - u1     u2 - u1
     *
     *    v&amp;Hat; =    v - v1     v2 - v1
     *
     * $target is a symbolic constant that indicates what kind of control points are provided in $points, and what
     * output is generated when the map is evaluated. It can assume one of nine predefined values:
     *
     *  - {@see GL46::GL_MAP2_VERTEX_3}: Each control point is three
     *    floating-point values representing x, y, and z. Internal {@see
     *    GL46::glVertex3}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP2_VERTEX_4}: Each control point is four
     *    floating-point values representing x, y, z, and w. Internal {@see
     *    GL46::glVertex4}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP2_INDEX}: Each control point is a single
     *    floating-point value representing a color index. Internal {@see
     *    GL46::glIndex}
     *    commands are generated when the map is evaluated but the current index
     *    is not updated with the value of these
     *    {@see GL46::glIndex} commands.
     *
     *  - {@see GL46::GL_MAP2_COLOR_4}: Each control point is four
     *    floating-point values representing red, green, blue, and alpha.
     *    Internal
     *    {@see GL46::glColor4} commands are generated when the map is evaluated
     *    but the current color is not updated
     *    with the value of these {@see GL46::glColor4} commands.
     *
     *  - {@see GL46::GL_MAP2_NORMAL}: Each control point is three
     *    floating-point values representing the x, y, and z components of a
     *    normal vector.
     *    Internal {@see GL46::glNormal} commands are generated when the map is
     *    evaluated but the current normal is not
     *    updated with the value of these {@see GL46::glNormal} commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_1}: Each control point is a single
     *    floating-point value representing the s texture coordinate. Internal
     *    {@see GL46::glTexCoord1} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_2}: Each control point is two
     *    floating-point values representing the s and t texture coordinates.
     *    Internal
     *    {@see GL46::glTexCoord2} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_3}: Each control point is three
     *    floating-point values representing the s, t, and r texture
     *    coordinates. Internal
     *    {@see GL46::glTexCoord3} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_4}: Each control point is four
     *    floating-point values representing the s, t, r, and q texture
     *    coordinates.
     *    Internal {@see GL46::glTexCoord4} commands are generated when the map
     *    is evaluated but the current texture
     *    coordinates are not updated with the value of these {@see
     *    GL46::glTexCoord} commands.
     *
     * $ustride, $uorder, $vstride, $vorder, and $points define the array addressing for accessing the control
     * points. $points is the location of the first control point, which occupies one, two, three, or four contiguous
     * memory locations, depending on which map is being defined. There are    uorder × vorder   control points in
     * the array. $ustride specifies how many float or double locations are skipped to advance the internal memory
     * pointer from control point   R   i &amp;it; j     to control point   R     i + 1   &amp;it; j    . $vstride
     * specifies how many float or double locations are skipped to advance the internal memory pointer from control
     * point   R   i &amp;it; j     to control point   R   i &amp;af;   j + 1      .
     *
     * @see http://docs.gl/gl2/glMap2
     * @since 1.1
     * @param int $target
     * @param float $u1
     * @param float $u2
     * @param int $ustride
     * @param int $uorder
     * @param float $v1
     * @param float $v2
     * @param int $vstride
     * @param int $vorder
     * @param \FFI\CData|null $points
     * @return void
     */
    public function map2d(
        int $target,
        float $u1,
        float $u2,
        int $ustride,
        int $uorder,
        float $v1,
        float $v2,
        int $vstride,
        int $vorder,
        ?\FFI\CData $points
    ): void {
        $this->info->ffi->glMap2d($target, $u1, $u2, $ustride, $uorder, $v1, $v2, $vstride, $vorder, $points);
    }

    /**
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals,
     * texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL
     * processing just as if they had been presented using {@see GL46::glVertex}, {@see GL46::glNormal},
     * {@see GL46::glTexCoord}, and {@see GL46::glColor} commands, except that the generated values do not update the
     * current normal, texture coordinates, or color.
     *
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL
     * implementation) can be described using evaluators. These include almost all surfaces used in computer
     * graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
     *
     * Evaluators define surfaces based on bivariate Bernstein polynomials. Define    p &amp;af;  u&amp;Hat;
     * v&amp;Hat;    as
     *
     *     p &amp;af;  u&amp;Hat; v&amp;Hat;   =   Σ  i = 0  n    Σ  j = 0  m     B i   n  &amp;af;  u&amp;Hat;
     * &amp;it;   B j   m  &amp;af;  v&amp;Hat;   &amp;it; R ij
     *
     * where   R ij   is a control point,     B i   n  &amp;af;  u&amp;Hat;    is the ith Bernstein polynomial of
     * degree n ($uorder =    n + 1  )
     *
     *      B i   n  &amp;af;  u&amp;Hat;   =      n   i     &amp;it;  u&amp;Hat;  i  &amp;it;    1 - u&amp;Hat;
     * n - i
     *
     * and     B j   m  &amp;af;  v&amp;Hat;    is the jth Bernstein polynomial of degree m ($vorder =    m + 1  )
     *
     *      B j   m  &amp;af;  v&amp;Hat;   =      m   j     &amp;it;  v&amp;Hat;  j  &amp;it;    1 - v&amp;Hat;
     * m - j
     *
     * Recall that    0 0  == 1   and        n   0     == 1
     *
     * {@see GL46::glMap2} is used to define the basis and to specify what kind of values are produced. Once defined,
     * a map can be enabled and disabled by calling {@see GL46::glEnable} and {@see GL46::glDisable} with the map
     * name, one of the nine predefined values for $target, described below. When {@see GL46::glEvalCoord2} presents
     * values u and v, the bivariate Bernstein polynomials are evaluated using   u&amp;Hat;  and   v&amp;Hat; , where
     *
     *    u&amp;Hat; =    u - u1     u2 - u1
     *
     *    v&amp;Hat; =    v - v1     v2 - v1
     *
     * $target is a symbolic constant that indicates what kind of control points are provided in $points, and what
     * output is generated when the map is evaluated. It can assume one of nine predefined values:
     *
     *  - {@see GL46::GL_MAP2_VERTEX_3}: Each control point is three
     *    floating-point values representing x, y, and z. Internal {@see
     *    GL46::glVertex3}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP2_VERTEX_4}: Each control point is four
     *    floating-point values representing x, y, z, and w. Internal {@see
     *    GL46::glVertex4}
     *    commands are generated when the map is evaluated.
     *
     *  - {@see GL46::GL_MAP2_INDEX}: Each control point is a single
     *    floating-point value representing a color index. Internal {@see
     *    GL46::glIndex}
     *    commands are generated when the map is evaluated but the current index
     *    is not updated with the value of these
     *    {@see GL46::glIndex} commands.
     *
     *  - {@see GL46::GL_MAP2_COLOR_4}: Each control point is four
     *    floating-point values representing red, green, blue, and alpha.
     *    Internal
     *    {@see GL46::glColor4} commands are generated when the map is evaluated
     *    but the current color is not updated
     *    with the value of these {@see GL46::glColor4} commands.
     *
     *  - {@see GL46::GL_MAP2_NORMAL}: Each control point is three
     *    floating-point values representing the x, y, and z components of a
     *    normal vector.
     *    Internal {@see GL46::glNormal} commands are generated when the map is
     *    evaluated but the current normal is not
     *    updated with the value of these {@see GL46::glNormal} commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_1}: Each control point is a single
     *    floating-point value representing the s texture coordinate. Internal
     *    {@see GL46::glTexCoord1} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_2}: Each control point is two
     *    floating-point values representing the s and t texture coordinates.
     *    Internal
     *    {@see GL46::glTexCoord2} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_3}: Each control point is three
     *    floating-point values representing the s, t, and r texture
     *    coordinates. Internal
     *    {@see GL46::glTexCoord3} commands are generated when the map is
     *    evaluated but the current texture coordinates
     *    are not updated with the value of these {@see GL46::glTexCoord}
     *    commands.
     *
     *  - {@see GL46::GL_MAP2_TEXTURE_COORD_4}: Each control point is four
     *    floating-point values representing the s, t, r, and q texture
     *    coordinates.
     *    Internal {@see GL46::glTexCoord4} commands are generated when the map
     *    is evaluated but the current texture
     *    coordinates are not updated with the value of these {@see
     *    GL46::glTexCoord} commands.
     *
     * $ustride, $uorder, $vstride, $vorder, and $points define the array addressing for accessing the control
     * points. $points is the location of the first control point, which occupies one, two, three, or four contiguous
     * memory locations, depending on which map is being defined. There are    uorder × vorder   control points in
     * the array. $ustride specifies how many float or double locations are skipped to advance the internal memory
     * pointer from control point   R   i &amp;it; j     to control point   R     i + 1   &amp;it; j    . $vstride
     * specifies how many float or double locations are skipped to advance the internal memory pointer from control
     * point   R   i &amp;it; j     to control point   R   i &amp;af;   j + 1      .
     *
     * @see http://docs.gl/gl2/glMap2
     * @since 1.1
     * @param int $target
     * @param float $u1
     * @param float $u2
     * @param int $ustride
     * @param int $uorder
     * @param float $v1
     * @param float $v2
     * @param int $vstride
     * @param int $vorder
     * @param \FFI\CData|null $points
     * @return void
     */
    public function map2f(
        int $target,
        float $u1,
        float $u2,
        int $ustride,
        int $uorder,
        float $v1,
        float $v2,
        int $vstride,
        int $vorder,
        ?\FFI\CData $points
    ): void {
        $this->info->ffi->glMap2f($target, $u1, $u2, $ustride, $uorder, $v1, $v2, $vstride, $vorder, $points);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used together to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}.
     *
     * {@see GL46::glMapGrid1} and {@see GL46::glMapGrid2} specify the linear grid mappings between the i (or i and
     * j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See
     * {@see GL46::glMap1} and {@see GL46::glMap2} for details of how u and v coordinates are evaluated.
     *
     * {@see GL46::glMapGrid1} specifies a single linear mapping such that integer grid coordinate 0 maps exactly to
     * $u1, and integer grid coordinate $un maps exactly to $u2. All other integer grid coordinates i are mapped so
     * that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     * {@see GL46::glMapGrid2} specifies two such linear mappings. One maps integer grid coordinate    i = 0
     * exactly to $u1, and integer grid coordinate    i = un   exactly to $u2. The other maps integer grid coordinate
     *    j = 0   exactly to $v1, and integer grid coordinate    j = vn   exactly to $v2. Other integer grid
     * coordinates i and j are mapped such that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     *    v =    j &amp;af;   v2 - v1    vn  + v1
     *
     * The mappings specified by {@see GL46::glMapGrid} are used identically by {@see GL46::glEvalMesh} and
     * {@see GL46::glEvalPoint}.
     *
     * @see http://docs.gl/gl2/glMapGrid
     * @since 1.1
     * @param int $un
     * @param float $u1
     * @param float $u2
     * @return void
     */
    public function mapGrid1d(int $un, float $u1, float $u2): void
    {
        $this->info->ffi->glMapGrid1d($un, $u1, $u2);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used together to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}.
     *
     * {@see GL46::glMapGrid1} and {@see GL46::glMapGrid2} specify the linear grid mappings between the i (or i and
     * j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See
     * {@see GL46::glMap1} and {@see GL46::glMap2} for details of how u and v coordinates are evaluated.
     *
     * {@see GL46::glMapGrid1} specifies a single linear mapping such that integer grid coordinate 0 maps exactly to
     * $u1, and integer grid coordinate $un maps exactly to $u2. All other integer grid coordinates i are mapped so
     * that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     * {@see GL46::glMapGrid2} specifies two such linear mappings. One maps integer grid coordinate    i = 0
     * exactly to $u1, and integer grid coordinate    i = un   exactly to $u2. The other maps integer grid coordinate
     *    j = 0   exactly to $v1, and integer grid coordinate    j = vn   exactly to $v2. Other integer grid
     * coordinates i and j are mapped such that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     *    v =    j &amp;af;   v2 - v1    vn  + v1
     *
     * The mappings specified by {@see GL46::glMapGrid} are used identically by {@see GL46::glEvalMesh} and
     * {@see GL46::glEvalPoint}.
     *
     * @see http://docs.gl/gl2/glMapGrid
     * @since 1.1
     * @param int $un
     * @param float $u1
     * @param float $u2
     * @return void
     */
    public function mapGrid1f(int $un, float $u1, float $u2): void
    {
        $this->info->ffi->glMapGrid1f($un, $u1, $u2);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used together to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}.
     *
     * {@see GL46::glMapGrid1} and {@see GL46::glMapGrid2} specify the linear grid mappings between the i (or i and
     * j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See
     * {@see GL46::glMap1} and {@see GL46::glMap2} for details of how u and v coordinates are evaluated.
     *
     * {@see GL46::glMapGrid1} specifies a single linear mapping such that integer grid coordinate 0 maps exactly to
     * $u1, and integer grid coordinate $un maps exactly to $u2. All other integer grid coordinates i are mapped so
     * that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     * {@see GL46::glMapGrid2} specifies two such linear mappings. One maps integer grid coordinate    i = 0
     * exactly to $u1, and integer grid coordinate    i = un   exactly to $u2. The other maps integer grid coordinate
     *    j = 0   exactly to $v1, and integer grid coordinate    j = vn   exactly to $v2. Other integer grid
     * coordinates i and j are mapped such that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     *    v =    j &amp;af;   v2 - v1    vn  + v1
     *
     * The mappings specified by {@see GL46::glMapGrid} are used identically by {@see GL46::glEvalMesh} and
     * {@see GL46::glEvalPoint}.
     *
     * @see http://docs.gl/gl2/glMapGrid
     * @since 1.1
     * @param int $un
     * @param float $u1
     * @param float $u2
     * @param int $vn
     * @param float $v1
     * @param float $v2
     * @return void
     */
    public function mapGrid2d(int $un, float $u1, float $u2, int $vn, float $v1, float $v2): void
    {
        $this->info->ffi->glMapGrid2d($un, $u1, $u2, $vn, $v1, $v2);
    }

    /**
     * {@see GL46::glMapGrid} and {@see GL46::glEvalMesh} are used together to efficiently generate and evaluate a
     * series of evenly-spaced map domain values. {@see GL46::glEvalMesh} steps through the integer domain of a one-
     * or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@see GL46::glMap1} and
     * {@see GL46::glMap2}.
     *
     * {@see GL46::glMapGrid1} and {@see GL46::glMapGrid2} specify the linear grid mappings between the i (or i and
     * j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See
     * {@see GL46::glMap1} and {@see GL46::glMap2} for details of how u and v coordinates are evaluated.
     *
     * {@see GL46::glMapGrid1} specifies a single linear mapping such that integer grid coordinate 0 maps exactly to
     * $u1, and integer grid coordinate $un maps exactly to $u2. All other integer grid coordinates i are mapped so
     * that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     * {@see GL46::glMapGrid2} specifies two such linear mappings. One maps integer grid coordinate    i = 0
     * exactly to $u1, and integer grid coordinate    i = un   exactly to $u2. The other maps integer grid coordinate
     *    j = 0   exactly to $v1, and integer grid coordinate    j = vn   exactly to $v2. Other integer grid
     * coordinates i and j are mapped such that
     *
     *    u =    i &amp;af;   u2 - u1    un  + u1
     *
     *    v =    j &amp;af;   v2 - v1    vn  + v1
     *
     * The mappings specified by {@see GL46::glMapGrid} are used identically by {@see GL46::glEvalMesh} and
     * {@see GL46::glEvalPoint}.
     *
     * @see http://docs.gl/gl2/glMapGrid
     * @since 1.1
     * @param int $un
     * @param float $u1
     * @param float $u2
     * @param int $vn
     * @param float $v1
     * @param float $v2
     * @return void
     */
    public function mapGrid2f(int $un, float $u1, float $u2, int $vn, float $v1, float $v2): void
    {
        $this->info->ffi->glMapGrid2f($un, $u1, $u2, $vn, $v1, $v2);
    }

    /**
     * {@see GL46::glMaterial} assigns values to material parameters. There are two matched sets of material
     * parameters. One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when
     * two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
     * set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the
     * {@see GL46::glLightModel} reference page for details concerning one- and two-sided lighting calculations.
     *
     * {@see GL46::glMaterial} takes three arguments. The first, $face, specifies whether the {@see GL46::GL_FRONT}
     * materials, the {@see GL46::GL_BACK} materials, or both {@see GL46::GL_FRONT_AND_BACK} materials will be
     * modified. The second, $pname, specifies which of several parameters in one or both sets will be modified. The
     * third, $params, specifies what value or values will be assigned to the specified parameter.
     *
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation
     * is discussed in the {@see GL46::glLightModel} reference page. The parameters that can be specified using
     * {@see GL46::glMaterial}, and their interpretations by the lighting equation, are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    reflectance for both front- and back-facing
     *    materials is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial diffuse
     *    reflectance for both front- and back-facing
     *    materials is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA reflectance of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial specular
     *    reflectance for both front- and
     *    back-facing materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params contains four integer or
     *    floating-point values that specify the RGBA emitted light intensity of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial emission
     *    intensity for both front- and back-facing
     *    materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params is a single integer or
     *    floating-point value that specifies the RGBA specular exponent of the
     *    material. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 128   are
     *    accepted. The initial specular exponent for both front- and
     *    back-facing materials is 0.
     *
     *  - {@see GL46::GL_AMBIENT_AND_DIFFUSE}: Equivalent to calling {@see
     *    GL46::glMaterial} twice with the same parameter values, once with
     *    {@see GL46::GL_AMBIENT} and once with {@see GL46::GL_DIFFUSE}.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params contains three integer or
     *    floating-point values specifying the color indices for ambient,
     *    diffuse,
     *    and specular lighting. These three values, and {@see
     *    GL46::GL_SHININESS}, are the only material values used by
     *    the color index mode lighting equation. Refer to the {@see
     *    GL46::glLightModel} reference page for a discussion
     *    of color index lighting.
     *
     * @see http://docs.gl/gl2/glMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function materialf(int $face, int $pname, float $param): void
    {
        $this->info->ffi->glMaterialf($face, $pname, $param);
    }

    /**
     * {@see GL46::glMaterial} assigns values to material parameters. There are two matched sets of material
     * parameters. One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when
     * two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
     * set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the
     * {@see GL46::glLightModel} reference page for details concerning one- and two-sided lighting calculations.
     *
     * {@see GL46::glMaterial} takes three arguments. The first, $face, specifies whether the {@see GL46::GL_FRONT}
     * materials, the {@see GL46::GL_BACK} materials, or both {@see GL46::GL_FRONT_AND_BACK} materials will be
     * modified. The second, $pname, specifies which of several parameters in one or both sets will be modified. The
     * third, $params, specifies what value or values will be assigned to the specified parameter.
     *
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation
     * is discussed in the {@see GL46::glLightModel} reference page. The parameters that can be specified using
     * {@see GL46::glMaterial}, and their interpretations by the lighting equation, are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    reflectance for both front- and back-facing
     *    materials is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial diffuse
     *    reflectance for both front- and back-facing
     *    materials is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA reflectance of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial specular
     *    reflectance for both front- and
     *    back-facing materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params contains four integer or
     *    floating-point values that specify the RGBA emitted light intensity of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial emission
     *    intensity for both front- and back-facing
     *    materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params is a single integer or
     *    floating-point value that specifies the RGBA specular exponent of the
     *    material. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 128   are
     *    accepted. The initial specular exponent for both front- and
     *    back-facing materials is 0.
     *
     *  - {@see GL46::GL_AMBIENT_AND_DIFFUSE}: Equivalent to calling {@see
     *    GL46::glMaterial} twice with the same parameter values, once with
     *    {@see GL46::GL_AMBIENT} and once with {@see GL46::GL_DIFFUSE}.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params contains three integer or
     *    floating-point values specifying the color indices for ambient,
     *    diffuse,
     *    and specular lighting. These three values, and {@see
     *    GL46::GL_SHININESS}, are the only material values used by
     *    the color index mode lighting equation. Refer to the {@see
     *    GL46::glLightModel} reference page for a discussion
     *    of color index lighting.
     *
     * @see http://docs.gl/gl2/glMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function materialfv(int $face, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glMaterialfv($face, $pname, $params);
    }

    /**
     * {@see GL46::glMaterial} assigns values to material parameters. There are two matched sets of material
     * parameters. One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when
     * two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
     * set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the
     * {@see GL46::glLightModel} reference page for details concerning one- and two-sided lighting calculations.
     *
     * {@see GL46::glMaterial} takes three arguments. The first, $face, specifies whether the {@see GL46::GL_FRONT}
     * materials, the {@see GL46::GL_BACK} materials, or both {@see GL46::GL_FRONT_AND_BACK} materials will be
     * modified. The second, $pname, specifies which of several parameters in one or both sets will be modified. The
     * third, $params, specifies what value or values will be assigned to the specified parameter.
     *
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation
     * is discussed in the {@see GL46::glLightModel} reference page. The parameters that can be specified using
     * {@see GL46::glMaterial}, and their interpretations by the lighting equation, are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    reflectance for both front- and back-facing
     *    materials is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial diffuse
     *    reflectance for both front- and back-facing
     *    materials is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA reflectance of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial specular
     *    reflectance for both front- and
     *    back-facing materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params contains four integer or
     *    floating-point values that specify the RGBA emitted light intensity of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial emission
     *    intensity for both front- and back-facing
     *    materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params is a single integer or
     *    floating-point value that specifies the RGBA specular exponent of the
     *    material. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 128   are
     *    accepted. The initial specular exponent for both front- and
     *    back-facing materials is 0.
     *
     *  - {@see GL46::GL_AMBIENT_AND_DIFFUSE}: Equivalent to calling {@see
     *    GL46::glMaterial} twice with the same parameter values, once with
     *    {@see GL46::GL_AMBIENT} and once with {@see GL46::GL_DIFFUSE}.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params contains three integer or
     *    floating-point values specifying the color indices for ambient,
     *    diffuse,
     *    and specular lighting. These three values, and {@see
     *    GL46::GL_SHININESS}, are the only material values used by
     *    the color index mode lighting equation. Refer to the {@see
     *    GL46::glLightModel} reference page for a discussion
     *    of color index lighting.
     *
     * @see http://docs.gl/gl2/glMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function materiali(int $face, int $pname, int $param): void
    {
        $this->info->ffi->glMateriali($face, $pname, $param);
    }

    /**
     * {@see GL46::glMaterial} assigns values to material parameters. There are two matched sets of material
     * parameters. One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when
     * two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
     * set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the
     * {@see GL46::glLightModel} reference page for details concerning one- and two-sided lighting calculations.
     *
     * {@see GL46::glMaterial} takes three arguments. The first, $face, specifies whether the {@see GL46::GL_FRONT}
     * materials, the {@see GL46::GL_BACK} materials, or both {@see GL46::GL_FRONT_AND_BACK} materials will be
     * modified. The second, $pname, specifies which of several parameters in one or both sets will be modified. The
     * third, $params, specifies what value or values will be assigned to the specified parameter.
     *
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation
     * is discussed in the {@see GL46::glLightModel} reference page. The parameters that can be specified using
     * {@see GL46::glMaterial}, and their interpretations by the lighting equation, are as follows:
     *
     *  - {@see GL46::GL_AMBIENT}: $params contains four integer or
     *    floating-point values that specify the ambient RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial ambient
     *    reflectance for both front- and back-facing
     *    materials is (0.2, 0.2, 0.2, 1.0).
     *
     *  - {@see GL46::GL_DIFFUSE}: $params contains four integer or
     *    floating-point values that specify the diffuse RGBA reflectance of the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial diffuse
     *    reflectance for both front- and back-facing
     *    materials is (0.8, 0.8, 0.8, 1.0).
     *
     *  - {@see GL46::GL_SPECULAR}: $params contains four integer or
     *    floating-point values that specify the specular RGBA reflectance of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial specular
     *    reflectance for both front- and
     *    back-facing materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_EMISSION}: $params contains four integer or
     *    floating-point values that specify the RGBA emitted light intensity of
     *    the
     *    material. Integer values are mapped linearly such that the most
     *    positive representable value maps to 1.0, and
     *    the most negative representable value maps to   -1.0 . Floating-point
     *    values are mapped directly. Neither
     *    integer nor floating-point values are clamped. The initial emission
     *    intensity for both front- and back-facing
     *    materials is (0, 0, 0, 1).
     *
     *  - {@see GL46::GL_SHININESS}: $params is a single integer or
     *    floating-point value that specifies the RGBA specular exponent of the
     *    material. Integer and floating-point values are mapped directly. Only
     *    values in the range    0 128   are
     *    accepted. The initial specular exponent for both front- and
     *    back-facing materials is 0.
     *
     *  - {@see GL46::GL_AMBIENT_AND_DIFFUSE}: Equivalent to calling {@see
     *    GL46::glMaterial} twice with the same parameter values, once with
     *    {@see GL46::GL_AMBIENT} and once with {@see GL46::GL_DIFFUSE}.
     *
     *  - {@see GL46::GL_COLOR_INDEXES}: $params contains three integer or
     *    floating-point values specifying the color indices for ambient,
     *    diffuse,
     *    and specular lighting. These three values, and {@see
     *    GL46::GL_SHININESS}, are the only material values used by
     *    the color index mode lighting equation. Refer to the {@see
     *    GL46::glLightModel} reference page for a discussion
     *    of color index lighting.
     *
     * @see http://docs.gl/gl2/glMaterial
     * @since 1.1
     * @param int $face
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function materialiv(int $face, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glMaterialiv($face, $pname, $params);
    }

    /**
     * {@see GL46::glMatrixMode} sets the current matrix mode. $mode can assume one of four values:
     *
     *  - {@see GL46::GL_MODELVIEW}: Applies subsequent matrix operations to the
     *    modelview matrix stack.
     *
     *  - {@see GL46::GL_PROJECTION}: Applies subsequent matrix operations to
     *    the projection matrix stack.
     *
     *  - {@see GL46::GL_TEXTURE}: Applies subsequent matrix operations to the
     *    texture matrix stack.
     *
     *  - {@see GL46::GL_COLOR}: Applies subsequent matrix operations to the
     *    color matrix stack.
     *
     * To find out which matrix stack is currently the target of all matrix operations, call {@see GL46::glGet} with
     * argument {@see GL46::GL_MATRIX_MODE}. The initial value is {@see GL46::GL_MODELVIEW}.
     *
     * @see http://docs.gl/gl2/glMatrixMode
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function matrixMode(int $mode): void
    {
        $this->info->ffi->glMatrixMode($mode);
    }

    /**
     * {@see GL46::glMultMatrix} multiplies the current matrix with the one specified using $m, and replaces the
     * current matrix with the product.
     *
     * The current matrix is determined by the current matrix mode (see {@see GL46::glMatrixMode}). It is either the
     * projection matrix, modelview matrix, or the texture matrix.
     *
     * @see http://docs.gl/gl2/glMultMatrix
     * @since 1.1
     * @param \FFI\CData|null $m
     * @return void
     */
    public function multMatrixd(?\FFI\CData $m): void
    {
        $this->info->ffi->glMultMatrixd($m);
    }

    /**
     * {@see GL46::glMultMatrix} multiplies the current matrix with the one specified using $m, and replaces the
     * current matrix with the product.
     *
     * The current matrix is determined by the current matrix mode (see {@see GL46::glMatrixMode}). It is either the
     * projection matrix, modelview matrix, or the texture matrix.
     *
     * @see http://docs.gl/gl2/glMultMatrix
     * @since 1.1
     * @param \FFI\CData|null $m
     * @return void
     */
    public function multMatrixf(?\FFI\CData $m): void
    {
        $this->info->ffi->glMultMatrixf($m);
    }

    /**
     * Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are
     * created with {@see GL46::glNewList}. All subsequent commands are placed in the display list, in the order
     * issued, until {@see GL46::glEndList} is called.
     *
     * {@see GL46::glNewList} has two arguments. The first argument, $list, is a positive integer that becomes the
     * unique name for the display list. Names can be created and reserved with {@see GL46::glGenLists} and tested
     * for uniqueness with {@see GL46::glIsList}. The second argument, $mode, is a symbolic constant that can assume
     * one of two values:
     *
     *  - {@see GL46::GL_COMPILE}: Commands are merely compiled.
     *
     *  - {@see GL46::GL_COMPILE_AND_EXECUTE}: Commands are executed as they are
     *    compiled into the display list.
     *
     * Certain commands are not compiled into the display list but are executed immediately, regardless of the
     * display-list mode. These commands are {@see GL46::glAreTexturesResident}, {@see GL46::glColorPointer},
     * {@see GL46::glDeleteLists}, {@see GL46::glDeleteTextures}, {@see GL46::glDisableClientState},
     * {@see GL46::glEdgeFlagPointer}, {@see GL46::glEnableClientState}, {@see GL46::glFeedbackBuffer},
     * {@see GL46::glFinish}, {@see GL46::glFlush}, {@see GL46::glGenLists}, {@see GL46::glGenTextures},
     * {@see GL46::glIndexPointer}, {@see GL46::glInterleavedArrays}, {@see GL46::glIsEnabled},
     * {@see GL46::glIsList}, {@see GL46::glIsTexture}, {@see GL46::glNormalPointer}, {@see GL46::glPopClientAttrib},
     * {@see GL46::glPixelStore}, {@see GL46::glPushClientAttrib}, {@see GL46::glReadPixels},
     * {@see GL46::glRenderMode}, {@see GL46::glSelectBuffer}, {@see GL46::glTexCoordPointer},
     * {@see GL46::glVertexPointer}, and all of the {@see GL46::glGet} commands.
     *
     * Similarly, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, and {@see GL46::glTexImage3D} are executed
     * immediately and not compiled into the display list when their first argument is
     * {@see GL46::GL_PROXY_TEXTURE_1D}, {@see GL46::GL_PROXY_TEXTURE_1D}, or {@see GL46::GL_PROXY_TEXTURE_3D},
     * respectively.
     *
     * When the `ARB_imaging` extension is supported, {@see GL46::glHistogram} executes immediately when its argument
     * is {@see GL46::GL_PROXY_HISTOGRAM}. Similarly, {@see GL46::glColorTable} executes immediately when its first
     * argument is {@see GL46::GL_PROXY_COLOR_TABLE}, {@see GL46::GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or
     * {@see GL46::GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.
     *
     * For OpenGL versions 1.3 and greater, or when the `ARB_multitexture` extension is supported,
     * {@see GL46::glClientActiveTexture} is not compiled into display lists, but executed immediately.
     *
     * When {@see GL46::glEndList} is encountered, the display-list definition is completed by associating the list
     * with the unique name $list (specified in the {@see GL46::glNewList} command). If a display list with name
     * $list already exists, it is replaced only when {@see GL46::glEndList} is called.
     *
     * @see http://docs.gl/gl2/glNewList
     * @since 1.1
     * @param int $list
     * @param int $mode
     * @return void
     */
    public function newList(int $list, int $mode): void
    {
        $this->info->ffi->glNewList($list, $mode);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param int $nx
     * @param int $ny
     * @param int $nz
     * @return void
     */
    public function normal3b(int $nx, int $ny, int $nz): void
    {
        $this->info->ffi->glNormal3b($nx, $ny, $nz);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function normal3bv(?\FFI\CData $v): void
    {
        $this->info->ffi->glNormal3bv($v);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param float $nx
     * @param float $ny
     * @param float $nz
     * @return void
     */
    public function normal3d(float $nx, float $ny, float $nz): void
    {
        $this->info->ffi->glNormal3d($nx, $ny, $nz);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function normal3dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glNormal3dv($v);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param float $nx
     * @param float $ny
     * @param float $nz
     * @return void
     */
    public function normal3f(float $nx, float $ny, float $nz): void
    {
        $this->info->ffi->glNormal3f($nx, $ny, $nz);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function normal3fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glNormal3fv($v);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param int $nx
     * @param int $ny
     * @param int $nz
     * @return void
     */
    public function normal3i(int $nx, int $ny, int $nz): void
    {
        $this->info->ffi->glNormal3i($nx, $ny, $nz);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function normal3iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glNormal3iv($v);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param int $nx
     * @param int $ny
     * @param int $nz
     * @return void
     */
    public function normal3s(int $nx, int $ny, int $nz): void
    {
        $this->info->ffi->glNormal3s($nx, $ny, $nz);
    }

    /**
     * The current normal is set to the given coordinates whenever {@see GL46::glNormal} is issued. Byte, short, or
     * integer arguments are converted to floating-point format with a linear mapping that maps the most positive
     * representable integer value to 1.0 and the most negative representable integer value to   -1.0 .
     *
     * Normals specified with {@see GL46::glNormal} need not have unit length. If {@see GL46::GL_NORMALIZE} is
     * enabled, then normals of any length specified with {@see GL46::glNormal} are normalized after transformation.
     * If {@see GL46::GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the
     * modelview matrix. {@see GL46::GL_RESCALE_NORMAL} requires that the originally specified normals were of unit
     * length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable
     * normalization, call {@see GL46::glEnable} and {@see GL46::glDisable} with either {@see GL46::GL_NORMALIZE} or
     * {@see GL46::GL_RESCALE_NORMAL}. Normalization is initially disabled.
     *
     * @see http://docs.gl/gl2/glNormal
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function normal3sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glNormal3sv($v);
    }

    /**
     * {@see GL46::glNormalPointer} specifies the location and data format of an array of normals to use when
     * rendering. $type specifies the data type of each normal coordinate, and $stride specifies the byte stride from
     * one normal to the next, allowing vertices and attributes to be packed into a single array or stored in
     * separate arrays. (Single-array storage may be more efficient on some implementations; see
     * {@see GL46::glInterleavedArrays}.)
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a normal array is specified, $pointer is treated as a byte offset into the
     * buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is saved as
     * normal vertex array client-side state ({@see GL46::GL_NORMAL_ARRAY_BUFFER_BINDING}).
     *
     * When a normal array is specified, $type, $stride, and $pointer are saved as client-side state, in addition to
     * the current vertex array buffer object binding.
     *
     * To enable and disable the normal array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_NORMAL_ARRAY}. If enabled, the normal array
     * is used when {@see GL46::glDrawArrays}, {@see GL46::glMultiDrawArrays}, {@see GL46::glDrawElements},
     * {@see GL46::glMultiDrawElements}, {@see GL46::glDrawRangeElements}, or {@see GL46::glArrayElement} is called.
     *
     * @see http://docs.gl/gl2/glNormalPointer
     * @since 1.1
     * @param int $type
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function normalPointer(int $type, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glNormalPointer($type, $stride, $pointer);
    }

    /**
     * {@see GL46::glOrtho} describes a transformation that produces a parallel projection. The current matrix (see
     * {@see GL46::glMatrixMode}) is multiplied by this matrix and the result replaces the current matrix, as if
     * {@see GL46::glMultMatrix} were called with the following matrix as its argument:
     *
     *         2   right - left       0   0    t x       0     2   top - bottom       0    t y       0   0     -2
     * farVal - nearVal        t z       0   0   0   1
     *
     * where    t x  =  -     right + left     right - left           t y  =  -     top + bottom     top - bottom
     *       t z  =  -     farVal + nearVal     farVal - nearVal
     *
     * Typically, the matrix mode is {@see GL46::GL_PROJECTION}, and    left bottom  - nearVal    and    right top  -
     * nearVal    specify the points on the near clipping plane that are mapped to the lower left and upper right
     * corners of the window, respectively, assuming that the eye is located at (0, 0, 0).    - farVal   specifies
     * the location of the far clipping plane. Both $nearVal and $farVal can be either positive or negative.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the current matrix stack.
     *
     * @see http://docs.gl/gl2/glOrtho
     * @since 1.1
     * @param float $left
     * @param float $right
     * @param float $bottom
     * @param float $top
     * @param float $zNear
     * @param float $zFar
     * @return void
     */
    public function ortho(float $left, float $right, float $bottom, float $top, float $zNear, float $zFar): void
    {
        $this->info->ffi->glOrtho($left, $right, $bottom, $top, $zNear, $zFar);
    }

    /**
     * Feedback is a GL render mode. The mode is selected by calling {@see GL46::glRenderMode} with
     * {@see GL46::GL_FEEDBACK}. When the GL is in feedback mode, no pixels are produced by rasterization. Instead,
     * information about primitives that would have been rasterized is fed back to the application using the GL. See
     * the {@see GL46::glFeedbackBuffer} reference page for a description of the feedback buffer and the values in
     * it.
     *
     * {@see GL46::glPassThrough} inserts a user-defined marker in the feedback buffer when it is executed in
     * feedback mode. $token is returned as if it were a primitive; it is indicated with its own unique identifying
     * value: {@see GL46::GL_PASS_THROUGH_TOKEN}. The order of {@see GL46::glPassThrough} commands with respect to
     * the specification of graphics primitives is maintained.
     *
     * @see http://docs.gl/gl2/glPassThrough
     * @since 1.1
     * @param float $token
     * @return void
     */
    public function passThrough(float $token): void
    {
        $this->info->ffi->glPassThrough($token);
    }

    /**
     * {@see GL46::glPixelMap} sets up translation tables, or maps, used by {@see GL46::glCopyPixels},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D}, {@see GL46::glDrawPixels},
     * {@see GL46::glReadPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and {@see GL46::glTexSubImage3D}. Additionally, if
     * the `ARB_imaging` subset is supported, the routines {@see GL46::glColorTable}, {@see GL46::glColorSubTable},
     * {@see GL46::glConvolutionFilter1D}, {@see GL46::glConvolutionFilter2D}, {@see GL46::glHistogram},
     * {@see GL46::glMinmax}, and {@see GL46::glSeparableFilter2D}. Use of these maps is described completely in the
     * {@see GL46::glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image
     * commands. Only the specification of the maps is described in this reference page.
     *
     * $map is a symbolic map name, indicating one of ten maps to set. $mapsize specifies the number of entries in
     * the map, and $values is a pointer to an array of $mapsize map values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel transfer map is specified, $values is treated as a byte offset into
     * the buffer object's data store.
     *
     * The ten maps are as follows:
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_I}: Maps color indices to color indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_S_TO_S}: Maps stencil indices to stencil
     *    indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_R}: Maps color indices to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_G}: Maps color indices to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_B}: Maps color indices to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_A}: Maps color indices to alpha
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_R_TO_R}: Maps red components to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_G_TO_G}: Maps green components to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_B_TO_B}: Maps blue components to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_A_TO_A}: Maps alpha components to alpha
     *    components.
     *
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or
     * unsigned int integers. Maps that store color component values (all but {@see GL46::GL_PIXEL_MAP_I_TO_I} and
     * {@see GL46::GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and
     * exponent sizes. Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the
     * internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values
     * specified by {@see GL46::glPixelMapusv} and {@see GL46::glPixelMapuiv} are converted linearly such that the
     * largest representable integer maps to 1.0, and 0 maps to 0.0.
     *
     * Maps that store indices, {@see GL46::GL_PIXEL_MAP_I_TO_I} and {@see GL46::GL_PIXEL_MAP_S_TO_S}, retain their
     * values in fixed-point format, with an unspecified number of bits to the right of the binary point.
     * Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the internal
     * fixed-point format of these maps. Unsigned integer values specified by {@see GL46::glPixelMapusv} and
     * {@see GL46::glPixelMapuiv} specify integer values, with all 0's to the right of the binary point.
     *
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either
     * color or stencil indices must have $mapsize =   2 n   for some n or the results are undefined. The maximum
     * allowable size for each map depends on the implementation and can be determined by calling {@see GL46::glGet}
     * with argument {@see GL46::GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
     *
     * | {@see GL46::GL_PIXEL_MAP_I_TO_I} | color index   | color index   | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_S_TO_S} | stencil index | stencil index | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_R} | color index   | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_G} | color index   | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_B} | color index   | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_A} | color index   | A             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_R_TO_R} | R             | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_G_TO_G} | G             | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_B_TO_B} | B             | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_A_TO_A} | A             | A             | 1 | 0 |
     * @see http://docs.gl/gl2/glPixelMap
     * @since 1.1
     * @param int $map
     * @param int $mapsize
     * @param \FFI\CData|null $values
     * @return void
     */
    public function pixelMapfv(int $map, int $mapsize, ?\FFI\CData $values): void
    {
        $this->info->ffi->glPixelMapfv($map, $mapsize, $values);
    }

    /**
     * {@see GL46::glPixelMap} sets up translation tables, or maps, used by {@see GL46::glCopyPixels},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D}, {@see GL46::glDrawPixels},
     * {@see GL46::glReadPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and {@see GL46::glTexSubImage3D}. Additionally, if
     * the `ARB_imaging` subset is supported, the routines {@see GL46::glColorTable}, {@see GL46::glColorSubTable},
     * {@see GL46::glConvolutionFilter1D}, {@see GL46::glConvolutionFilter2D}, {@see GL46::glHistogram},
     * {@see GL46::glMinmax}, and {@see GL46::glSeparableFilter2D}. Use of these maps is described completely in the
     * {@see GL46::glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image
     * commands. Only the specification of the maps is described in this reference page.
     *
     * $map is a symbolic map name, indicating one of ten maps to set. $mapsize specifies the number of entries in
     * the map, and $values is a pointer to an array of $mapsize map values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel transfer map is specified, $values is treated as a byte offset into
     * the buffer object's data store.
     *
     * The ten maps are as follows:
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_I}: Maps color indices to color indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_S_TO_S}: Maps stencil indices to stencil
     *    indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_R}: Maps color indices to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_G}: Maps color indices to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_B}: Maps color indices to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_A}: Maps color indices to alpha
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_R_TO_R}: Maps red components to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_G_TO_G}: Maps green components to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_B_TO_B}: Maps blue components to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_A_TO_A}: Maps alpha components to alpha
     *    components.
     *
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or
     * unsigned int integers. Maps that store color component values (all but {@see GL46::GL_PIXEL_MAP_I_TO_I} and
     * {@see GL46::GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and
     * exponent sizes. Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the
     * internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values
     * specified by {@see GL46::glPixelMapusv} and {@see GL46::glPixelMapuiv} are converted linearly such that the
     * largest representable integer maps to 1.0, and 0 maps to 0.0.
     *
     * Maps that store indices, {@see GL46::GL_PIXEL_MAP_I_TO_I} and {@see GL46::GL_PIXEL_MAP_S_TO_S}, retain their
     * values in fixed-point format, with an unspecified number of bits to the right of the binary point.
     * Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the internal
     * fixed-point format of these maps. Unsigned integer values specified by {@see GL46::glPixelMapusv} and
     * {@see GL46::glPixelMapuiv} specify integer values, with all 0's to the right of the binary point.
     *
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either
     * color or stencil indices must have $mapsize =   2 n   for some n or the results are undefined. The maximum
     * allowable size for each map depends on the implementation and can be determined by calling {@see GL46::glGet}
     * with argument {@see GL46::GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
     *
     * | {@see GL46::GL_PIXEL_MAP_I_TO_I} | color index   | color index   | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_S_TO_S} | stencil index | stencil index | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_R} | color index   | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_G} | color index   | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_B} | color index   | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_A} | color index   | A             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_R_TO_R} | R             | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_G_TO_G} | G             | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_B_TO_B} | B             | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_A_TO_A} | A             | A             | 1 | 0 |
     * @see http://docs.gl/gl2/glPixelMap
     * @since 1.1
     * @param int $map
     * @param int $mapsize
     * @param \FFI\CData|null $values
     * @return void
     */
    public function pixelMapuiv(int $map, int $mapsize, ?\FFI\CData $values): void
    {
        $this->info->ffi->glPixelMapuiv($map, $mapsize, $values);
    }

    /**
     * {@see GL46::glPixelMap} sets up translation tables, or maps, used by {@see GL46::glCopyPixels},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D}, {@see GL46::glDrawPixels},
     * {@see GL46::glReadPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and {@see GL46::glTexSubImage3D}. Additionally, if
     * the `ARB_imaging` subset is supported, the routines {@see GL46::glColorTable}, {@see GL46::glColorSubTable},
     * {@see GL46::glConvolutionFilter1D}, {@see GL46::glConvolutionFilter2D}, {@see GL46::glHistogram},
     * {@see GL46::glMinmax}, and {@see GL46::glSeparableFilter2D}. Use of these maps is described completely in the
     * {@see GL46::glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image
     * commands. Only the specification of the maps is described in this reference page.
     *
     * $map is a symbolic map name, indicating one of ten maps to set. $mapsize specifies the number of entries in
     * the map, and $values is a pointer to an array of $mapsize map values.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a pixel transfer map is specified, $values is treated as a byte offset into
     * the buffer object's data store.
     *
     * The ten maps are as follows:
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_I}: Maps color indices to color indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_S_TO_S}: Maps stencil indices to stencil
     *    indices.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_R}: Maps color indices to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_G}: Maps color indices to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_B}: Maps color indices to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_I_TO_A}: Maps color indices to alpha
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_R_TO_R}: Maps red components to red
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_G_TO_G}: Maps green components to green
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_B_TO_B}: Maps blue components to blue
     *    components.
     *
     *  - {@see GL46::GL_PIXEL_MAP_A_TO_A}: Maps alpha components to alpha
     *    components.
     *
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or
     * unsigned int integers. Maps that store color component values (all but {@see GL46::GL_PIXEL_MAP_I_TO_I} and
     * {@see GL46::GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and
     * exponent sizes. Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the
     * internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values
     * specified by {@see GL46::glPixelMapusv} and {@see GL46::glPixelMapuiv} are converted linearly such that the
     * largest representable integer maps to 1.0, and 0 maps to 0.0.
     *
     * Maps that store indices, {@see GL46::GL_PIXEL_MAP_I_TO_I} and {@see GL46::GL_PIXEL_MAP_S_TO_S}, retain their
     * values in fixed-point format, with an unspecified number of bits to the right of the binary point.
     * Floating-point values specified by {@see GL46::glPixelMapfv} are converted directly to the internal
     * fixed-point format of these maps. Unsigned integer values specified by {@see GL46::glPixelMapusv} and
     * {@see GL46::glPixelMapuiv} specify integer values, with all 0's to the right of the binary point.
     *
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either
     * color or stencil indices must have $mapsize =   2 n   for some n or the results are undefined. The maximum
     * allowable size for each map depends on the implementation and can be determined by calling {@see GL46::glGet}
     * with argument {@see GL46::GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
     *
     * | {@see GL46::GL_PIXEL_MAP_I_TO_I} | color index   | color index   | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_S_TO_S} | stencil index | stencil index | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_R} | color index   | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_G} | color index   | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_B} | color index   | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_I_TO_A} | color index   | A             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_R_TO_R} | R             | R             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_G_TO_G} | G             | G             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_B_TO_B} | B             | B             | 1 | 0 |
     * | {@see GL46::GL_PIXEL_MAP_A_TO_A} | A             | A             | 1 | 0 |
     * @see http://docs.gl/gl2/glPixelMap
     * @since 1.1
     * @param int $map
     * @param int $mapsize
     * @param \FFI\CData|null $values
     * @return void
     */
    public function pixelMapusv(int $map, int $mapsize, ?\FFI\CData $values): void
    {
        $this->info->ffi->glPixelMapusv($map, $mapsize, $values);
    }

    /**
     * {@see GL46::glPixelStore} sets pixel storage modes that affect the operation of subsequent
     * {@see GL46::glReadPixels} as well as the unpacking of texture patterns (see {@see GL46::glTexImage1D},
     * {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D},
     * {@see GL46::glTexSubImage2D}, {@see GL46::glTexSubImage3D}), {@see GL46::glCompressedTexImage1D},
     * {@see GL46::glCompressedTexImage2D}, {@see GL46::glCompressedTexImage3D},
     * {@see GL46::glCompressedTexSubImage1D}, {@see GL46::glCompressedTexSubImage2D} or
     * {@see GL46::glCompressedTexSubImage1D}.
     *
     * $pname is a symbolic constant indicating the parameter to be set, and $param is the new value. Six of the
     * twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
     *
     *  - {@see GL46::GL_PACK_SWAP_BYTES}: If true, byte ordering for multibyte
     *    color components, depth components, or stencil indices is reversed.
     *    That
     *    is, if a four-byte component consists of bytes   b 0  ,   b 1  ,   b 2
     *     ,   b 3  , it is stored in memory as
     *    b 3  ,   b 2  ,   b 1  ,   b 0   if {@see GL46::GL_PACK_SWAP_BYTES} is
     *    true. {@see GL46::GL_PACK_SWAP_BYTES}
     *    has no effect on the memory order of components within a pixel, only
     *    on the order of bytes within components
     *    or indices. For example, the three components of a {@see GL46::GL_RGB}
     *    format pixel are always stored with red
     *    first, green second, and blue third, regardless of the value of {@see
     *    GL46::GL_PACK_SWAP_BYTES}.
     *
     *  - {@see GL46::GL_PACK_LSB_FIRST}: If true, bits are ordered within a
     *    byte from least significant to most significant; otherwise, the first
     *    bit
     *    in each byte is the most significant one.
     *
     *  - {@see GL46::GL_PACK_ROW_LENGTH}: If greater than 0, {@see
     *    GL46::GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If
     *    the first pixel
     *    of a row is placed at location p in memory, then the location of the
     *    first pixel of the next row is obtained
     *    by skipping      k =      n &amp;it; l       a s   &amp;it;     s
     *    &amp;it; n &amp;it; l   a      &amp;it;    s
     *    &gt;= a     s &lt; a          components or indices, where n is the
     *    number of components or indices in a
     *    pixel, l is the number of pixels in a row ({@see
     *    GL46::GL_PACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to the pixel routine otherwise), a is the value of {@see
     *    GL46::GL_PACK_ALIGNMENT}, and s is the size,
     *    in bytes, of a single component (if    a &lt; s  , then it is as if
     *    a = s  ). In the case of 1-bit values,
     *    the location of the next row is obtained by skipping      k =  8
     *    &amp;it; a &amp;it;     n &amp;it; l     8
     *    &amp;it; a          components or indices.   The word component in
     *    this description refers to the nonindex
     *    values red, green, blue, alpha, and depth. Storage format {@see
     *    GL46::GL_RGB}, for example, has three
     *    components per pixel: first red, then green, and finally blue.
     *
     *  - {@see GL46::GL_PACK_IMAGE_HEIGHT}: If greater than 0, {@see
     *    GL46::GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image
     *    three-dimensional texture volume, where ``image'' is defined by all
     *    pixels sharing the same third dimension
     *    index. If the first pixel of a row is placed at location p in memory,
     *    then the location of the first pixel of
     *    the next row is obtained by skipping      k =      n &amp;it; l
     *    &amp;it; h       a s   &amp;it;     s &amp;it;
     *    n &amp;it; l &amp;it; h   a      &amp;it;    s &gt;= a     s &lt; a
     *          components or indices, where n is
     *    the number of components or indices in a pixel, l is the number of
     *    pixels in a row
     *    ({@see GL46::GL_PACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to {@see GL46::glTexImage3D}
     *    otherwise), h is the number of rows in a pixel image ({@see
     *    GL46::GL_PACK_IMAGE_HEIGHT} if it is greater than
     *    0, the height argument to the {@see GL46::glTexImage3D} routine
     *    otherwise), a is the value of
     *    {@see GL46::GL_PACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then it
     *    is as if    a = s  ).   The word component in this description refers
     *    to the nonindex values red, green, blue,
     *    alpha, and depth. Storage format {@see GL46::GL_RGB}, for example, has
     *    three components per pixel: first red,
     *    then green, and finally blue.
     *
     *  - {@see GL46::GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, and
     *    GL_PACK_SKIP_IMAGES}: These values are provided as a convenience to
     *    the programmer; they provide no functionality that cannot be
     *    duplicated simply by incrementing the pointer passed to {@see
     *    GL46::glReadPixels}. Setting
     *    {@see GL46::GL_PACK_SKIP_PIXELS} to i is equivalent to incrementing
     *    the pointer by    i &amp;it; n
     *    components or indices, where n is the number of components or indices
     *    in each pixel. Setting
     *    {@see GL46::GL_PACK_SKIP_ROWS} to j is equivalent to incrementing the
     *    pointer by    j &amp;it; m   components
     *    or indices, where m is the number of components or indices per row, as
     *    just computed in the
     *    {@see GL46::GL_PACK_ROW_LENGTH} section. Setting {@see
     *    GL46::GL_PACK_SKIP_IMAGES} to k is equivalent to
     *    incrementing the pointer by    k &amp;it; p  , where p is the number
     *    of components or indices per image, as
     *    computed in the {@see GL46::GL_PACK_IMAGE_HEIGHT} section.
     *
     *  - {@see GL46::GL_PACK_ALIGNMENT}: Specifies the alignment requirements
     *    for the start of each pixel row in memory. The allowable values are 1
     *    (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
     *    (word-alignment), and 8 (rows start on
     *    double-word boundaries).
     *
     * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values
     * are significant for {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and {@see GL46::glTexSubImage3D}
     *
     * They are as follows:
     *
     *  - {@see GL46::GL_UNPACK_SWAP_BYTES}: If true, byte ordering for
     *    multibyte color components, depth components, or stencil indices is
     *    reversed. That
     *    is, if a four-byte component consists of bytes   b 0  ,   b 1  ,   b 2
     *     ,   b 3  , it is taken from memory as
     *     b 3  ,   b 2  ,   b 1  ,   b 0   if {@see GL46::GL_UNPACK_SWAP_BYTES}
     *    is true.
     *    {@see GL46::GL_UNPACK_SWAP_BYTES} has no effect on the memory order of
     *    components within a pixel, only on the
     *    order of bytes within components or indices. For example, the three
     *    components of a {@see GL46::GL_RGB} format
     *    pixel are always stored with red first, green second, and blue third,
     *    regardless of the value of
     *    {@see GL46::GL_UNPACK_SWAP_BYTES}.
     *
     *  - {@see GL46::GL_UNPACK_LSB_FIRST}: If true, bits are ordered within a
     *    byte from least significant to most significant; otherwise, the first
     *    bit
     *    in each byte is the most significant one.
     *
     *  - {@see GL46::GL_UNPACK_ROW_LENGTH}: If greater than 0, {@see
     *    GL46::GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If
     *    the first
     *    pixel of a row is placed at location p in memory, then the location of
     *    the first pixel of the next row is
     *    obtained by skipping      k =      n &amp;it; l       a s   &amp;it;
     *      s &amp;it; n &amp;it; l   a
     *    &amp;it;    s &gt;= a     s &lt; a          components or indices,
     *    where n is the number of components or
     *    indices in a pixel, l is the number of pixels in a row ({@see
     *    GL46::GL_UNPACK_ROW_LENGTH} if it is greater
     *    than 0, the width argument to the pixel routine otherwise), a is the
     *    value of
     *    {@see GL46::GL_UNPACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then
     *    it is as if    a = s  ). In the case of 1-bit values, the location of
     *    the next row is obtained by skipping
     *     k =  8 &amp;it; a &amp;it;     n &amp;it; l     8 &amp;it; a
     *    components or indices.   The word
     *    component in this description refers to the nonindex values red,
     *    green, blue, alpha, and depth. Storage format
     *    {@see GL46::GL_RGB}, for example, has three components per pixel:
     *    first red, then green, and finally blue.
     *
     *  - {@see GL46::GL_UNPACK_IMAGE_HEIGHT}: If greater than 0, {@see
     *    GL46::GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image
     *    of a
     *    three-dimensional texture volume. Where ``image'' is defined by all
     *    pixel sharing the same third dimension
     *    index. If the first pixel of a row is placed at location p in memory,
     *    then the location of the first pixel of
     *    the next row is obtained by skipping      k =      n &amp;it; l
     *    &amp;it; h       a s   &amp;it;     s &amp;it;
     *    n &amp;it; l &amp;it; h   a      &amp;it;    s &gt;= a     s &lt; a
     *          components or indices, where n is
     *    the number of components or indices in a pixel, l is the number of
     *    pixels in a row
     *    ({@see GL46::GL_UNPACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to {@see GL46::glTexImage3D}
     *    otherwise), h is the number of rows in an image ({@see
     *    GL46::GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0,
     *    the height argument to {@see GL46::glTexImage3D} otherwise), a is the
     *    value of
     *    {@see GL46::GL_UNPACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then
     *    it is as if    a = s  ).   The word component in this description
     *    refers to the nonindex values red, green,
     *    blue, alpha, and depth. Storage format {@see GL46::GL_RGB}, for
     *    example, has three components per pixel: first
     *    red, then green, and finally blue.
     *
     *  - {@see GL46::GL_UNPACK_SKIP_PIXELS and GL_UNPACK_SKIP_ROWS}: These
     *    values are provided as a convenience to the programmer; they provide
     *    no functionality that cannot be
     *    duplicated by incrementing the pointer passed to {@see
     *    GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     *    {@see GL46::glTexSubImage1D} or {@see GL46::glTexSubImage2D}. Setting
     *    {@see GL46::GL_UNPACK_SKIP_PIXELS} to i
     *    is equivalent to incrementing the pointer by    i &amp;it; n
     *    components or indices, where n is the number of
     *    components or indices in each pixel. Setting {@see
     *    GL46::GL_UNPACK_SKIP_ROWS} to j is equivalent to
     *    incrementing the pointer by    j &amp;it; k   components or indices,
     *    where k is the number of components or
     *    indices per row, as just computed in the {@see
     *    GL46::GL_UNPACK_ROW_LENGTH} section.
     *
     *  - {@see GL46::GL_UNPACK_ALIGNMENT}: Specifies the alignment requirements
     *    for the start of each pixel row in memory. The allowable values are 1
     *    (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
     *    (word-alignment), and 8 (rows start on
     *    double-word boundaries).
     *
     * The following table gives the type, initial value, and range of valid values for each storage parameter that
     * can be set with {@see GL46::glPixelStore}.
     *
     * | {@see GL46::GL_PACK_SWAP_BYTES}     | boolean | false | true or false |
     * | {@see GL46::GL_PACK_LSB_FIRST}      | boolean | false | true or false |
     * | {@see GL46::GL_PACK_ROW_LENGTH}     | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_IMAGE_HEIGHT}   | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_ROWS}      | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_PIXELS}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_IMAGES}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_ALIGNMENT}      | integer | 4     | 1, 2, 4, or 8 |
     * | {@see GL46::GL_UNPACK_SWAP_BYTES}   | boolean | false | true or false |
     * | {@see GL46::GL_UNPACK_LSB_FIRST}    | boolean | false | true or false |
     * | {@see GL46::GL_UNPACK_ROW_LENGTH}   | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_IMAGE_HEIGHT} | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_ROWS}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_PIXELS}  | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_IMAGES}  | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_ALIGNMENT}    | integer | 4     | 1, 2, 4, or 8 |
     * {@see GL46::glPixelStoref} can be used to set any pixel store parameter. If the parameter type is boolean,
     * then if $param is 0, the parameter is false; otherwise it is set to true. If $pname is an integer type
     * parameter, $param is rounded to the nearest integer.
     *
     * Likewise, {@see GL46::glPixelStorei} can also be used to set any of the pixel store parameters. Boolean
     * parameters are set to false if $param is 0 and true otherwise.
     *
     * @see http://docs.gl/gl2/glPixelStore
     * @see http://docs.gl/gl4/glPixelStore
     * @since 1.1
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function pixelStoref(int $pname, float $param): void
    {
        $this->info->ffi->glPixelStoref($pname, $param);
    }

    /**
     * {@see GL46::glPixelStore} sets pixel storage modes that affect the operation of subsequent
     * {@see GL46::glReadPixels} as well as the unpacking of texture patterns (see {@see GL46::glTexImage1D},
     * {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D},
     * {@see GL46::glTexSubImage2D}, {@see GL46::glTexSubImage3D}), {@see GL46::glCompressedTexImage1D},
     * {@see GL46::glCompressedTexImage2D}, {@see GL46::glCompressedTexImage3D},
     * {@see GL46::glCompressedTexSubImage1D}, {@see GL46::glCompressedTexSubImage2D} or
     * {@see GL46::glCompressedTexSubImage1D}.
     *
     * $pname is a symbolic constant indicating the parameter to be set, and $param is the new value. Six of the
     * twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
     *
     *  - {@see GL46::GL_PACK_SWAP_BYTES}: If true, byte ordering for multibyte
     *    color components, depth components, or stencil indices is reversed.
     *    That
     *    is, if a four-byte component consists of bytes   b 0  ,   b 1  ,   b 2
     *     ,   b 3  , it is stored in memory as
     *    b 3  ,   b 2  ,   b 1  ,   b 0   if {@see GL46::GL_PACK_SWAP_BYTES} is
     *    true. {@see GL46::GL_PACK_SWAP_BYTES}
     *    has no effect on the memory order of components within a pixel, only
     *    on the order of bytes within components
     *    or indices. For example, the three components of a {@see GL46::GL_RGB}
     *    format pixel are always stored with red
     *    first, green second, and blue third, regardless of the value of {@see
     *    GL46::GL_PACK_SWAP_BYTES}.
     *
     *  - {@see GL46::GL_PACK_LSB_FIRST}: If true, bits are ordered within a
     *    byte from least significant to most significant; otherwise, the first
     *    bit
     *    in each byte is the most significant one.
     *
     *  - {@see GL46::GL_PACK_ROW_LENGTH}: If greater than 0, {@see
     *    GL46::GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If
     *    the first pixel
     *    of a row is placed at location p in memory, then the location of the
     *    first pixel of the next row is obtained
     *    by skipping      k =      n &amp;it; l       a s   &amp;it;     s
     *    &amp;it; n &amp;it; l   a      &amp;it;    s
     *    &gt;= a     s &lt; a          components or indices, where n is the
     *    number of components or indices in a
     *    pixel, l is the number of pixels in a row ({@see
     *    GL46::GL_PACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to the pixel routine otherwise), a is the value of {@see
     *    GL46::GL_PACK_ALIGNMENT}, and s is the size,
     *    in bytes, of a single component (if    a &lt; s  , then it is as if
     *    a = s  ). In the case of 1-bit values,
     *    the location of the next row is obtained by skipping      k =  8
     *    &amp;it; a &amp;it;     n &amp;it; l     8
     *    &amp;it; a          components or indices.   The word component in
     *    this description refers to the nonindex
     *    values red, green, blue, alpha, and depth. Storage format {@see
     *    GL46::GL_RGB}, for example, has three
     *    components per pixel: first red, then green, and finally blue.
     *
     *  - {@see GL46::GL_PACK_IMAGE_HEIGHT}: If greater than 0, {@see
     *    GL46::GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image
     *    three-dimensional texture volume, where ``image'' is defined by all
     *    pixels sharing the same third dimension
     *    index. If the first pixel of a row is placed at location p in memory,
     *    then the location of the first pixel of
     *    the next row is obtained by skipping      k =      n &amp;it; l
     *    &amp;it; h       a s   &amp;it;     s &amp;it;
     *    n &amp;it; l &amp;it; h   a      &amp;it;    s &gt;= a     s &lt; a
     *          components or indices, where n is
     *    the number of components or indices in a pixel, l is the number of
     *    pixels in a row
     *    ({@see GL46::GL_PACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to {@see GL46::glTexImage3D}
     *    otherwise), h is the number of rows in a pixel image ({@see
     *    GL46::GL_PACK_IMAGE_HEIGHT} if it is greater than
     *    0, the height argument to the {@see GL46::glTexImage3D} routine
     *    otherwise), a is the value of
     *    {@see GL46::GL_PACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then it
     *    is as if    a = s  ).   The word component in this description refers
     *    to the nonindex values red, green, blue,
     *    alpha, and depth. Storage format {@see GL46::GL_RGB}, for example, has
     *    three components per pixel: first red,
     *    then green, and finally blue.
     *
     *  - {@see GL46::GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, and
     *    GL_PACK_SKIP_IMAGES}: These values are provided as a convenience to
     *    the programmer; they provide no functionality that cannot be
     *    duplicated simply by incrementing the pointer passed to {@see
     *    GL46::glReadPixels}. Setting
     *    {@see GL46::GL_PACK_SKIP_PIXELS} to i is equivalent to incrementing
     *    the pointer by    i &amp;it; n
     *    components or indices, where n is the number of components or indices
     *    in each pixel. Setting
     *    {@see GL46::GL_PACK_SKIP_ROWS} to j is equivalent to incrementing the
     *    pointer by    j &amp;it; m   components
     *    or indices, where m is the number of components or indices per row, as
     *    just computed in the
     *    {@see GL46::GL_PACK_ROW_LENGTH} section. Setting {@see
     *    GL46::GL_PACK_SKIP_IMAGES} to k is equivalent to
     *    incrementing the pointer by    k &amp;it; p  , where p is the number
     *    of components or indices per image, as
     *    computed in the {@see GL46::GL_PACK_IMAGE_HEIGHT} section.
     *
     *  - {@see GL46::GL_PACK_ALIGNMENT}: Specifies the alignment requirements
     *    for the start of each pixel row in memory. The allowable values are 1
     *    (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
     *    (word-alignment), and 8 (rows start on
     *    double-word boundaries).
     *
     * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values
     * are significant for {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D}, {@see GL46::glTexImage3D},
     * {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and {@see GL46::glTexSubImage3D}
     *
     * They are as follows:
     *
     *  - {@see GL46::GL_UNPACK_SWAP_BYTES}: If true, byte ordering for
     *    multibyte color components, depth components, or stencil indices is
     *    reversed. That
     *    is, if a four-byte component consists of bytes   b 0  ,   b 1  ,   b 2
     *     ,   b 3  , it is taken from memory as
     *     b 3  ,   b 2  ,   b 1  ,   b 0   if {@see GL46::GL_UNPACK_SWAP_BYTES}
     *    is true.
     *    {@see GL46::GL_UNPACK_SWAP_BYTES} has no effect on the memory order of
     *    components within a pixel, only on the
     *    order of bytes within components or indices. For example, the three
     *    components of a {@see GL46::GL_RGB} format
     *    pixel are always stored with red first, green second, and blue third,
     *    regardless of the value of
     *    {@see GL46::GL_UNPACK_SWAP_BYTES}.
     *
     *  - {@see GL46::GL_UNPACK_LSB_FIRST}: If true, bits are ordered within a
     *    byte from least significant to most significant; otherwise, the first
     *    bit
     *    in each byte is the most significant one.
     *
     *  - {@see GL46::GL_UNPACK_ROW_LENGTH}: If greater than 0, {@see
     *    GL46::GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If
     *    the first
     *    pixel of a row is placed at location p in memory, then the location of
     *    the first pixel of the next row is
     *    obtained by skipping      k =      n &amp;it; l       a s   &amp;it;
     *      s &amp;it; n &amp;it; l   a
     *    &amp;it;    s &gt;= a     s &lt; a          components or indices,
     *    where n is the number of components or
     *    indices in a pixel, l is the number of pixels in a row ({@see
     *    GL46::GL_UNPACK_ROW_LENGTH} if it is greater
     *    than 0, the width argument to the pixel routine otherwise), a is the
     *    value of
     *    {@see GL46::GL_UNPACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then
     *    it is as if    a = s  ). In the case of 1-bit values, the location of
     *    the next row is obtained by skipping
     *     k =  8 &amp;it; a &amp;it;     n &amp;it; l     8 &amp;it; a
     *    components or indices.   The word
     *    component in this description refers to the nonindex values red,
     *    green, blue, alpha, and depth. Storage format
     *    {@see GL46::GL_RGB}, for example, has three components per pixel:
     *    first red, then green, and finally blue.
     *
     *  - {@see GL46::GL_UNPACK_IMAGE_HEIGHT}: If greater than 0, {@see
     *    GL46::GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image
     *    of a
     *    three-dimensional texture volume. Where ``image'' is defined by all
     *    pixel sharing the same third dimension
     *    index. If the first pixel of a row is placed at location p in memory,
     *    then the location of the first pixel of
     *    the next row is obtained by skipping      k =      n &amp;it; l
     *    &amp;it; h       a s   &amp;it;     s &amp;it;
     *    n &amp;it; l &amp;it; h   a      &amp;it;    s &gt;= a     s &lt; a
     *          components or indices, where n is
     *    the number of components or indices in a pixel, l is the number of
     *    pixels in a row
     *    ({@see GL46::GL_UNPACK_ROW_LENGTH} if it is greater than 0, the width
     *    argument to {@see GL46::glTexImage3D}
     *    otherwise), h is the number of rows in an image ({@see
     *    GL46::GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0,
     *    the height argument to {@see GL46::glTexImage3D} otherwise), a is the
     *    value of
     *    {@see GL46::GL_UNPACK_ALIGNMENT}, and s is the size, in bytes, of a
     *    single component (if    a &lt; s  , then
     *    it is as if    a = s  ).   The word component in this description
     *    refers to the nonindex values red, green,
     *    blue, alpha, and depth. Storage format {@see GL46::GL_RGB}, for
     *    example, has three components per pixel: first
     *    red, then green, and finally blue.
     *
     *  - {@see GL46::GL_UNPACK_SKIP_PIXELS and GL_UNPACK_SKIP_ROWS}: These
     *    values are provided as a convenience to the programmer; they provide
     *    no functionality that cannot be
     *    duplicated by incrementing the pointer passed to {@see
     *    GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     *    {@see GL46::glTexSubImage1D} or {@see GL46::glTexSubImage2D}. Setting
     *    {@see GL46::GL_UNPACK_SKIP_PIXELS} to i
     *    is equivalent to incrementing the pointer by    i &amp;it; n
     *    components or indices, where n is the number of
     *    components or indices in each pixel. Setting {@see
     *    GL46::GL_UNPACK_SKIP_ROWS} to j is equivalent to
     *    incrementing the pointer by    j &amp;it; k   components or indices,
     *    where k is the number of components or
     *    indices per row, as just computed in the {@see
     *    GL46::GL_UNPACK_ROW_LENGTH} section.
     *
     *  - {@see GL46::GL_UNPACK_ALIGNMENT}: Specifies the alignment requirements
     *    for the start of each pixel row in memory. The allowable values are 1
     *    (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
     *    (word-alignment), and 8 (rows start on
     *    double-word boundaries).
     *
     * The following table gives the type, initial value, and range of valid values for each storage parameter that
     * can be set with {@see GL46::glPixelStore}.
     *
     * | {@see GL46::GL_PACK_SWAP_BYTES}     | boolean | false | true or false |
     * | {@see GL46::GL_PACK_LSB_FIRST}      | boolean | false | true or false |
     * | {@see GL46::GL_PACK_ROW_LENGTH}     | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_IMAGE_HEIGHT}   | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_ROWS}      | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_PIXELS}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_SKIP_IMAGES}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_PACK_ALIGNMENT}      | integer | 4     | 1, 2, 4, or 8 |
     * | {@see GL46::GL_UNPACK_SWAP_BYTES}   | boolean | false | true or false |
     * | {@see GL46::GL_UNPACK_LSB_FIRST}    | boolean | false | true or false |
     * | {@see GL46::GL_UNPACK_ROW_LENGTH}   | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_IMAGE_HEIGHT} | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_ROWS}    | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_PIXELS}  | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_SKIP_IMAGES}  | integer | 0     |    0 ∞      |
     * | {@see GL46::GL_UNPACK_ALIGNMENT}    | integer | 4     | 1, 2, 4, or 8 |
     * {@see GL46::glPixelStoref} can be used to set any pixel store parameter. If the parameter type is boolean,
     * then if $param is 0, the parameter is false; otherwise it is set to true. If $pname is an integer type
     * parameter, $param is rounded to the nearest integer.
     *
     * Likewise, {@see GL46::glPixelStorei} can also be used to set any of the pixel store parameters. Boolean
     * parameters are set to false if $param is 0 and true otherwise.
     *
     * @see http://docs.gl/gl2/glPixelStore
     * @see http://docs.gl/gl4/glPixelStore
     * @since 1.1
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function pixelStorei(int $pname, int $param): void
    {
        $this->info->ffi->glPixelStorei($pname, $param);
    }

    /**
     * {@see GL46::glPixelTransfer} sets pixel transfer modes that affect the operation of subsequent
     * {@see GL46::glCopyPixels}, {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D},
     * {@see GL46::glCopyTexSubImage1D}, {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D},
     * {@see GL46::glDrawPixels}, {@see GL46::glReadPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     * {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and
     * {@see GL46::glTexSubImage3D} commands. Additionally, if the `ARB_imaging` subset is supported, the routines
     * {@see GL46::glColorTable}, {@see GL46::glColorSubTable}, {@see GL46::glConvolutionFilter1D},
     * {@see GL46::glConvolutionFilter2D}, {@see GL46::glHistogram}, {@see GL46::glMinmax}, and
     * {@see GL46::glSeparableFilter2D} are also affected. The algorithms that are specified by pixel transfer modes
     * operate on pixels after they are read from the frame buffer ({@see GL46::glCopyPixels}
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D}, and {@see GL46::glReadPixels}), or
     * unpacked from client memory ({@see GL46::glDrawPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     * {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and
     * {@see GL46::glTexSubImage3D}). Pixel transfer operations happen in the same order, and in the same manner,
     * regardless of the command that resulted in the pixel operation. Pixel storage modes (see
     * {@see GL46::glPixelStore}) control the unpacking of pixels being read from client memory and the packing of
     * pixels being written back into client memory.
     *
     * Pixel transfer operations handle four fundamental pixel types: color, color index, depth, and stencil. Color
     * pixels consist of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0
     * represents zero intensity and 1 represents full intensity. Color indices comprise a single fixed-point value,
     * with unspecified precision to the right of the binary point. Depth pixels comprise a single floating-point
     * value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer
     * value, and 1.0 represents the maximum depth buffer value. Finally, stencil pixels comprise a single
     * fixed-point value, with unspecified precision to the right of the binary point.
     *
     * The pixel transfer operations performed on the four basic pixel types are as follows:
     *
     *  - {@see GL46::Color}: Each of the four color components is multiplied by
     *    a scale factor, then added to a bias factor. That is, the
     *    red component is multiplied by {@see GL46::GL_RED_SCALE}, then added
     *    to {@see GL46::GL_RED_BIAS}; the green
     *    component is multiplied by {@see GL46::GL_GREEN_SCALE}, then added to
     *    {@see GL46::GL_GREEN_BIAS}; the blue
     *    component is multiplied by {@see GL46::GL_BLUE_SCALE}, then added to
     *    {@see GL46::GL_BLUE_BIAS}; and the alpha
     *    component is multiplied by {@see GL46::GL_ALPHA_SCALE}, then added to
     *    {@see GL46::GL_ALPHA_BIAS}. After all
     *    four color components are scaled and biased, each is clamped to the
     *    range    0 1  . All color, scale, and bias
     *    values are specified with {@see GL46::glPixelTransfer}.   If {@see
     *    GL46::GL_MAP_COLOR} is true, each color
     *    component is scaled by the size of the corresponding color-to-color
     *    map, then replaced by the contents of that
     *    map indexed by the scaled component. That is, the red component is
     *    scaled by
     *    {@see GL46::GL_PIXEL_MAP_R_TO_R_SIZE}, then replaced by the contents
     *    of {@see GL46::GL_PIXEL_MAP_R_TO_R}
     *    indexed by itself. The green component is scaled by {@see
     *    GL46::GL_PIXEL_MAP_G_TO_G_SIZE}, then replaced by
     *    the contents of {@see GL46::GL_PIXEL_MAP_G_TO_G} indexed by itself.
     *    The blue component is scaled by
     *    {@see GL46::GL_PIXEL_MAP_B_TO_B_SIZE}, then replaced by the contents
     *    of {@see GL46::GL_PIXEL_MAP_B_TO_B}
     *    indexed by itself. And the alpha component is scaled by {@see
     *    GL46::GL_PIXEL_MAP_A_TO_A_SIZE}, then replaced
     *    by the contents of {@see GL46::GL_PIXEL_MAP_A_TO_A} indexed by itself.
     *    All components taken from the maps are
     *    then clamped to the range    0 1  . {@see GL46::GL_MAP_COLOR} is
     *    specified with {@see GL46::glPixelTransfer}.
     *    The contents of the various maps are specified with {@see
     *    GL46::glPixelMap}.   If the `ARB_imaging` extension
     *    is supported, each of the four color components may be scaled and
     *    biased after transformation by the color
     *    matrix. That is, the red component is multiplied by {@see
     *    GL46::GL_POST_COLOR_MATRIX_RED_SCALE}, then added to
     *    {@see GL46::GL_POST_COLOR_MATRIX_RED_BIAS}; the green component is
     *    multiplied by
     *    {@see GL46::GL_POST_COLOR_MATRIX_GREEN_SCALE}, then added to {@see
     *    GL46::GL_POST_COLOR_MATRIX_GREEN_BIAS}; the
     *    blue component is multiplied by {@see
     *    GL46::GL_POST_COLOR_MATRIX_BLUE_SCALE}, then added to
     *    {@see GL46::GL_POST_COLOR_MATRIX_BLUE_BIAS}; and the alpha component
     *    is multiplied by
     *    {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_SCALE}, then added to {@see
     *    GL46::GL_POST_COLOR_MATRIX_ALPHA_BIAS}.
     *    After all four color components are scaled and biased, each is clamped
     *    to the range    0 1  .   Similarly, if
     *    the `ARB_imaging` extension is supported, each of the four color
     *    components may be scaled and biased after
     *    processing by the enabled convolution filter. That is, the red
     *    component is multiplied by
     *    {@see GL46::GL_POST_CONVOLUTION_RED_SCALE}, then added to {@see
     *    GL46::GL_POST_CONVOLUTION_RED_BIAS}; the green
     *    component is multiplied by {@see
     *    GL46::GL_POST_CONVOLUTION_GREEN_SCALE}, then added to
     *    {@see GL46::GL_POST_CONVOLUTION_GREEN_BIAS}; the blue component is
     *    multiplied by
     *    {@see GL46::GL_POST_CONVOLUTION_BLUE_SCALE}, then added to {@see
     *    GL46::GL_POST_CONVOLUTION_BLUE_BIAS}; and the
     *    alpha component is multiplied by {@see
     *    GL46::GL_POST_CONVOLUTION_ALPHA_SCALE}, then added to
     *    {@see GL46::GL_POST_CONVOLUTION_ALPHA_BIAS}. After all four color
     *    components are scaled and biased, each is
     *    clamped to the range    0 1  .
     *
     *  - {@see GL46::Color index}: Each color index is shifted left by {@see
     *    GL46::GL_INDEX_SHIFT} bits; any bits beyond the number of fraction
     *    bits carried by the fixed-point index are filled with zeros. If {@see
     *    GL46::GL_INDEX_SHIFT} is negative, the
     *    shift is to the right, again zero filled. Then {@see
     *    GL46::GL_INDEX_OFFSET} is added to the index.
     *    {@see GL46::GL_INDEX_SHIFT} and {@see GL46::GL_INDEX_OFFSET} are
     *    specified with {@see GL46::glPixelTransfer}.
     *     From this point, operation diverges depending on the required format
     *    of the resulting pixels. If the
     *    resulting pixels are to be written to a color index buffer, or if they
     *    are being read back to client memory in
     *    {@see GL46::GL_COLOR_INDEX} format, the pixels continue to be treated
     *    as indices. If {@see GL46::GL_MAP_COLOR}
     *    is true, each index is masked by    2 n  - 1  , where n is {@see
     *    GL46::GL_PIXEL_MAP_I_TO_I_SIZE}, then
     *    replaced by the contents of {@see GL46::GL_PIXEL_MAP_I_TO_I} indexed
     *    by the masked value.
     *    {@see GL46::GL_MAP_COLOR} is specified with {@see
     *    GL46::glPixelTransfer}. The contents of the index map is
     *    specified with {@see GL46::glPixelMap}.   If the resulting pixels are
     *    to be written to an RGBA color buffer,
     *    or if they are read back to client memory in a format other than {@see
     *    GL46::GL_COLOR_INDEX}, the pixels are
     *    converted from indices to colors by referencing the four maps {@see
     *    GL46::GL_PIXEL_MAP_I_TO_R},
     *    {@see GL46::GL_PIXEL_MAP_I_TO_G}, {@see GL46::GL_PIXEL_MAP_I_TO_B},
     *    and {@see GL46::GL_PIXEL_MAP_I_TO_A}.
     *    Before being dereferenced, the index is masked by    2 n  - 1  , where
     *    n is
     *    {@see GL46::GL_PIXEL_MAP_I_TO_R_SIZE} for the red map, {@see
     *    GL46::GL_PIXEL_MAP_I_TO_G_SIZE} for the green
     *    map, {@see GL46::GL_PIXEL_MAP_I_TO_B_SIZE} for the blue map, and {@see
     *    GL46::GL_PIXEL_MAP_I_TO_A_SIZE} for the
     *    alpha map. All components taken from the maps are then clamped to the
     *    range    0 1  . The contents of the four
     *    maps is specified with {@see GL46::glPixelMap}.
     *
     *  - {@see GL46::Depth}: Each depth value is multiplied by {@see
     *    GL46::GL_DEPTH_SCALE}, added to {@see GL46::GL_DEPTH_BIAS}, then
     *    clamped to the range    0 1  .
     *
     *  - {@see GL46::Stencil}: Each index is shifted {@see
     *    GL46::GL_INDEX_SHIFT} bits just as a color index is, then added to
     *    {@see GL46::GL_INDEX_OFFSET}. If {@see GL46::GL_MAP_STENCIL} is true,
     *    each index is masked by    2 n  - 1  ,
     *    where n is {@see GL46::GL_PIXEL_MAP_S_TO_S_SIZE}, then replaced by the
     *    contents of
     *    {@see GL46::GL_PIXEL_MAP_S_TO_S} indexed by the masked value.
     *
     * The following table gives the type, initial value, and range of valid values for each of the pixel transfer
     * parameters that are set with {@see GL46::glPixelTransfer}.
     *
     * | {@see GL46::GL_MAP_COLOR}                     | boolean | false | true/false |
     * | {@see GL46::GL_MAP_STENCIL}                   | boolean | false | true/false |
     * | {@see GL46::GL_INDEX_SHIFT}                   | integer | 0     |     -      |
     * | {@see GL46::GL_INDEX_OFFSET}                  | integer | 0     |     -      |
     * | {@see GL46::GL_RED_SCALE}                     | float   | 1     |     -      |
     * | {@see GL46::GL_GREEN_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_BLUE_SCALE}                    | float   | 1     |     -      |
     * | {@see GL46::GL_ALPHA_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_DEPTH_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_RED_BIAS}                      | float   | 0     |     -      |
     * | {@see GL46::GL_GREEN_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_BLUE_BIAS}                     | float   | 0     |     -      |
     * | {@see GL46::GL_ALPHA_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_DEPTH_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_RED_SCALE}   | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_GREEN_SCALE} | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_BLUE_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_SCALE} | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_RED_BIAS}    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_GREEN_BIAS}  | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_BLUE_BIAS}   | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_BIAS}  | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_RED_SCALE}    | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_GREEN_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_BLUE_SCALE}   | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_ALPHA_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_RED_BIAS}     | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_GREEN_BIAS}   | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_BLUE_BIAS}    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_ALPHA_BIAS}   | float   | 0     |     -      |
     * {@see GL46::glPixelTransferf} can be used to set any pixel transfer parameter. If the parameter type is
     * boolean, 0 implies false and any other value implies true. If $pname is an integer parameter, $param is
     * rounded to the nearest integer.
     *
     * Likewise, {@see GL46::glPixelTransferi} can be used to set any of the pixel transfer parameters. Boolean
     * parameters are set to false if $param is 0 and to true otherwise. $param is converted to floating point before
     * being assigned to real-valued parameters.
     *
     * @see http://docs.gl/gl2/glPixelTransfer
     * @since 1.1
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function pixelTransferf(int $pname, float $param): void
    {
        $this->info->ffi->glPixelTransferf($pname, $param);
    }

    /**
     * {@see GL46::glPixelTransfer} sets pixel transfer modes that affect the operation of subsequent
     * {@see GL46::glCopyPixels}, {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D},
     * {@see GL46::glCopyTexSubImage1D}, {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D},
     * {@see GL46::glDrawPixels}, {@see GL46::glReadPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     * {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and
     * {@see GL46::glTexSubImage3D} commands. Additionally, if the `ARB_imaging` subset is supported, the routines
     * {@see GL46::glColorTable}, {@see GL46::glColorSubTable}, {@see GL46::glConvolutionFilter1D},
     * {@see GL46::glConvolutionFilter2D}, {@see GL46::glHistogram}, {@see GL46::glMinmax}, and
     * {@see GL46::glSeparableFilter2D} are also affected. The algorithms that are specified by pixel transfer modes
     * operate on pixels after they are read from the frame buffer ({@see GL46::glCopyPixels}
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, {@see GL46::glCopyTexSubImage3D}, and {@see GL46::glReadPixels}), or
     * unpacked from client memory ({@see GL46::glDrawPixels}, {@see GL46::glTexImage1D}, {@see GL46::glTexImage2D},
     * {@see GL46::glTexImage3D}, {@see GL46::glTexSubImage1D}, {@see GL46::glTexSubImage2D}, and
     * {@see GL46::glTexSubImage3D}). Pixel transfer operations happen in the same order, and in the same manner,
     * regardless of the command that resulted in the pixel operation. Pixel storage modes (see
     * {@see GL46::glPixelStore}) control the unpacking of pixels being read from client memory and the packing of
     * pixels being written back into client memory.
     *
     * Pixel transfer operations handle four fundamental pixel types: color, color index, depth, and stencil. Color
     * pixels consist of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0
     * represents zero intensity and 1 represents full intensity. Color indices comprise a single fixed-point value,
     * with unspecified precision to the right of the binary point. Depth pixels comprise a single floating-point
     * value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer
     * value, and 1.0 represents the maximum depth buffer value. Finally, stencil pixels comprise a single
     * fixed-point value, with unspecified precision to the right of the binary point.
     *
     * The pixel transfer operations performed on the four basic pixel types are as follows:
     *
     *  - {@see GL46::Color}: Each of the four color components is multiplied by
     *    a scale factor, then added to a bias factor. That is, the
     *    red component is multiplied by {@see GL46::GL_RED_SCALE}, then added
     *    to {@see GL46::GL_RED_BIAS}; the green
     *    component is multiplied by {@see GL46::GL_GREEN_SCALE}, then added to
     *    {@see GL46::GL_GREEN_BIAS}; the blue
     *    component is multiplied by {@see GL46::GL_BLUE_SCALE}, then added to
     *    {@see GL46::GL_BLUE_BIAS}; and the alpha
     *    component is multiplied by {@see GL46::GL_ALPHA_SCALE}, then added to
     *    {@see GL46::GL_ALPHA_BIAS}. After all
     *    four color components are scaled and biased, each is clamped to the
     *    range    0 1  . All color, scale, and bias
     *    values are specified with {@see GL46::glPixelTransfer}.   If {@see
     *    GL46::GL_MAP_COLOR} is true, each color
     *    component is scaled by the size of the corresponding color-to-color
     *    map, then replaced by the contents of that
     *    map indexed by the scaled component. That is, the red component is
     *    scaled by
     *    {@see GL46::GL_PIXEL_MAP_R_TO_R_SIZE}, then replaced by the contents
     *    of {@see GL46::GL_PIXEL_MAP_R_TO_R}
     *    indexed by itself. The green component is scaled by {@see
     *    GL46::GL_PIXEL_MAP_G_TO_G_SIZE}, then replaced by
     *    the contents of {@see GL46::GL_PIXEL_MAP_G_TO_G} indexed by itself.
     *    The blue component is scaled by
     *    {@see GL46::GL_PIXEL_MAP_B_TO_B_SIZE}, then replaced by the contents
     *    of {@see GL46::GL_PIXEL_MAP_B_TO_B}
     *    indexed by itself. And the alpha component is scaled by {@see
     *    GL46::GL_PIXEL_MAP_A_TO_A_SIZE}, then replaced
     *    by the contents of {@see GL46::GL_PIXEL_MAP_A_TO_A} indexed by itself.
     *    All components taken from the maps are
     *    then clamped to the range    0 1  . {@see GL46::GL_MAP_COLOR} is
     *    specified with {@see GL46::glPixelTransfer}.
     *    The contents of the various maps are specified with {@see
     *    GL46::glPixelMap}.   If the `ARB_imaging` extension
     *    is supported, each of the four color components may be scaled and
     *    biased after transformation by the color
     *    matrix. That is, the red component is multiplied by {@see
     *    GL46::GL_POST_COLOR_MATRIX_RED_SCALE}, then added to
     *    {@see GL46::GL_POST_COLOR_MATRIX_RED_BIAS}; the green component is
     *    multiplied by
     *    {@see GL46::GL_POST_COLOR_MATRIX_GREEN_SCALE}, then added to {@see
     *    GL46::GL_POST_COLOR_MATRIX_GREEN_BIAS}; the
     *    blue component is multiplied by {@see
     *    GL46::GL_POST_COLOR_MATRIX_BLUE_SCALE}, then added to
     *    {@see GL46::GL_POST_COLOR_MATRIX_BLUE_BIAS}; and the alpha component
     *    is multiplied by
     *    {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_SCALE}, then added to {@see
     *    GL46::GL_POST_COLOR_MATRIX_ALPHA_BIAS}.
     *    After all four color components are scaled and biased, each is clamped
     *    to the range    0 1  .   Similarly, if
     *    the `ARB_imaging` extension is supported, each of the four color
     *    components may be scaled and biased after
     *    processing by the enabled convolution filter. That is, the red
     *    component is multiplied by
     *    {@see GL46::GL_POST_CONVOLUTION_RED_SCALE}, then added to {@see
     *    GL46::GL_POST_CONVOLUTION_RED_BIAS}; the green
     *    component is multiplied by {@see
     *    GL46::GL_POST_CONVOLUTION_GREEN_SCALE}, then added to
     *    {@see GL46::GL_POST_CONVOLUTION_GREEN_BIAS}; the blue component is
     *    multiplied by
     *    {@see GL46::GL_POST_CONVOLUTION_BLUE_SCALE}, then added to {@see
     *    GL46::GL_POST_CONVOLUTION_BLUE_BIAS}; and the
     *    alpha component is multiplied by {@see
     *    GL46::GL_POST_CONVOLUTION_ALPHA_SCALE}, then added to
     *    {@see GL46::GL_POST_CONVOLUTION_ALPHA_BIAS}. After all four color
     *    components are scaled and biased, each is
     *    clamped to the range    0 1  .
     *
     *  - {@see GL46::Color index}: Each color index is shifted left by {@see
     *    GL46::GL_INDEX_SHIFT} bits; any bits beyond the number of fraction
     *    bits carried by the fixed-point index are filled with zeros. If {@see
     *    GL46::GL_INDEX_SHIFT} is negative, the
     *    shift is to the right, again zero filled. Then {@see
     *    GL46::GL_INDEX_OFFSET} is added to the index.
     *    {@see GL46::GL_INDEX_SHIFT} and {@see GL46::GL_INDEX_OFFSET} are
     *    specified with {@see GL46::glPixelTransfer}.
     *     From this point, operation diverges depending on the required format
     *    of the resulting pixels. If the
     *    resulting pixels are to be written to a color index buffer, or if they
     *    are being read back to client memory in
     *    {@see GL46::GL_COLOR_INDEX} format, the pixels continue to be treated
     *    as indices. If {@see GL46::GL_MAP_COLOR}
     *    is true, each index is masked by    2 n  - 1  , where n is {@see
     *    GL46::GL_PIXEL_MAP_I_TO_I_SIZE}, then
     *    replaced by the contents of {@see GL46::GL_PIXEL_MAP_I_TO_I} indexed
     *    by the masked value.
     *    {@see GL46::GL_MAP_COLOR} is specified with {@see
     *    GL46::glPixelTransfer}. The contents of the index map is
     *    specified with {@see GL46::glPixelMap}.   If the resulting pixels are
     *    to be written to an RGBA color buffer,
     *    or if they are read back to client memory in a format other than {@see
     *    GL46::GL_COLOR_INDEX}, the pixels are
     *    converted from indices to colors by referencing the four maps {@see
     *    GL46::GL_PIXEL_MAP_I_TO_R},
     *    {@see GL46::GL_PIXEL_MAP_I_TO_G}, {@see GL46::GL_PIXEL_MAP_I_TO_B},
     *    and {@see GL46::GL_PIXEL_MAP_I_TO_A}.
     *    Before being dereferenced, the index is masked by    2 n  - 1  , where
     *    n is
     *    {@see GL46::GL_PIXEL_MAP_I_TO_R_SIZE} for the red map, {@see
     *    GL46::GL_PIXEL_MAP_I_TO_G_SIZE} for the green
     *    map, {@see GL46::GL_PIXEL_MAP_I_TO_B_SIZE} for the blue map, and {@see
     *    GL46::GL_PIXEL_MAP_I_TO_A_SIZE} for the
     *    alpha map. All components taken from the maps are then clamped to the
     *    range    0 1  . The contents of the four
     *    maps is specified with {@see GL46::glPixelMap}.
     *
     *  - {@see GL46::Depth}: Each depth value is multiplied by {@see
     *    GL46::GL_DEPTH_SCALE}, added to {@see GL46::GL_DEPTH_BIAS}, then
     *    clamped to the range    0 1  .
     *
     *  - {@see GL46::Stencil}: Each index is shifted {@see
     *    GL46::GL_INDEX_SHIFT} bits just as a color index is, then added to
     *    {@see GL46::GL_INDEX_OFFSET}. If {@see GL46::GL_MAP_STENCIL} is true,
     *    each index is masked by    2 n  - 1  ,
     *    where n is {@see GL46::GL_PIXEL_MAP_S_TO_S_SIZE}, then replaced by the
     *    contents of
     *    {@see GL46::GL_PIXEL_MAP_S_TO_S} indexed by the masked value.
     *
     * The following table gives the type, initial value, and range of valid values for each of the pixel transfer
     * parameters that are set with {@see GL46::glPixelTransfer}.
     *
     * | {@see GL46::GL_MAP_COLOR}                     | boolean | false | true/false |
     * | {@see GL46::GL_MAP_STENCIL}                   | boolean | false | true/false |
     * | {@see GL46::GL_INDEX_SHIFT}                   | integer | 0     |     -      |
     * | {@see GL46::GL_INDEX_OFFSET}                  | integer | 0     |     -      |
     * | {@see GL46::GL_RED_SCALE}                     | float   | 1     |     -      |
     * | {@see GL46::GL_GREEN_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_BLUE_SCALE}                    | float   | 1     |     -      |
     * | {@see GL46::GL_ALPHA_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_DEPTH_SCALE}                   | float   | 1     |     -      |
     * | {@see GL46::GL_RED_BIAS}                      | float   | 0     |     -      |
     * | {@see GL46::GL_GREEN_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_BLUE_BIAS}                     | float   | 0     |     -      |
     * | {@see GL46::GL_ALPHA_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_DEPTH_BIAS}                    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_RED_SCALE}   | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_GREEN_SCALE} | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_BLUE_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_SCALE} | float   | 1     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_RED_BIAS}    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_GREEN_BIAS}  | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_BLUE_BIAS}   | float   | 0     |     -      |
     * | {@see GL46::GL_POST_COLOR_MATRIX_ALPHA_BIAS}  | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_RED_SCALE}    | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_GREEN_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_BLUE_SCALE}   | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_ALPHA_SCALE}  | float   | 1     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_RED_BIAS}     | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_GREEN_BIAS}   | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_BLUE_BIAS}    | float   | 0     |     -      |
     * | {@see GL46::GL_POST_CONVOLUTION_ALPHA_BIAS}   | float   | 0     |     -      |
     * {@see GL46::glPixelTransferf} can be used to set any pixel transfer parameter. If the parameter type is
     * boolean, 0 implies false and any other value implies true. If $pname is an integer parameter, $param is
     * rounded to the nearest integer.
     *
     * Likewise, {@see GL46::glPixelTransferi} can be used to set any of the pixel transfer parameters. Boolean
     * parameters are set to false if $param is 0 and to true otherwise. $param is converted to floating point before
     * being assigned to real-valued parameters.
     *
     * @see http://docs.gl/gl2/glPixelTransfer
     * @since 1.1
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function pixelTransferi(int $pname, int $param): void
    {
        $this->info->ffi->glPixelTransferi($pname, $param);
    }

    /**
     * {@see GL46::glPixelZoom} specifies values for the x and y zoom factors. During the execution of
     * {@see GL46::glDrawPixels} or {@see GL46::glCopyPixels}, if (  xr ,   yr ) is the current raster position, and
     * a given element is in the mth row and nth column of the pixel rectangle, then pixels whose centers are in the
     * rectangle with corners at
     *
     * (   xr +  n &amp;CenterDot; xfactor   ,    yr +  m &amp;CenterDot; yfactor   )
     *
     * (   xr +    n + 1   &amp;CenterDot; xfactor   ,    yr +    m + 1   &amp;CenterDot; yfactor   )
     *
     * are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular
     * region is also modified.
     *
     * Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about
     * the current raster position.
     *
     * @see http://docs.gl/gl2/glPixelZoom
     * @since 1.1
     * @param float $xfactor
     * @param float $yfactor
     * @return void
     */
    public function pixelZoom(float $xfactor, float $yfactor): void
    {
        $this->info->ffi->glPixelZoom($xfactor, $yfactor);
    }

    /**
     * {@see GL46::glPointSize} specifies the rasterized diameter of points. If point size mode is disabled (see
     * {@see GL46::glEnable} with parameter {@see GL46::GL_PROGRAM_POINT_SIZE}), this value will be used to rasterize
     * points. Otherwise, the value written to the shading language built-in variable `gl_PointSize` will be used.
     *
     * @see http://docs.gl/gl2/glPointSize
     * @see http://docs.gl/gl4/glPointSize
     * @since 1.1
     * @param float $size
     * @return void
     */
    public function pointSize(float $size): void
    {
        $this->info->ffi->glPointSize($size);
    }

    /**
     * {@see GL46::glPolygonMode} controls the interpretation of polygons for rasterization. $face describes which
     * polygons $mode applies to: both front and back-facing polygons ({@see GL46::GL_FRONT_AND_BACK}). The polygon
     * mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the
     * polygon is clipped and possibly culled before these modes are applied.
     *
     * Three modes are defined and can be specified in $mode:
     *
     *  - {@see GL46::GL_POINT}: Polygon vertices that are marked as the start
     *    of a boundary edge are drawn as points. Point attributes such
     *    as {@see GL46::GL_POINT_SIZE} and {@see GL46::GL_POINT_SMOOTH} control
     *    the rasterization of the points.
     *    Polygon rasterization attributes other than {@see
     *    GL46::GL_POLYGON_MODE} have no effect.
     *
     *  - {@see GL46::GL_LINE}: Boundary edges of the polygon are drawn as line
     *    segments. Line attributes such as {@see GL46::GL_LINE_WIDTH}
     *    and {@see GL46::GL_LINE_SMOOTH} control the rasterization of the
     *    lines. Polygon rasterization attributes other
     *    than {@see GL46::GL_POLYGON_MODE} have no effect.
     *
     *  - {@see GL46::GL_FILL}: The interior of the polygon is filled. Polygon
     *    attributes such as {@see GL46::GL_POLYGON_SMOOTH} control the
     *    rasterization of the polygon.
     *
     * @see http://docs.gl/gl2/glPolygonMode
     * @see http://docs.gl/gl4/glPolygonMode
     * @since 1.1
     * @param int $face
     * @param int $mode
     * @return void
     */
    public function polygonMode(int $face, int $mode): void
    {
        $this->info->ffi->glPolygonMode($face, $mode);
    }

    /**
     * When {@see GL46::GL_POLYGON_OFFSET_FILL}, {@see GL46::GL_POLYGON_OFFSET_LINE}, or
     * {@see GL46::GL_POLYGON_OFFSET_POINT} is enabled, each fragment's depth value will be offset after it is
     * interpolated from the depth values of the appropriate vertices. The value of the offset is     factor × DZ  +
     *  r × units   , where   DZ  is a measurement of the change in depth relative to the screen area of the
     * polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given
     * implementation. The offset is added before the depth test is performed and before the value is written into
     * the depth buffer.
     *
     * {@see GL46::glPolygonOffset} is useful for rendering hidden-line images, for applying decals to surfaces, and
     * for rendering solids with highlighted edges.
     *
     * @see http://docs.gl/gl2/glPolygonOffset
     * @see http://docs.gl/gl4/glPolygonOffset
     * @since 1.1
     * @param float $factor
     * @param float $units
     * @return void
     */
    public function polygonOffset(float $factor, float $units): void
    {
        $this->info->ffi->glPolygonOffset($factor, $units);
    }

    /**
     * Polygon stippling, like line stippling (see {@see GL46::glLineStipple}), masks out certain fragments produced
     * by rasterization, creating a pattern. Stippling is independent of polygon antialiasing.
     *
     * $pattern is a pointer to a    32 × 32   stipple pattern that is stored in memory just like the pixel data
     * supplied to a {@see GL46::glDrawPixels} call with  height and width both equal to 32, a pixel format of
     * {@see GL46::GL_COLOR_INDEX}, and data type of {@see GL46::GL_BITMAP}. That is, the stipple pattern is
     * represented as a    32 × 32   array of 1-bit color indices packed in unsigned bytes.
     * {@see GL46::glPixelStore} parameters like {@see GL46::GL_UNPACK_SWAP_BYTES} and
     * {@see GL46::GL_UNPACK_LSB_FIRST} affect the assembling of the bits into a stipple pattern. Pixel transfer
     * operations (shift, offset, pixel map) are not applied to the stipple image, however.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a stipple pattern is specified, $pattern is treated as a byte offset into the
     * buffer object's data store.
     *
     * To enable and disable polygon stippling, call {@see GL46::glEnable} and {@see GL46::glDisable} with argument
     * {@see GL46::GL_POLYGON_STIPPLE}. Polygon stippling is initially disabled. If it's enabled, a rasterized
     * polygon fragment with window coordinates   x w   and   y w   is sent to the next stage of the GL if and only
     * if the (   x w  % 32  )th bit in the (   y w  % 32  )th row of the stipple pattern is 1 (one). When polygon
     * stippling is disabled, it is as if the stipple pattern consists of all 1's.
     *
     * @see http://docs.gl/gl2/glPolygonStipple
     * @since 1.1
     * @param \FFI\CData|null $mask
     * @return void
     */
    public function polygonStipple(?\FFI\CData $mask): void
    {
        $this->info->ffi->glPolygonStipple($mask);
    }

    /**
     * {@see GL46::glPushAttrib} takes one argument, a mask that indicates which groups of state variables to save on
     * the attribute stack. Symbolic constants are used to set bits in the mask. $mask is typically constructed by
     * specifying the bitwise-or of several of these constants together. The special mask
     * {@see GL46::GL_ALL_ATTRIB_BITS} can be used to save all stackable states.
     *
     * The symbolic mask constants and their associated GL state are as follows (the second column lists which
     * attributes are saved):
     *
     * | {@see GL46::GL_ACCUM_BUFFER_BIT}    | Accumulation buffer clear value                                                     |
     * | {@see GL46::GL_COLOR_BUFFER_BIT}    | {@see GL46::GL_ALPHA_TEST} enable bit                                               |
     * |                                     | Alpha test function and reference value                                             |
     * |                                     | {@see GL46::GL_BLEND} enable bit                                                    |
     * |                                     | Blending source and destination functions                                           |
     * |                                     | Constant blend color                                                                |
     * |                                     | Blending equation                                                                   |
     * |                                     | {@see GL46::GL_DITHER} enable bit                                                   |
     * |                                     | {@see GL46::GL_DRAW_BUFFER} setting                                                 |
     * |                                     | {@see GL46::GL_COLOR_LOGIC_OP} enable bit                                           |
     * |                                     | {@see GL46::GL_INDEX_LOGIC_OP} enable bit                                           |
     * |                                     | Logic op function                                                                   |
     * |                                     | Color mode and index mode clear values                                              |
     * |                                     | Color mode and index mode writemasks                                                |
     * | {@see GL46::GL_CURRENT_BIT}         | Current RGBA color                                                                  |
     * |                                     | Current color index                                                                 |
     * |                                     | Current normal vector                                                               |
     * |                                     | Current texture coordinates                                                         |
     * |                                     | Current raster position                                                             |
     * |                                     | {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag                                  |
     * |                                     | RGBA color associated with current raster position                                  |
     * |                                     | Color index associated with current raster position                                 |
     * |                                     | Texture coordinates associated with current raster position                         |
     * |                                     | {@see GL46::GL_EDGE_FLAG} flag                                                      |
     * | {@see GL46::GL_DEPTH_BUFFER_BIT}    | {@see GL46::GL_DEPTH_TEST} enable bit                                               |
     * |                                     | Depth buffer test function                                                          |
     * |                                     | Depth buffer clear value                                                            |
     * |                                     | {@see GL46::GL_DEPTH_WRITEMASK} enable bit                                          |
     * | {@see GL46::GL_ENABLE_BIT}          | {@see GL46::GL_ALPHA_TEST} flag                                                     |
     * |                                     | {@see GL46::GL_AUTO_NORMAL} flag                                                    |
     * |                                     | {@see GL46::GL_BLEND} flag                                                          |
     * |                                     | Enable bits for the user-definable clipping planes                                  |
     * |                                     | {@see GL46::GL_COLOR_MATERIAL}                                                      |
     * |                                     | {@see GL46::GL_CULL_FACE} flag                                                      |
     * |                                     | {@see GL46::GL_DEPTH_TEST} flag                                                     |
     * |                                     | {@see GL46::GL_DITHER} flag                                                         |
     * |                                     | {@see GL46::GL_FOG} flag                                                            |
     * |                                     | {@see GL46::GL_LIGHT}i where {@see GL46::0} &lt;= i &lt; {@see GL46::GL_MAX_LIGHTS} |
     * |                                     | {@see GL46::GL_LIGHTING} flag                                                       |
     * |                                     | {@see GL46::GL_LINE_SMOOTH} flag                                                    |
     * |                                     | {@see GL46::GL_LINE_STIPPLE} flag                                                   |
     * |                                     | {@see GL46::GL_COLOR_LOGIC_OP} flag                                                 |
     * |                                     | {@see GL46::GL_INDEX_LOGIC_OP} flag                                                 |
     * |                                     | {@see GL46::GL_MAP1_}x where x is a map type                                        |
     * |                                     | {@see GL46::GL_MAP2_}x where x is a map type                                        |
     * |                                     | {@see GL46::GL_MULTISAMPLE} flag                                                    |
     * |                                     | {@see GL46::GL_NORMALIZE} flag                                                      |
     * |                                     | {@see GL46::GL_POINT_SMOOTH} flag                                                   |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_LINE} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FILL} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_POINT} flag                                           |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH} flag                                                 |
     * |                                     | {@see GL46::GL_POLYGON_STIPPLE} flag                                                |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE} flag                                       |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_ONE} flag                                            |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE} flag                                                |
     * |                                     | {@see GL46::GL_SCISSOR_TEST} flag                                                   |
     * |                                     | {@see GL46::GL_STENCIL_TEST} flag                                                   |
     * |                                     | {@see GL46::GL_TEXTURE_1D} flag                                                     |
     * |                                     | {@see GL46::GL_TEXTURE_2D} flag                                                     |
     * |                                     | {@see GL46::GL_TEXTURE_3D} flag                                                     |
     * |                                     | Flags {@see GL46::GL_TEXTURE_GEN_}x where x is S, T, R, or Q                        |
     * | {@see GL46::GL_EVAL_BIT}            | {@see GL46::GL_MAP1_}x enable bits, where x is a map type                           |
     * |                                     | {@see GL46::GL_MAP2_}x enable bits, where x is a map type                           |
     * |                                     | 1D grid endpoints and divisions                                                     |
     * |                                     | 2D grid endpoints and divisions                                                     |
     * |                                     | {@see GL46::GL_AUTO_NORMAL} enable bit                                              |
     * | {@see GL46::GL_FOG_BIT}             | {@see GL46::GL_FOG} enable bit                                                      |
     * |                                     | Fog color                                                                           |
     * |                                     | Fog density                                                                         |
     * |                                     | Linear fog start                                                                    |
     * |                                     | Linear fog end                                                                      |
     * |                                     | Fog index                                                                           |
     * |                                     | {@see GL46::GL_FOG_MODE} value                                                      |
     * | {@see GL46::GL_HINT_BIT}            | {@see GL46::GL_PERSPECTIVE_CORRECTION_HINT} setting                                 |
     * |                                     | {@see GL46::GL_POINT_SMOOTH_HINT} setting                                           |
     * |                                     | {@see GL46::GL_LINE_SMOOTH_HINT} setting                                            |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH_HINT} setting                                         |
     * |                                     | {@see GL46::GL_FOG_HINT} setting                                                    |
     * |                                     | {@see GL46::GL_GENERATE_MIPMAP_HINT} setting                                        |
     * |                                     | {@see GL46::GL_TEXTURE_COMPRESSION_HINT} setting                                    |
     * | {@see GL46::GL_LIGHTING_BIT}        | {@see GL46::GL_COLOR_MATERIAL} enable bit                                           |
     * |                                     | {@see GL46::GL_COLOR_MATERIAL_FACE} value                                           |
     * |                                     | Color material parameters that are tracking the current color                       |
     * |                                     | Ambient scene color                                                                 |
     * |                                     | {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER} value                                      |
     * |                                     | {@see GL46::GL_LIGHT_MODEL_TWO_SIDE} setting                                        |
     * |                                     | {@see GL46::GL_LIGHTING} enable bit                                                 |
     * |                                     | Enable bit for each light                                                           |
     * |                                     | Ambient, diffuse, and specular intensity for each light                             |
     * |                                     | Direction, position, exponent, and cutoff angle for each light                      |
     * |                                     | Constant, linear, and quadratic attenuation factors for each light                  |
     * |                                     | Ambient, diffuse, specular, and emissive color for each material                    |
     * |                                     | Ambient, diffuse, and specular color indices for each material                      |
     * |                                     | Specular exponent for each material                                                 |
     * |                                     | {@see GL46::GL_SHADE_MODEL} setting                                                 |
     * | {@see GL46::GL_LINE_BIT}            | {@see GL46::GL_LINE_SMOOTH} flag                                                    |
     * |                                     | {@see GL46::GL_LINE_STIPPLE} enable bit                                             |
     * |                                     | Line stipple pattern and repeat counter                                             |
     * |                                     | Line width                                                                          |
     * | {@see GL46::GL_LIST_BIT}            | {@see GL46::GL_LIST_BASE} setting                                                   |
     * | {@see GL46::GL_MULTISAMPLE_BIT}     | {@see GL46::GL_MULTISAMPLE} flag                                                    |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE} flag                                       |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_ONE} flag                                            |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE} flag                                                |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE_VALUE} value                                         |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE_INVERT} value                                        |
     * | {@see GL46::GL_PIXEL_MODE_BIT}      | {@see GL46::GL_RED_BIAS} and {@see GL46::GL_RED_SCALE} settings                     |
     * |                                     | {@see GL46::GL_GREEN_BIAS} and {@see GL46::GL_GREEN_SCALE} values                   |
     * |                                     | {@see GL46::GL_BLUE_BIAS} and {@see GL46::GL_BLUE_SCALE}                            |
     * |                                     | {@see GL46::GL_ALPHA_BIAS} and {@see GL46::GL_ALPHA_SCALE}                          |
     * |                                     | {@see GL46::GL_DEPTH_BIAS} and {@see GL46::GL_DEPTH_SCALE}                          |
     * |                                     | {@see GL46::GL_INDEX_OFFSET} and {@see GL46::GL_INDEX_SHIFT} values                 |
     * |                                     | {@see GL46::GL_MAP_COLOR} and {@see GL46::GL_MAP_STENCIL} flags                     |
     * |                                     | {@see GL46::GL_ZOOM_X} and {@see GL46::GL_ZOOM_Y} factors                           |
     * |                                     | {@see GL46::GL_READ_BUFFER} setting                                                 |
     * | {@see GL46::GL_POINT_BIT}           | {@see GL46::GL_POINT_SMOOTH} flag                                                   |
     * |                                     | Point size                                                                          |
     * | {@see GL46::GL_POLYGON_BIT}         | {@see GL46::GL_CULL_FACE} enable bit                                                |
     * |                                     | {@see GL46::GL_CULL_FACE_MODE} value                                                |
     * |                                     | {@see GL46::GL_FRONT_FACE} indicator                                                |
     * |                                     | {@see GL46::GL_POLYGON_MODE} setting                                                |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH} flag                                                 |
     * |                                     | {@see GL46::GL_POLYGON_STIPPLE} enable bit                                          |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FILL} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_LINE} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_POINT} flag                                           |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FACTOR}                                               |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_UNITS}                                                |
     * | {@see GL46::GL_POLYGON_STIPPLE_BIT} | Polygon stipple image                                                               |
     * | {@see GL46::GL_SCISSOR_BIT}         | {@see GL46::GL_SCISSOR_TEST} flag                                                   |
     * |                                     | Scissor box                                                                         |
     * | {@see GL46::GL_STENCIL_BUFFER_BIT}  | {@see GL46::GL_STENCIL_TEST} enable bit                                             |
     * |                                     | Stencil function and reference value                                                |
     * |                                     | Stencil value mask                                                                  |
     * |                                     | Stencil fail, pass, and depth buffer pass actions                                   |
     * |                                     | Stencil buffer clear value                                                          |
     * |                                     | Stencil buffer writemask                                                            |
     * | {@see GL46::GL_TEXTURE_BIT}         | Enable bits for the four texture coordinates                                        |
     * |                                     | Border color for each texture image                                                 |
     * |                                     | Minification function for each texture image                                        |
     * |                                     | Magnification function for each texture image                                       |
     * |                                     | Texture coordinates and wrap mode for each texture image                            |
     * |                                     | Color and mode for each texture environment                                         |
     * |                                     | Enable bits {@see GL46::GL_TEXTURE_GEN_}x, x is S, T, R, and Q                      |
     * |                                     | {@see GL46::GL_TEXTURE_GEN_MODE} setting for S, T, R, and Q                         |
     * |                                     | {@see GL46::glTexGen} plane equations for S, T, R, and Q                            |
     * |                                     | Current texture bindings (for example, {@see GL46::GL_TEXTURE_BINDING_2D})          |
     * | {@see GL46::GL_TRANSFORM_BIT}       | Coefficients of the six clipping planes                                             |
     * |                                     | Enable bits for the user-definable clipping planes                                  |
     * |                                     | {@see GL46::GL_MATRIX_MODE} value                                                   |
     * |                                     | {@see GL46::GL_NORMALIZE} flag                                                      |
     * |                                     | {@see GL46::GL_RESCALE_NORMAL} flag                                                 |
     * | {@see GL46::GL_VIEWPORT_BIT}        | Depth range (near and far)                                                          |
     * |                                     | Viewport origin and extent                                                          |
     * {@see GL46::glPopAttrib} restores the values of the state variables saved with the last
     * {@see GL46::glPushAttrib} command. Those not saved are left unchanged.
     *
     * It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case,
     * the error flag is set and no other change is made to GL state.
     *
     * Initially, the attribute stack is empty.
     *
     * @see http://docs.gl/gl2/glPushAttrib
     * @since 1.1
     * @return void
     */
    public function popAttrib(): void
    {
        $this->info->ffi->glPopAttrib();
    }

    /**
     * {@see GL46::glPushClientAttrib} takes one argument, a mask that indicates which groups of client-state
     * variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. $mask is
     * typically constructed by specifying the bitwise-or of several of these constants together. The special mask
     * {@see GL46::GL_CLIENT_ALL_ATTRIB_BITS} can be used to save all stackable client state.
     *
     * The symbolic mask constants and their associated GL client state are as follows (the second column lists which
     * attributes are saved):
     *
     * {@see GL46::GL_CLIENT_PIXEL_STORE_BIT} Pixel storage modes {@see GL46::GL_CLIENT_VERTEX_ARRAY_BIT} Vertex
     * arrays (and enables)
     *
     * {@see GL46::glPopClientAttrib} restores the values of the client-state variables saved with the last
     * {@see GL46::glPushClientAttrib}. Those not saved are left unchanged.
     *
     * It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack.
     * In either case, the error flag is set, and no other change is made to GL state.
     *
     * Initially, the client attribute stack is empty.
     *
     * @see http://docs.gl/gl2/glPushClientAttrib
     * @since 1.1
     * @return void
     */
    public function popClientAttrib(): void
    {
        $this->info->ffi->glPopClientAttrib();
    }

    /**
     * There is a stack of matrices for each of the matrix modes. In {@see GL46::GL_MODELVIEW} mode, the stack depth
     * is at least 32. In the other modes, {@see GL46::GL_COLOR}, {@see GL46::GL_PROJECTION}, and
     * {@see GL46::GL_TEXTURE}, the depth is at least 2. The current matrix in any mode is the matrix on the top of
     * the stack for that mode.
     *
     * {@see GL46::glPushMatrix} pushes the current matrix stack down by one, duplicating the current matrix. That
     * is, after a {@see GL46::glPushMatrix} call, the matrix on top of the stack is identical to the one below it.
     *
     * {@see GL46::glPopMatrix} pops the current matrix stack, replacing the current matrix with the one below it on
     * the stack.
     *
     * Initially, each of the stacks contains one matrix, an identity matrix.
     *
     * It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In
     * either case, the error flag is set and no other change is made to GL state.
     *
     * @see http://docs.gl/gl2/glLoadMatrix
     * @see http://docs.gl/gl2/glPushMatrix
     * @since 1.1
     * @return void
     */
    public function popMatrix(): void
    {
        $this->info->ffi->glPopMatrix();
    }

    /**
     * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It
     * consists of an ordered set of unsigned integers and is initially empty.
     *
     * {@see GL46::glPushName} causes $name to be pushed onto the name stack. {@see GL46::glPopName} pops one name
     * off the top of the stack.
     *
     * The maximum name stack depth is implementation-dependent; call {@see GL46::GL_MAX_NAME_STACK_DEPTH} to find
     * out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a
     * name off an empty stack. It is also an error to manipulate the name stack between the execution of
     * {@see GL46::glBegin} and the corresponding execution of {@see GL46::glEnd}. In any of these cases, the error
     * flag is set and no other change is made to GL state.
     *
     * The name stack is always empty while the render mode is not {@see GL46::GL_SELECT}. Calls to
     * {@see GL46::glPushName} or {@see GL46::glPopName} while the render mode is not {@see GL46::GL_SELECT} are
     * ignored.
     *
     * @see http://docs.gl/gl2/glLoadName
     * @see http://docs.gl/gl2/glPushName
     * @since 1.1
     * @return void
     */
    public function popName(): void
    {
        $this->info->ffi->glPopName();
    }

    /**
     * {@see GL46::glPrioritizeTextures} assigns the $n texture priorities given in $priorities to the $n textures
     * named in $textures.
     *
     * The GL establishes a ``working set'' of textures that are resident in texture memory. These textures may be
     * bound to a texture target much more efficiently than textures that are not resident. By specifying a priority
     * for each texture, {@see GL46::glPrioritizeTextures} allows applications to guide the GL implementation in
     * determining which textures should be resident.
     *
     * The priorities given in $priorities are clamped to the range    0 1   before they are assigned. 0 indicates
     * the lowest priority; textures with priority 0 are least likely to be resident. 1 indicates the highest
     * priority; textures with priority 1 are most likely to be resident. However, textures are not guaranteed to be
     * resident until they are used.
     *
     * {@see GL46::glPrioritizeTextures} silently ignores attempts to prioritize texture 0 or any texture name that
     * does not correspond to an existing texture.
     *
     * {@see GL46::glPrioritizeTextures} does not require that any of the textures named by $textures be bound to a
     * texture target. {@see GL46::glTexParameter} may also be used to set a texture's priority, but only if the
     * texture is currently bound. This is the only way to set the priority of a default texture.
     *
     * @see http://docs.gl/gl2/glPrioritizeTextures
     * @since 1.1
     * @param int $n
     * @param \FFI\CData|null $textures
     * @param \FFI\CData|null $priorities
     * @return void
     */
    public function prioritizeTextures(int $n, ?\FFI\CData $textures, ?\FFI\CData $priorities): void
    {
        $this->info->ffi->glPrioritizeTextures($n, $textures, $priorities);
    }

    /**
     * {@see GL46::glPushAttrib} takes one argument, a mask that indicates which groups of state variables to save on
     * the attribute stack. Symbolic constants are used to set bits in the mask. $mask is typically constructed by
     * specifying the bitwise-or of several of these constants together. The special mask
     * {@see GL46::GL_ALL_ATTRIB_BITS} can be used to save all stackable states.
     *
     * The symbolic mask constants and their associated GL state are as follows (the second column lists which
     * attributes are saved):
     *
     * | {@see GL46::GL_ACCUM_BUFFER_BIT}    | Accumulation buffer clear value                                                     |
     * | {@see GL46::GL_COLOR_BUFFER_BIT}    | {@see GL46::GL_ALPHA_TEST} enable bit                                               |
     * |                                     | Alpha test function and reference value                                             |
     * |                                     | {@see GL46::GL_BLEND} enable bit                                                    |
     * |                                     | Blending source and destination functions                                           |
     * |                                     | Constant blend color                                                                |
     * |                                     | Blending equation                                                                   |
     * |                                     | {@see GL46::GL_DITHER} enable bit                                                   |
     * |                                     | {@see GL46::GL_DRAW_BUFFER} setting                                                 |
     * |                                     | {@see GL46::GL_COLOR_LOGIC_OP} enable bit                                           |
     * |                                     | {@see GL46::GL_INDEX_LOGIC_OP} enable bit                                           |
     * |                                     | Logic op function                                                                   |
     * |                                     | Color mode and index mode clear values                                              |
     * |                                     | Color mode and index mode writemasks                                                |
     * | {@see GL46::GL_CURRENT_BIT}         | Current RGBA color                                                                  |
     * |                                     | Current color index                                                                 |
     * |                                     | Current normal vector                                                               |
     * |                                     | Current texture coordinates                                                         |
     * |                                     | Current raster position                                                             |
     * |                                     | {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag                                  |
     * |                                     | RGBA color associated with current raster position                                  |
     * |                                     | Color index associated with current raster position                                 |
     * |                                     | Texture coordinates associated with current raster position                         |
     * |                                     | {@see GL46::GL_EDGE_FLAG} flag                                                      |
     * | {@see GL46::GL_DEPTH_BUFFER_BIT}    | {@see GL46::GL_DEPTH_TEST} enable bit                                               |
     * |                                     | Depth buffer test function                                                          |
     * |                                     | Depth buffer clear value                                                            |
     * |                                     | {@see GL46::GL_DEPTH_WRITEMASK} enable bit                                          |
     * | {@see GL46::GL_ENABLE_BIT}          | {@see GL46::GL_ALPHA_TEST} flag                                                     |
     * |                                     | {@see GL46::GL_AUTO_NORMAL} flag                                                    |
     * |                                     | {@see GL46::GL_BLEND} flag                                                          |
     * |                                     | Enable bits for the user-definable clipping planes                                  |
     * |                                     | {@see GL46::GL_COLOR_MATERIAL}                                                      |
     * |                                     | {@see GL46::GL_CULL_FACE} flag                                                      |
     * |                                     | {@see GL46::GL_DEPTH_TEST} flag                                                     |
     * |                                     | {@see GL46::GL_DITHER} flag                                                         |
     * |                                     | {@see GL46::GL_FOG} flag                                                            |
     * |                                     | {@see GL46::GL_LIGHT}i where {@see GL46::0} &lt;= i &lt; {@see GL46::GL_MAX_LIGHTS} |
     * |                                     | {@see GL46::GL_LIGHTING} flag                                                       |
     * |                                     | {@see GL46::GL_LINE_SMOOTH} flag                                                    |
     * |                                     | {@see GL46::GL_LINE_STIPPLE} flag                                                   |
     * |                                     | {@see GL46::GL_COLOR_LOGIC_OP} flag                                                 |
     * |                                     | {@see GL46::GL_INDEX_LOGIC_OP} flag                                                 |
     * |                                     | {@see GL46::GL_MAP1_}x where x is a map type                                        |
     * |                                     | {@see GL46::GL_MAP2_}x where x is a map type                                        |
     * |                                     | {@see GL46::GL_MULTISAMPLE} flag                                                    |
     * |                                     | {@see GL46::GL_NORMALIZE} flag                                                      |
     * |                                     | {@see GL46::GL_POINT_SMOOTH} flag                                                   |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_LINE} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FILL} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_POINT} flag                                           |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH} flag                                                 |
     * |                                     | {@see GL46::GL_POLYGON_STIPPLE} flag                                                |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE} flag                                       |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_ONE} flag                                            |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE} flag                                                |
     * |                                     | {@see GL46::GL_SCISSOR_TEST} flag                                                   |
     * |                                     | {@see GL46::GL_STENCIL_TEST} flag                                                   |
     * |                                     | {@see GL46::GL_TEXTURE_1D} flag                                                     |
     * |                                     | {@see GL46::GL_TEXTURE_2D} flag                                                     |
     * |                                     | {@see GL46::GL_TEXTURE_3D} flag                                                     |
     * |                                     | Flags {@see GL46::GL_TEXTURE_GEN_}x where x is S, T, R, or Q                        |
     * | {@see GL46::GL_EVAL_BIT}            | {@see GL46::GL_MAP1_}x enable bits, where x is a map type                           |
     * |                                     | {@see GL46::GL_MAP2_}x enable bits, where x is a map type                           |
     * |                                     | 1D grid endpoints and divisions                                                     |
     * |                                     | 2D grid endpoints and divisions                                                     |
     * |                                     | {@see GL46::GL_AUTO_NORMAL} enable bit                                              |
     * | {@see GL46::GL_FOG_BIT}             | {@see GL46::GL_FOG} enable bit                                                      |
     * |                                     | Fog color                                                                           |
     * |                                     | Fog density                                                                         |
     * |                                     | Linear fog start                                                                    |
     * |                                     | Linear fog end                                                                      |
     * |                                     | Fog index                                                                           |
     * |                                     | {@see GL46::GL_FOG_MODE} value                                                      |
     * | {@see GL46::GL_HINT_BIT}            | {@see GL46::GL_PERSPECTIVE_CORRECTION_HINT} setting                                 |
     * |                                     | {@see GL46::GL_POINT_SMOOTH_HINT} setting                                           |
     * |                                     | {@see GL46::GL_LINE_SMOOTH_HINT} setting                                            |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH_HINT} setting                                         |
     * |                                     | {@see GL46::GL_FOG_HINT} setting                                                    |
     * |                                     | {@see GL46::GL_GENERATE_MIPMAP_HINT} setting                                        |
     * |                                     | {@see GL46::GL_TEXTURE_COMPRESSION_HINT} setting                                    |
     * | {@see GL46::GL_LIGHTING_BIT}        | {@see GL46::GL_COLOR_MATERIAL} enable bit                                           |
     * |                                     | {@see GL46::GL_COLOR_MATERIAL_FACE} value                                           |
     * |                                     | Color material parameters that are tracking the current color                       |
     * |                                     | Ambient scene color                                                                 |
     * |                                     | {@see GL46::GL_LIGHT_MODEL_LOCAL_VIEWER} value                                      |
     * |                                     | {@see GL46::GL_LIGHT_MODEL_TWO_SIDE} setting                                        |
     * |                                     | {@see GL46::GL_LIGHTING} enable bit                                                 |
     * |                                     | Enable bit for each light                                                           |
     * |                                     | Ambient, diffuse, and specular intensity for each light                             |
     * |                                     | Direction, position, exponent, and cutoff angle for each light                      |
     * |                                     | Constant, linear, and quadratic attenuation factors for each light                  |
     * |                                     | Ambient, diffuse, specular, and emissive color for each material                    |
     * |                                     | Ambient, diffuse, and specular color indices for each material                      |
     * |                                     | Specular exponent for each material                                                 |
     * |                                     | {@see GL46::GL_SHADE_MODEL} setting                                                 |
     * | {@see GL46::GL_LINE_BIT}            | {@see GL46::GL_LINE_SMOOTH} flag                                                    |
     * |                                     | {@see GL46::GL_LINE_STIPPLE} enable bit                                             |
     * |                                     | Line stipple pattern and repeat counter                                             |
     * |                                     | Line width                                                                          |
     * | {@see GL46::GL_LIST_BIT}            | {@see GL46::GL_LIST_BASE} setting                                                   |
     * | {@see GL46::GL_MULTISAMPLE_BIT}     | {@see GL46::GL_MULTISAMPLE} flag                                                    |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_COVERAGE} flag                                       |
     * |                                     | {@see GL46::GL_SAMPLE_ALPHA_TO_ONE} flag                                            |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE} flag                                                |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE_VALUE} value                                         |
     * |                                     | {@see GL46::GL_SAMPLE_COVERAGE_INVERT} value                                        |
     * | {@see GL46::GL_PIXEL_MODE_BIT}      | {@see GL46::GL_RED_BIAS} and {@see GL46::GL_RED_SCALE} settings                     |
     * |                                     | {@see GL46::GL_GREEN_BIAS} and {@see GL46::GL_GREEN_SCALE} values                   |
     * |                                     | {@see GL46::GL_BLUE_BIAS} and {@see GL46::GL_BLUE_SCALE}                            |
     * |                                     | {@see GL46::GL_ALPHA_BIAS} and {@see GL46::GL_ALPHA_SCALE}                          |
     * |                                     | {@see GL46::GL_DEPTH_BIAS} and {@see GL46::GL_DEPTH_SCALE}                          |
     * |                                     | {@see GL46::GL_INDEX_OFFSET} and {@see GL46::GL_INDEX_SHIFT} values                 |
     * |                                     | {@see GL46::GL_MAP_COLOR} and {@see GL46::GL_MAP_STENCIL} flags                     |
     * |                                     | {@see GL46::GL_ZOOM_X} and {@see GL46::GL_ZOOM_Y} factors                           |
     * |                                     | {@see GL46::GL_READ_BUFFER} setting                                                 |
     * | {@see GL46::GL_POINT_BIT}           | {@see GL46::GL_POINT_SMOOTH} flag                                                   |
     * |                                     | Point size                                                                          |
     * | {@see GL46::GL_POLYGON_BIT}         | {@see GL46::GL_CULL_FACE} enable bit                                                |
     * |                                     | {@see GL46::GL_CULL_FACE_MODE} value                                                |
     * |                                     | {@see GL46::GL_FRONT_FACE} indicator                                                |
     * |                                     | {@see GL46::GL_POLYGON_MODE} setting                                                |
     * |                                     | {@see GL46::GL_POLYGON_SMOOTH} flag                                                 |
     * |                                     | {@see GL46::GL_POLYGON_STIPPLE} enable bit                                          |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FILL} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_LINE} flag                                            |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_POINT} flag                                           |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_FACTOR}                                               |
     * |                                     | {@see GL46::GL_POLYGON_OFFSET_UNITS}                                                |
     * | {@see GL46::GL_POLYGON_STIPPLE_BIT} | Polygon stipple image                                                               |
     * | {@see GL46::GL_SCISSOR_BIT}         | {@see GL46::GL_SCISSOR_TEST} flag                                                   |
     * |                                     | Scissor box                                                                         |
     * | {@see GL46::GL_STENCIL_BUFFER_BIT}  | {@see GL46::GL_STENCIL_TEST} enable bit                                             |
     * |                                     | Stencil function and reference value                                                |
     * |                                     | Stencil value mask                                                                  |
     * |                                     | Stencil fail, pass, and depth buffer pass actions                                   |
     * |                                     | Stencil buffer clear value                                                          |
     * |                                     | Stencil buffer writemask                                                            |
     * | {@see GL46::GL_TEXTURE_BIT}         | Enable bits for the four texture coordinates                                        |
     * |                                     | Border color for each texture image                                                 |
     * |                                     | Minification function for each texture image                                        |
     * |                                     | Magnification function for each texture image                                       |
     * |                                     | Texture coordinates and wrap mode for each texture image                            |
     * |                                     | Color and mode for each texture environment                                         |
     * |                                     | Enable bits {@see GL46::GL_TEXTURE_GEN_}x, x is S, T, R, and Q                      |
     * |                                     | {@see GL46::GL_TEXTURE_GEN_MODE} setting for S, T, R, and Q                         |
     * |                                     | {@see GL46::glTexGen} plane equations for S, T, R, and Q                            |
     * |                                     | Current texture bindings (for example, {@see GL46::GL_TEXTURE_BINDING_2D})          |
     * | {@see GL46::GL_TRANSFORM_BIT}       | Coefficients of the six clipping planes                                             |
     * |                                     | Enable bits for the user-definable clipping planes                                  |
     * |                                     | {@see GL46::GL_MATRIX_MODE} value                                                   |
     * |                                     | {@see GL46::GL_NORMALIZE} flag                                                      |
     * |                                     | {@see GL46::GL_RESCALE_NORMAL} flag                                                 |
     * | {@see GL46::GL_VIEWPORT_BIT}        | Depth range (near and far)                                                          |
     * |                                     | Viewport origin and extent                                                          |
     * {@see GL46::glPopAttrib} restores the values of the state variables saved with the last
     * {@see GL46::glPushAttrib} command. Those not saved are left unchanged.
     *
     * It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case,
     * the error flag is set and no other change is made to GL state.
     *
     * Initially, the attribute stack is empty.
     *
     * @see http://docs.gl/gl2/glPushAttrib
     * @since 1.1
     * @param int $mask
     * @return void
     */
    public function pushAttrib(int $mask): void
    {
        $this->info->ffi->glPushAttrib($mask);
    }

    /**
     * {@see GL46::glPushClientAttrib} takes one argument, a mask that indicates which groups of client-state
     * variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. $mask is
     * typically constructed by specifying the bitwise-or of several of these constants together. The special mask
     * {@see GL46::GL_CLIENT_ALL_ATTRIB_BITS} can be used to save all stackable client state.
     *
     * The symbolic mask constants and their associated GL client state are as follows (the second column lists which
     * attributes are saved):
     *
     * {@see GL46::GL_CLIENT_PIXEL_STORE_BIT} Pixel storage modes {@see GL46::GL_CLIENT_VERTEX_ARRAY_BIT} Vertex
     * arrays (and enables)
     *
     * {@see GL46::glPopClientAttrib} restores the values of the client-state variables saved with the last
     * {@see GL46::glPushClientAttrib}. Those not saved are left unchanged.
     *
     * It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack.
     * In either case, the error flag is set, and no other change is made to GL state.
     *
     * Initially, the client attribute stack is empty.
     *
     * @see http://docs.gl/gl2/glPushClientAttrib
     * @since 1.1
     * @param int $mask
     * @return void
     */
    public function pushClientAttrib(int $mask): void
    {
        $this->info->ffi->glPushClientAttrib($mask);
    }

    /**
     * There is a stack of matrices for each of the matrix modes. In {@see GL46::GL_MODELVIEW} mode, the stack depth
     * is at least 32. In the other modes, {@see GL46::GL_COLOR}, {@see GL46::GL_PROJECTION}, and
     * {@see GL46::GL_TEXTURE}, the depth is at least 2. The current matrix in any mode is the matrix on the top of
     * the stack for that mode.
     *
     * {@see GL46::glPushMatrix} pushes the current matrix stack down by one, duplicating the current matrix. That
     * is, after a {@see GL46::glPushMatrix} call, the matrix on top of the stack is identical to the one below it.
     *
     * {@see GL46::glPopMatrix} pops the current matrix stack, replacing the current matrix with the one below it on
     * the stack.
     *
     * Initially, each of the stacks contains one matrix, an identity matrix.
     *
     * It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In
     * either case, the error flag is set and no other change is made to GL state.
     *
     * @see http://docs.gl/gl2/glPushMatrix
     * @since 1.1
     * @return void
     */
    public function pushMatrix(): void
    {
        $this->info->ffi->glPushMatrix();
    }

    /**
     * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It
     * consists of an ordered set of unsigned integers and is initially empty.
     *
     * {@see GL46::glPushName} causes $name to be pushed onto the name stack. {@see GL46::glPopName} pops one name
     * off the top of the stack.
     *
     * The maximum name stack depth is implementation-dependent; call {@see GL46::GL_MAX_NAME_STACK_DEPTH} to find
     * out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a
     * name off an empty stack. It is also an error to manipulate the name stack between the execution of
     * {@see GL46::glBegin} and the corresponding execution of {@see GL46::glEnd}. In any of these cases, the error
     * flag is set and no other change is made to GL state.
     *
     * The name stack is always empty while the render mode is not {@see GL46::GL_SELECT}. Calls to
     * {@see GL46::glPushName} or {@see GL46::glPopName} while the render mode is not {@see GL46::GL_SELECT} are
     * ignored.
     *
     * @see http://docs.gl/gl2/glPushName
     * @since 1.1
     * @param int $name
     * @return void
     */
    public function pushName(int $name): void
    {
        $this->info->ffi->glPushName($name);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @return void
     */
    public function rasterPos2d(float $x, float $y): void
    {
        $this->info->ffi->glRasterPos2d($x, $y);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos2dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos2dv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @return void
     */
    public function rasterPos2f(float $x, float $y): void
    {
        $this->info->ffi->glRasterPos2f($x, $y);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos2fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos2fv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @return void
     */
    public function rasterPos2i(int $x, int $y): void
    {
        $this->info->ffi->glRasterPos2i($x, $y);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos2iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos2iv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @return void
     */
    public function rasterPos2s(int $x, int $y): void
    {
        $this->info->ffi->glRasterPos2s($x, $y);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos2sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos2sv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function rasterPos3d(float $x, float $y, float $z): void
    {
        $this->info->ffi->glRasterPos3d($x, $y, $z);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos3dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos3dv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function rasterPos3f(float $x, float $y, float $z): void
    {
        $this->info->ffi->glRasterPos3f($x, $y, $z);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos3fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos3fv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @return void
     */
    public function rasterPos3i(int $x, int $y, int $z): void
    {
        $this->info->ffi->glRasterPos3i($x, $y, $z);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos3iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos3iv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @return void
     */
    public function rasterPos3s(int $x, int $y, int $z): void
    {
        $this->info->ffi->glRasterPos3s($x, $y, $z);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos3sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos3sv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @param float $w
     * @return void
     */
    public function rasterPos4d(float $x, float $y, float $z, float $w): void
    {
        $this->info->ffi->glRasterPos4d($x, $y, $z, $w);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos4dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos4dv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @param float $w
     * @return void
     */
    public function rasterPos4f(float $x, float $y, float $z, float $w): void
    {
        $this->info->ffi->glRasterPos4f($x, $y, $z, $w);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos4fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos4fv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @param int $w
     * @return void
     */
    public function rasterPos4i(int $x, int $y, int $z, int $w): void
    {
        $this->info->ffi->glRasterPos4i($x, $y, $z, $w);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos4iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos4iv($v);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @param int $w
     * @return void
     */
    public function rasterPos4s(int $x, int $y, int $z, int $w): void
    {
        $this->info->ffi->glRasterPos4s($x, $y, $z, $w);
    }

    /**
     * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to
     * position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
     * {@see GL46::glBitmap}, {@see GL46::glDrawPixels}, and {@see GL46::glCopyPixels}.
     *
     * The current raster position consists of three window coordinates (x, y, z), a clip coordinate value (w), an
     * eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a
     * clip coordinate, because w is not projected to window coordinates. {@see GL46::glRasterPos4} specifies object
     * coordinates x, y, z, and w explicitly. {@see GL46::glRasterPos3} specifies object coordinate x, y, and z
     * explicitly, while w is implicitly set to 1. {@see GL46::glRasterPos2} uses the argument values for x and y
     * while implicitly setting z and w to 0 and 1.
     *
     * The object coordinates presented by {@see GL46::glRasterPos} are treated just like those of a
     * {@see GL46::glVertex} command: They are transformed by the current modelview and projection matrices and
     * passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window
     * coordinates, which become the new current raster position, and the
     * {@see GL46::GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex is culled, then the valid bit is
     * cleared and the current raster position and associated color and texture coordinates are undefined.
     *
     * The current raster position also includes some associated color data and texture coordinates. If lighting is
     * enabled, then {@see GL46::GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@see GL46::GL_CURRENT_RASTER_INDEX} (in
     * color index mode) is set to the color produced by the lighting calculation (see {@see GL46::glLight},
     * {@see GL46::glLightModel}, and {@see GL46::glShadeModel}). If lighting is disabled, current color (in RGBA
     * mode, state variable {@see GL46::GL_CURRENT_COLOR}) or color index (in color index mode, state variable
     * {@see GL46::GL_CURRENT_INDEX}) is used to update the current raster color.
     * {@see GL46::GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
     *
     * Likewise, {@see GL46::GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of
     * {@see GL46::GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see
     * {@see GL46::glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as
     * transformed by only the modelview matrix replaces {@see GL46::GL_CURRENT_RASTER_DISTANCE}.
     *
     * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is
     * set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture
     * coordinates are (0, 0, 0, 1). In RGBA mode, {@see GL46::GL_CURRENT_RASTER_INDEX} is always 1; in color index
     * mode, the current raster RGBA color always maintains its initial value.
     *
     * @see http://docs.gl/gl2/glRasterPos
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function rasterPos4sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glRasterPos4sv($v);
    }

    /**
     * {@see GL46::glReadBuffer} specifies a color buffer as the source for subsequent {@see GL46::glReadPixels},
     * {@see GL46::glCopyTexImage1D}, {@see GL46::glCopyTexImage2D}, {@see GL46::glCopyTexSubImage1D},
     * {@see GL46::glCopyTexSubImage2D}, and {@see GL46::glCopyTexSubImage3D} commands. $mode accepts one of twelve
     * or more predefined values. In a fully configured system, {@see GL46::GL_FRONT}, {@see GL46::GL_LEFT}, and
     * {@see GL46::GL_FRONT_LEFT} all name the front left buffer, {@see GL46::GL_FRONT_RIGHT} and
     * {@see GL46::GL_RIGHT} name the front right buffer, and {@see GL46::GL_BACK_LEFT} and {@see GL46::GL_BACK} name
     * the back left buffer. Further more, the constants {@see GL46::GL_COLOR_ATTACHMENT}i may be used to indicate
     * the ith color attachment where i ranges from zero to the value of {@see GL46::GL_MAX_COLOR_ATTACHMENTS} minus
     * one.
     *
     * Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered
     * configurations have a front left and a front right buffer if stereo, and only a front left buffer if
     * nonstereo. It is an error to specify a nonexistent buffer to {@see GL46::glReadBuffer}.
     *
     * $mode is initially {@see GL46::GL_FRONT} in single-buffered configurations and {@see GL46::GL_BACK} in
     * double-buffered configurations.
     *
     * For {@see GL46::glReadBuffer}, the target framebuffer object is that bound to
     * {@see GL46::GL_READ_FRAMEBUFFER}. For {@see GL46::glNamedFramebufferReadBuffer}, $framebuffer must either be
     * zero or the name of the target framebuffer object. If $framebuffer is zero, then the default read framebuffer
     * is affected.
     *
     * @see http://docs.gl/gl2/glReadBuffer
     * @see http://docs.gl/gl4/glReadBuffer
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function readBuffer(int $mode): void
    {
        $this->info->ffi->glReadBuffer($mode);
    }

    /**
     * {@see GL46::glReadPixels} and {@see GL46::glReadnPixels} return pixel data from the frame buffer, starting
     * with the pixel whose lower left corner is at location ($x, $y), into client memory starting at location $data.
     * Several parameters control the processing of the pixel data before it is placed into client memory. These
     * parameters are set with {@see GL46::glPixelStore}. This reference page describes the effects on
     * {@see GL46::glReadPixels} and {@see GL46::glReadnPixels} of most, but not all of the parameters specified by
     * these three commands.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_PACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a block of pixels is requested, $data is treated as a byte offset into the
     * buffer object's data store rather than a pointer to client memory.
     *
     * {@see GL46::glReadPixels} and {@see GL46::glReadnPixels} return values from each pixel with lower left corner
     * at     x + i   y + j    for    0 &lt;= i &lt; width   and    0 &lt;= j &lt; height  . This pixel is said to be
     * the ith pixel in the jth row. Pixels are returned in row order from the lowest to the highest row, left to
     * right in each row.
     *
     * $format specifies the format for the returned pixel values; accepted values are:
     *
     *  - {@see GL46::GL_STENCIL_INDEX}: Stencil values are read from the
     *    stencil buffer.
     *
     *  - {@see GL46::GL_DEPTH_COMPONENT}: Depth values are read from the depth
     *    buffer. Each component is converted to floating point such that the
     *    minimum depth value maps to 0 and the maximum value maps to 1. Each
     *    component is clamped to the range    0 1
     *    .
     *
     *  - {@see GL46::GL_DEPTH_STENCIL}: Values are taken from both the depth
     *    and stencil buffers. The $type parameter must be
     *    {@see GL46::GL_UNSIGNED_INT_24_8} or {@see
     *    GL46::GL_FLOAT_32_UNSIGNED_INT_24_8_REV}.
     *
     *  - {@see GL46::GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA,
     *    GL_BGRA}: Color values are taken from the color buffer.
     *
     * Finally, the indices or components are converted to the proper format, as specified by $type. If $format is
     * {@see GL46::GL_STENCIL_INDEX} and $type is not {@see GL46::GL_FLOAT}, each index is masked with the mask value
     * given in the following table. If $type is {@see GL46::GL_FLOAT}, then each integer index is converted to
     * single-precision floating-point format.
     *
     * If $format is {@see GL46::GL_RED}, {@see GL46::GL_GREEN}, {@see GL46::GL_BLUE}, {@see GL46::GL_RGB},
     * {@see GL46::GL_BGR}, {@see GL46::GL_RGBA}, or {@see GL46::GL_BGRA} and $type is not {@see GL46::GL_FLOAT},
     * each component is multiplied by the multiplier shown in the following table. If type is {@see GL46::GL_FLOAT},
     * then each component is passed as is (or converted to the client's single-precision floating-point format if it
     * is different from the one used by the GL).
     *
     * | {@see GL46::GL_UNSIGNED_BYTE}                  |    2 8  - 1  |      2 8  - 1   &amp;it; c            |
     * | {@see GL46::GL_BYTE}                           |    2 7  - 1  |        2 8  - 1   &amp;it; c - 1   2  |
     * | {@see GL46::GL_UNSIGNED_SHORT}                 |    2 16  - 1 |      2 16  - 1   &amp;it; c           |
     * | {@see GL46::GL_SHORT}                          |    2 15  - 1 |        2 16  - 1   &amp;it; c - 1   2 |
     * | {@see GL46::GL_UNSIGNED_INT}                   |    2 32  - 1 |      2 32  - 1   &amp;it; c           |
     * | {@see GL46::GL_INT}                            |    2 31  - 1 |        2 32  - 1   &amp;it; c - 1   2 |
     * | {@see GL46::GL_HALF_FLOAT}                     | none         | c                                     |
     * | {@see GL46::GL_FLOAT}                          | none         | c                                     |
     * | {@see GL46::GL_UNSIGNED_BYTE_3_3_2}            |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_BYTE_2_3_3_REV}        |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_5_6_5}           |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_5_6_5_REV}       |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4}         |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_4_4_4_4_REV}     |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_5_5_5_1}         |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_SHORT_1_5_5_5_REV}     |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_8_8_8_8}           |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_8_8_8_8_REV}       |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_10_10_10_2}        |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_2_10_10_10_REV}    |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_24_8}              |    2 N  - 1  |      2 N  - 1   &amp;it; c            |
     * | {@see GL46::GL_UNSIGNED_INT_10F_11F_11F_REV}   | --           | Special                               |
     * | {@see GL46::GL_UNSIGNED_INT_5_9_9_9_REV}       | --           | Special                               |
     * | {@see GL46::GL_FLOAT_32_UNSIGNED_INT_24_8_REV} | none         | c (Depth Only)                        |
     * Return values are placed in memory as follows. If $format is {@see GL46::GL_STENCIL_INDEX},
     * {@see GL46::GL_DEPTH_COMPONENT}, {@see GL46::GL_RED}, {@see GL46::GL_GREEN}, or {@see GL46::GL_BLUE}, a single
     * value is returned and the data for the ith pixel in the jth row is placed in location     j  &amp;it; width +
     * i  . {@see GL46::GL_RGB} and {@see GL46::GL_BGR} return three values, {@see GL46::GL_RGBA} and
     * {@see GL46::GL_BGRA} return four values for each pixel, with all values corresponding to a single pixel
     * occupying contiguous space in $data. Storage parameters set by {@see GL46::glPixelStore}, such as
     * {@see GL46::GL_PACK_LSB_FIRST} and {@see GL46::GL_PACK_SWAP_BYTES}, affect the way that data is written into
     * memory. See {@see GL46::glPixelStore}  for a description.
     *
     * {@see GL46::glReadnPixels} function will only handle the call if $bufSize is at least of the size required to
     * store the requested data. Otherwise, it will generate a {@see GL46::GL_INVALID_OPERATION} error.
     *
     * @see http://docs.gl/gl2/glReadPixels
     * @see http://docs.gl/gl4/glReadPixels
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function readPixels(int $x, int $y, int $width, int $height, int $format, int $type, ?\FFI\CData $pixels): void
    {
        $this->info->ffi->glReadPixels($x, $y, $width, $height, $format, $type, $pixels);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param float $x1
     * @param float $y1
     * @param float $x2
     * @param float $y2
     * @return void
     */
    public function rectd(float $x1, float $y1, float $x2, float $y2): void
    {
        $this->info->ffi->glRectd($x1, $y1, $x2, $y2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param \FFI\CData|null $v1
     * @param \FFI\CData|null $v2
     * @return void
     */
    public function rectdv(?\FFI\CData $v1, ?\FFI\CData $v2): void
    {
        $this->info->ffi->glRectdv($v1, $v2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param float $x1
     * @param float $y1
     * @param float $x2
     * @param float $y2
     * @return void
     */
    public function rectf(float $x1, float $y1, float $x2, float $y2): void
    {
        $this->info->ffi->glRectf($x1, $y1, $x2, $y2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param \FFI\CData|null $v1
     * @param \FFI\CData|null $v2
     * @return void
     */
    public function rectfv(?\FFI\CData $v1, ?\FFI\CData $v2): void
    {
        $this->info->ffi->glRectfv($v1, $v2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param int $x1
     * @param int $y1
     * @param int $x2
     * @param int $y2
     * @return void
     */
    public function recti(int $x1, int $y1, int $x2, int $y2): void
    {
        $this->info->ffi->glRecti($x1, $y1, $x2, $y2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param \FFI\CData|null $v1
     * @param \FFI\CData|null $v2
     * @return void
     */
    public function rectiv(?\FFI\CData $v1, ?\FFI\CData $v2): void
    {
        $this->info->ffi->glRectiv($v1, $v2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param int $x1
     * @param int $y1
     * @param int $x2
     * @param int $y2
     * @return void
     */
    public function rects(int $x1, int $y1, int $x2, int $y2): void
    {
        $this->info->ffi->glRects($x1, $y1, $x2, $y2);
    }

    /**
     * {@see GL46::glRect} supports efficient specification of rectangles as two corner points. Each rectangle
     * command takes four arguments, organized either as two consecutive pairs of    x y   coordinates or as two
     * pointers to arrays, each containing an    x y   pair. The resulting rectangle is defined in the    z = 0
     * plane.
     *
     * {@see GL46::glRect}($x1, $y1, $x2, $y2) is exactly equivalent to the following sequence:
     *
     * <code>
     *
     * glBegin({@see GL46::GL_POLYGON});
     * glVertex2($x1, $y1);
     * glVertex2($x2, $y1);
     * glVertex2($x2, $y2);
     * glVertex2($x1, $y2);
     * glEnd();
     *
     * </code>
     *
     *  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed
     * with a counterclockwise winding.
     *
     * @see http://docs.gl/gl2/glRect
     * @since 1.1
     * @param \FFI\CData|null $v1
     * @param \FFI\CData|null $v2
     * @return void
     */
    public function rectsv(?\FFI\CData $v1, ?\FFI\CData $v2): void
    {
        $this->info->ffi->glRectsv($v1, $v2);
    }

    /**
     * {@see GL46::glRenderMode} sets the rasterization mode. It takes one argument, $mode, which can assume one of
     * three predefined values:
     *
     *  - {@see GL46::GL_RENDER}: Render mode. Primitives are rasterized,
     *    producing pixel fragments, which are written into the frame buffer.
     *    This is the normal mode and also the default mode.
     *
     *  - {@see GL46::GL_SELECT}: Selection mode. No pixel fragments are
     *    produced, and no change to the frame buffer contents is made. Instead,
     *    a record of the names of primitives that would have been drawn if the
     *    render mode had been
     *    {@see GL46::GL_RENDER} is returned in a select buffer, which must be
     *    created (see {@see GL46::glSelectBuffer})
     *    before selection mode is entered.
     *
     *  - {@see GL46::GL_FEEDBACK}: Feedback mode. No pixel fragments are
     *    produced, and no change to the frame buffer contents is made. Instead,
     *    the coordinates and attributes of vertices that would have been drawn
     *    if the render mode had been
     *    {@see GL46::GL_RENDER} is returned in a feedback buffer, which must be
     *    created (see
     *    {@see GL46::glFeedbackBuffer}) before feedback mode is entered.
     *
     * The return value of {@see GL46::glRenderMode} is determined by the render mode at the time
     * {@see GL46::glRenderMode} is called, rather than by $mode. The values returned for the three render modes are
     * as follows:
     *
     *  - {@see GL46::GL_RENDER}: 0.
     *
     *  - {@see GL46::GL_SELECT}: The number of hit records transferred to the
     *    select buffer.
     *
     *  - {@see GL46::GL_FEEDBACK}: The number of values (not vertices)
     *    transferred to the feedback buffer.
     *
     * See the {@see GL46::glSelectBuffer} and {@see GL46::glFeedbackBuffer} reference pages for more details
     * concerning selection and feedback operation.
     *
     * @see http://docs.gl/gl2/glRenderMode
     * @since 1.1
     * @param int $mode
     * @return int
     */
    public function renderMode(int $mode): int
    {
        return $this->info->ffi->glRenderMode($mode);
    }

    /**
     * {@see GL46::glRotate} produces a rotation of $angle degrees around the vector    x y z  . The current matrix
     * (see {@see GL46::glMatrixMode}) is multiplied by a rotation matrix with the product replacing the current
     * matrix, as if {@see GL46::glMultMatrix} were called with the following matrix as its argument:
     *
     *         x 2  &amp;af;   1 - c    + c     x &amp;it;  y &amp;af;   1 - c    - z &amp;it; s     x &amp;it;  z
     * &amp;af;   1 - c    + y &amp;it; s    0      y &amp;it;  x &amp;af;   1 - c    + z &amp;it; s      y 2
     * &amp;af;   1 - c    + c     y &amp;it;  z &amp;af;   1 - c    - x &amp;it; s    0      x &amp;it;  z &amp;af;
     *  1 - c    - y &amp;it; s     y &amp;it;  z &amp;af;   1 - c    + x &amp;it; s      z 2  &amp;af;   1 - c    +
     * c    0     0   0   0   1
     *
     * Where    c =  cos &amp;af;  angle    ,    s =  sin &amp;af;  angle    , and
     * &amp;DoubleVerticalBar;&amp;DoubleVerticalBar;  x y z   = 1   (if not, the GL will normalize this vector).
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * {@see GL46::glRotate} is called are rotated. Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to
     * save and restore the unrotated coordinate system.
     *
     * @see http://docs.gl/gl2/glRotate
     * @since 1.1
     * @param float $angle
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function rotated(float $angle, float $x, float $y, float $z): void
    {
        $this->info->ffi->glRotated($angle, $x, $y, $z);
    }

    /**
     * {@see GL46::glRotate} produces a rotation of $angle degrees around the vector    x y z  . The current matrix
     * (see {@see GL46::glMatrixMode}) is multiplied by a rotation matrix with the product replacing the current
     * matrix, as if {@see GL46::glMultMatrix} were called with the following matrix as its argument:
     *
     *         x 2  &amp;af;   1 - c    + c     x &amp;it;  y &amp;af;   1 - c    - z &amp;it; s     x &amp;it;  z
     * &amp;af;   1 - c    + y &amp;it; s    0      y &amp;it;  x &amp;af;   1 - c    + z &amp;it; s      y 2
     * &amp;af;   1 - c    + c     y &amp;it;  z &amp;af;   1 - c    - x &amp;it; s    0      x &amp;it;  z &amp;af;
     *  1 - c    - y &amp;it; s     y &amp;it;  z &amp;af;   1 - c    + x &amp;it; s      z 2  &amp;af;   1 - c    +
     * c    0     0   0   0   1
     *
     * Where    c =  cos &amp;af;  angle    ,    s =  sin &amp;af;  angle    , and
     * &amp;DoubleVerticalBar;&amp;DoubleVerticalBar;  x y z   = 1   (if not, the GL will normalize this vector).
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * {@see GL46::glRotate} is called are rotated. Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to
     * save and restore the unrotated coordinate system.
     *
     * @see http://docs.gl/gl2/glRotate
     * @since 1.1
     * @param float $angle
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function rotatef(float $angle, float $x, float $y, float $z): void
    {
        $this->info->ffi->glRotatef($angle, $x, $y, $z);
    }

    /**
     * {@see GL46::glScale} produces a nonuniform scaling along the x, y, and z axes. The three parameters indicate
     * the desired scale factor along each of the three axes.
     *
     * The current matrix (see {@see GL46::glMatrixMode}) is multiplied by this scale matrix, and the product
     * replaces the current matrix as if {@see GL46::glMultMatrix} were called with the following matrix as its
     * argument:
     *
     *       x   0   0   0     0   y   0   0     0   0   z   0     0   0   0   1
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * {@see GL46::glScale} is called are scaled.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the unscaled coordinate system.
     *
     * @see http://docs.gl/gl2/glScale
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function scaled(float $x, float $y, float $z): void
    {
        $this->info->ffi->glScaled($x, $y, $z);
    }

    /**
     * {@see GL46::glScale} produces a nonuniform scaling along the x, y, and z axes. The three parameters indicate
     * the desired scale factor along each of the three axes.
     *
     * The current matrix (see {@see GL46::glMatrixMode}) is multiplied by this scale matrix, and the product
     * replaces the current matrix as if {@see GL46::glMultMatrix} were called with the following matrix as its
     * argument:
     *
     *       x   0   0   0     0   y   0   0     0   0   z   0     0   0   0   1
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * {@see GL46::glScale} is called are scaled.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the unscaled coordinate system.
     *
     * @see http://docs.gl/gl2/glScale
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function scalef(float $x, float $y, float $z): void
    {
        $this->info->ffi->glScalef($x, $y, $z);
    }

    /**
     * {@see GL46::glScissor} defines a rectangle, called the scissor box, in window coordinates. The first two
     * arguments, $x and $y, specify the lower left corner of the box. $width and $height specify the width and
     * height of the box.
     *
     * To enable and disable the scissor test, call {@see GL46::glEnable} and  {@see GL46::glDisable} with argument
     * {@see GL46::GL_SCISSOR_TEST}. The test is initially disabled. While the test is enabled, only pixels that lie
     * within the scissor box can be modified by drawing commands. Window coordinates have integer values at the
     * shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel
     * in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.
     *
     * When the scissor test is disabled, it is as though the scissor box includes the entire window.
     *
     * @see http://docs.gl/gl2/glScissor
     * @see http://docs.gl/gl4/glScissor
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @return void
     */
    public function scissor(int $x, int $y, int $width, int $height): void
    {
        $this->info->ffi->glScissor($x, $y, $width, $height);
    }

    /**
     * {@see GL46::glSelectBuffer} has two arguments: $buffer is a pointer to an array of unsigned integers, and
     * $size indicates the size of the array. $buffer returns values from the name stack (see
     * {@see GL46::glInitNames}, {@see GL46::glLoadName}, {@see GL46::glPushName}) when the rendering mode is
     * {@see GL46::GL_SELECT} (see {@see GL46::glRenderMode}). {@see GL46::glSelectBuffer} must be issued before
     * selection mode is enabled, and it must not be issued while the rendering mode is {@see GL46::GL_SELECT}.
     *
     * A programmer can use selection to determine which primitives are drawn into some region of a window. The
     * region is defined by the current modelview and perspective matrices.
     *
     * In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive or a raster
     * position intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes,
     * this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change
     * is made to the name stack, or when {@see GL46::glRenderMode} is called, a hit record is copied to $buffer if
     * any hits have occurred since the last such event (name stack change or {@see GL46::glRenderMode} call). The
     * hit record consists of the number of names in the name stack at the time of the event, followed by the minimum
     * and maximum depth values of all vertices that hit since the previous event, followed by the name stack
     * contents, bottom name first.
     *
     * Depth values (which are in the range [0,1]) are multiplied by    2 32  - 1  , before being placed in the hit
     * record.
     *
     * An internal index into $buffer is reset to 0 whenever selection mode is entered. Each time a hit record is
     * copied into $buffer, the index is incremented to point to the cell just past the end of the block of
     * names\\(emthat is, to the next available cell If the hit record is larger than the number of remaining
     * locations in $buffer, as much data as can fit is copied, and the overflow flag is set. If the name stack is
     * empty when a hit record is copied, that record consists of 0 followed by the minimum and maximum depth values.
     *
     * To exit selection mode, call {@see GL46::glRenderMode} with an argument other than {@see GL46::GL_SELECT}.
     * Whenever {@see GL46::glRenderMode} is called while the render mode is {@see GL46::GL_SELECT}, it returns the
     * number of hit records copied to $buffer, resets the overflow flag and the selection buffer pointer, and
     * initializes the name stack to be empty. If the overflow bit was set when {@see GL46::glRenderMode} was called,
     * a negative hit record count is returned.
     *
     * @see http://docs.gl/gl2/glSelectBuffer
     * @since 1.1
     * @param int $size
     * @param int|null $buffer
     * @return void
     */
    public function selectBuffer(int $size, ?int &$buffer): void
    {
        $bufferCType = $this->info->ffi->new('GLuint', false);
        try {
            $this->info->ffi->glSelectBuffer($size, \FFI::addr($bufferCType));
        } finally {
            $buffer = $bufferCType->cdata;
            \FFI::free($bufferCType);
        }
    }

    /**
     * GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors
     * of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each
     * resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the
     * pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is
     * the result of lighting if lighting is enabled, or it is the current color at the time the vertex was specified
     * if lighting is disabled.
     *
     * Flat and smooth shading are indistinguishable for points. Starting when {@see GL46::glBegin} is issued and
     * counting vertices and primitives from 1, the GL gives each flat-shaded line segment i the computed color of
     * vertex    i + 1  , its second vertex. Counting similarly from 1, the GL gives each flat-shaded polygon the
     * computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in
     * all cases except single polygons, where the first vertex specifies the flat-shaded color.
     *
     * | Single polygon (   i == 1  ) | 1                   |
     * | Triangle strip               |    i + 2            |
     * | Triangle fan                 |    i + 2            |
     * | Independent triangle         |    3 &amp;it; i     |
     * | Quad strip                   |    2 &amp;it; i + 2 |
     * | Independent quad             |    4 &amp;it; i     |
     * Flat and smooth shading are specified by {@see GL46::glShadeModel} with $mode set to {@see GL46::GL_FLAT} and
     * {@see GL46::GL_SMOOTH}, respectively.
     *
     * @see http://docs.gl/gl2/glShadeModel
     * @since 1.1
     * @param int $mode
     * @return void
     */
    public function shadeModel(int $mode): void
    {
        $this->info->ffi->glShadeModel($mode);
    }

    /**
     * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first
     * drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask
     * out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special
     * effects, such as decals, outlining, and constructive solid geometry rendering.
     *
     * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference
     * value and the value in the stencil buffer. To enable and disable the test, call {@see GL46::glEnable} and
     * {@see GL46::glDisable} with argument {@see GL46::GL_STENCIL_TEST}. To specify actions based on the outcome of
     * the stencil test, call {@see GL46::glStencilOp} or {@see GL46::glStencilOpSeparate}.
     *
     * There can be two separate sets of $func, $ref, and $mask parameters; one affects back-facing polygons, and the
     * other affects front-facing polygons as well as other non-polygon primitives. {@see GL46::glStencilFunc} sets
     * both front and back stencil state to the same values. Use {@see GL46::glStencilFuncSeparate} to set front and
     * back stencil state to different values.
     *
     * $func is a symbolic constant that determines the stencil comparison function. It accepts one of eight values,
     * shown in the following list. $ref is an integer reference value that is used in the stencil comparison. It is
     * clamped to the range    0  2 n  - 1   , where n is the number of bitplanes in the stencil buffer. $mask is
     * bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating
     * in the comparison.
     *
     * If stencil represents the value stored in the corresponding stencil buffer location, the following list shows
     * the effect of each comparison function that can be specified by $func. Only if the comparison succeeds is the
     * pixel passed through to the next stage in the rasterization process (see {@see GL46::glStencilOp}). All tests
     * treat stencil values as unsigned integers in the range    0  2 n  - 1   , where n is the number of bitplanes
     * in the stencil buffer.
     *
     * The following values are accepted by $func:
     *
     *  - {@see GL46::GL_NEVER}: Always fails.
     *
     *  - {@see GL46::GL_LESS}: Passes if ( $ref &amp; $mask ) &lt; ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_LEQUAL}: Passes if ( $ref &amp; $mask ) &lt;= ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_GREATER}: Passes if ( $ref &amp; $mask ) &gt; ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_GEQUAL}: Passes if ( $ref &amp; $mask ) &gt;= ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_EQUAL}: Passes if ( $ref &amp; $mask ) = ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_NOTEQUAL}: Passes if ( $ref &amp; $mask ) != ( stencil
     *    &amp; $mask ).
     *
     *  - {@see GL46::GL_ALWAYS}: Always passes.
     *
     * @see http://docs.gl/gl2/glStencilFunc
     * @see http://docs.gl/gl4/glStencilFunc
     * @since 1.1
     * @param int $func
     * @param int $ref
     * @param int $mask
     * @return void
     */
    public function stencilFunc(int $func, int $ref, int $mask): void
    {
        $this->info->ffi->glStencilFunc($func, $ref, $mask);
    }

    /**
     * {@see GL46::glStencilMask} controls the writing of individual bits in the stencil planes. The least
     * significant n bits of $mask, where n is the number of bits in the stencil buffer, specify a mask. Where a 1
     * appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears,
     * the corresponding bit is write-protected. Initially, all bits are enabled for writing.
     *
     * There can be two separate $mask writemasks; one affects back-facing polygons, and the other affects
     * front-facing polygons as well as other non-polygon primitives. {@see GL46::glStencilMask} sets both front and
     * back stencil writemasks to the same values. Use {@see GL46::glStencilMaskSeparate} to set front and back
     * stencil writemasks to different values.
     *
     * @see http://docs.gl/gl2/glStencilMask
     * @see http://docs.gl/gl4/glStencilMask
     * @since 1.1
     * @param int $mask
     * @return void
     */
    public function stencilMask(int $mask): void
    {
        $this->info->ffi->glStencilMask($mask);
    }

    /**
     * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil
     * planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out
     * portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special
     * effects, such as decals, outlining, and constructive solid geometry rendering.
     *
     * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in
     * the stencil buffer and a reference value. To enable and disable the test, call {@see GL46::glEnable} and
     * {@see GL46::glDisable} with argument {@see GL46::GL_STENCIL_TEST}; to control it, call
     * {@see GL46::glStencilFunc} or {@see GL46::glStencilFuncSeparate}.
     *
     * There can be two separate sets of $sfail, $dpfail, and $dppass parameters; one affects back-facing polygons,
     * and the other affects front-facing polygons as well as other non-polygon primitives. {@see GL46::glStencilOp}
     * sets both front and back stencil state to the same values. Use {@see GL46::glStencilOpSeparate} to set front
     * and back stencil state to different values.
     *
     * {@see GL46::glStencilOp} takes three arguments that indicate what happens to the stored stencil value while
     * stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and
     * $sfail specifies what happens to the stencil buffer contents. The following eight actions are possible.
     *
     *  - {@see GL46::GL_KEEP}: Keeps the current value.
     *
     *  - {@see GL46::GL_ZERO}: Sets the stencil buffer value to 0.
     *
     *  - {@see GL46::GL_REPLACE}: Sets the stencil buffer value to ref, as
     *    specified by {@see GL46::glStencilFunc}.
     *
     *  - {@see GL46::GL_INCR}: Increments the current stencil buffer value.
     *    Clamps to the maximum representable unsigned value.
     *
     *  - {@see GL46::GL_INCR_WRAP}: Increments the current stencil buffer
     *    value. Wraps stencil buffer value to zero when incrementing the
     *    maximum
     *    representable unsigned value.
     *
     *  - {@see GL46::GL_DECR}: Decrements the current stencil buffer value.
     *    Clamps to 0.
     *
     *  - {@see GL46::GL_DECR_WRAP}: Decrements the current stencil buffer
     *    value. Wraps stencil buffer value to the maximum representable
     *    unsigned
     *    value when decrementing a stencil buffer value of zero.
     *
     *  - {@see GL46::GL_INVERT}: Bitwise inverts the current stencil buffer
     *    value.
     *
     * Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped
     * to 0 and    2 n  - 1  , where n is the value returned by querying {@see GL46::GL_STENCIL_BITS}.
     *
     * The other two arguments to {@see GL46::glStencilOp} specify stencil buffer actions that depend on whether
     * subsequent depth buffer tests succeed ($dppass) or fail ($dpfail) (see {@see GL46::glDepthFunc}). The actions
     * are specified using the same eight symbolic constants as $sfail. Note that $dpfail is ignored when there is no
     * depth buffer, or when the depth buffer is not enabled. In these cases, $sfail and $dppass specify stencil
     * action when the stencil test fails and passes, respectively.
     *
     * @see http://docs.gl/gl2/glStencilOp
     * @see http://docs.gl/gl4/glStencilOp
     * @since 1.1
     * @param int $fail
     * @param int $zfail
     * @param int $zpass
     * @return void
     */
    public function stencilOp(int $fail, int $zfail, int $zpass): void
    {
        $this->info->ffi->glStencilOp($fail, $zfail, $zpass);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @return void
     */
    public function texCoord1d(float $s): void
    {
        $this->info->ffi->glTexCoord1d($s);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord1dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord1dv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @return void
     */
    public function texCoord1f(float $s): void
    {
        $this->info->ffi->glTexCoord1f($s);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord1fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord1fv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @return void
     */
    public function texCoord1i(int $s): void
    {
        $this->info->ffi->glTexCoord1i($s);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord1iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord1iv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @return void
     */
    public function texCoord1s(int $s): void
    {
        $this->info->ffi->glTexCoord1s($s);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord1sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord1sv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @return void
     */
    public function texCoord2d(float $s, float $t): void
    {
        $this->info->ffi->glTexCoord2d($s, $t);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord2dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord2dv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @return void
     */
    public function texCoord2f(float $s, float $t): void
    {
        $this->info->ffi->glTexCoord2f($s, $t);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord2fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord2fv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @return void
     */
    public function texCoord2i(int $s, int $t): void
    {
        $this->info->ffi->glTexCoord2i($s, $t);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord2iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord2iv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @return void
     */
    public function texCoord2s(int $s, int $t): void
    {
        $this->info->ffi->glTexCoord2s($s, $t);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord2sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord2sv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @param float $r
     * @return void
     */
    public function texCoord3d(float $s, float $t, float $r): void
    {
        $this->info->ffi->glTexCoord3d($s, $t, $r);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord3dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord3dv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @param float $r
     * @return void
     */
    public function texCoord3f(float $s, float $t, float $r): void
    {
        $this->info->ffi->glTexCoord3f($s, $t, $r);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord3fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord3fv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @param int $r
     * @return void
     */
    public function texCoord3i(int $s, int $t, int $r): void
    {
        $this->info->ffi->glTexCoord3i($s, $t, $r);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord3iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord3iv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @param int $r
     * @return void
     */
    public function texCoord3s(int $s, int $t, int $r): void
    {
        $this->info->ffi->glTexCoord3s($s, $t, $r);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord3sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord3sv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @param float $r
     * @param float $q
     * @return void
     */
    public function texCoord4d(float $s, float $t, float $r, float $q): void
    {
        $this->info->ffi->glTexCoord4d($s, $t, $r, $q);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord4dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord4dv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param float $s
     * @param float $t
     * @param float $r
     * @param float $q
     * @return void
     */
    public function texCoord4f(float $s, float $t, float $r, float $q): void
    {
        $this->info->ffi->glTexCoord4f($s, $t, $r, $q);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord4fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord4fv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @param int $r
     * @param int $q
     * @return void
     */
    public function texCoord4i(int $s, int $t, int $r, int $q): void
    {
        $this->info->ffi->glTexCoord4i($s, $t, $r, $q);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord4iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord4iv($v);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param int $s
     * @param int $t
     * @param int $r
     * @param int $q
     * @return void
     */
    public function texCoord4s(int $s, int $t, int $r, int $q): void
    {
        $this->info->ffi->glTexCoord4s($s, $t, $r, $q);
    }

    /**
     * {@see GL46::glTexCoord} specifies texture coordinates in one, two, three, or four dimensions.
     * {@see GL46::glTexCoord1} sets the current texture coordinates to    s 0 0 1  ; a call to
     * {@see GL46::glTexCoord2} sets them to    s t 0 1  . Similarly, {@see GL46::glTexCoord3} specifies the texture
     * coordinates as    s t r 1  , and {@see GL46::glTexCoord4} defines all four components explicitly as    s t r q
     *  .
     *
     * The current texture coordinates are part of the data that is associated with each vertex and with the current
     * raster position. Initially, the values for s, t, r, and q are (0, 0, 0, 1).
     *
     * @see http://docs.gl/gl2/glTexCoord
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function texCoord4sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glTexCoord4sv($v);
    }

    /**
     * {@see GL46::glTexCoordPointer} specifies the location and data format of an array of texture coordinates to
     * use when rendering. $size specifies the number of coordinates per texture coordinate set, and must be 1, 2, 3,
     * or 4. $type specifies the data type of each texture coordinate, and $stride specifies the byte stride from one
     * texture coordinate set to the next, allowing vertices and attributes to be packed into a single array or
     * stored in separate arrays. (Single-array storage may be more efficient on some implementations; see
     * {@see GL46::glInterleavedArrays}.)
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture coordinate array is specified, $pointer is treated as a byte offset
     * into the buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is
     * saved as texture coordinate vertex array client-side state
     * ({@see GL46::GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING}).
     *
     * When a texture coordinate array is specified, $size, $type, $stride, and $pointer are saved as client-side
     * state, in addition to the current vertex array buffer object binding.
     *
     * To enable and disable a texture coordinate array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_TEXTURE_COORD_ARRAY}. If enabled, the
     * texture coordinate array is used when {@see GL46::glArrayElement}, {@see GL46::glDrawArrays},
     * {@see GL46::glMultiDrawArrays}, {@see GL46::glDrawElements}, {@see GL46::glMultiDrawElements}, or
     * {@see GL46::glDrawRangeElements} is called.
     *
     * @see http://docs.gl/gl2/glTexCoordPointer
     * @since 1.1
     * @param int $size
     * @param int $type
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function texCoordPointer(int $size, int $type, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glTexCoordPointer($size, $type, $stride, $pointer);
    }

    /**
     * A texture environment specifies how texture values are interpreted when a fragment is textured. When $target
     * is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, then $params is (or points to) the symbolic name of a texture
     * function. Six texture functions may be specified: {@see GL46::GL_ADD}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_DECAL}, {@see GL46::GL_BLEND}, {@see GL46::GL_REPLACE}, or {@see GL46::GL_COMBINE}.
     *
     * The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to
     * texture source components. C s and A s are used by the texture functions described below.
     *
     * | {@see GL46::GL_ALPHA}           | (0, 0, 0)         | A t |
     * | {@see GL46::GL_LUMINANCE}       | ( L t, L t, L t ) | 1   |
     * | {@see GL46::GL_LUMINANCE_ALPHA} | ( L t, L t, L t ) | A t |
     * | {@see GL46::GL_INTENSITY}       | ( I t, I t, I t ) | I t |
     * | {@see GL46::GL_RGB}             | ( R t, G t, B t ) | 1   |
     * | {@see GL46::GL_RGBA}            | ( R t, G t, B t ) | A t |
     * A texture function acts on the fragment to be textured using the texture image value that applies to the
     * fragment (see {@see GL46::glTexParameter}) and produces an RGBA color for that fragment. The following table
     * shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a
     * triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image
     * are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the
     * incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c
     * to the texture environment color, and the subscript v indicates a value produced by the texture function.
     *
     * | {@see GL46::GL_ALPHA}           |    C v  = |    C p |    C p                | undefined                                          |    C p                                             |    C p                |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |    A v  =  A p  &amp;it; A s                       |     A p  &amp;it; A s |
     * | {@see GL46::GL_LUMINANCE}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 1)                          |    A v  = |    A p |    A p                |                                                    |    A p                                             |    A p                |
     * | {@see GL46::GL_LUMINANCE_ALPHA} |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 2)                          |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * | {@see GL46::GL_INTENSITY}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it;   1 - A s    + A c  &amp;it; A s |     A p  + A s        |
     * | {@see GL46::GL_RGB}             |    C v  = |    C s |     C p  &amp;it; C s |    C s                                             |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 3)                          |    A v  = |    A p |    A p                |    A p                                             |    A p                                             |    A p                |
     * | {@see GL46::GL_RGBA}            |    C v  = |    C s |     C p  &amp;it; C s |     C p  &amp;it;   1 - A s    + C s  &amp;it; A s |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 4)                          |    A v  = |    A s |     A p  &amp;it; A s |    A p                                             |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, and $params is {@see GL46::GL_COMBINE}, the form of the texture
     * function depends on the values of {@see GL46::GL_COMBINE_RGB} and {@see GL46::GL_COMBINE_ALPHA}.
     *
     * The following describes how the texture sources, as specified by {@see GL46::GL_SRC0_RGB},
     * {@see GL46::GL_SRC1_RGB}, {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA},
     * and {@see GL46::GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables,
     * {@see GL46::GL_SRC0_c} is represented by Arg0, {@see GL46::GL_SRC1_c} is represented by Arg1, and
     * {@see GL46::GL_SRC2_c} is represented by Arg2.
     *
     * {@see GL46::GL_COMBINE_RGB} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, {@see GL46::GL_SUBTRACT},
     * {@see GL46::GL_DOT3_RGB}, or {@see GL46::GL_DOT3_RGBA}.
     *
     * | {@see GL46::GL_REPLACE}                               | Arg0                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_MODULATE}                              |    Arg0 × Arg1                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | {@see GL46::GL_ADD}                                   |    Arg0 + Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_ADD_SIGNED}                            |    Arg0 + Arg1 - 0.5                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_INTERPOLATE}                           |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2                                                                                                                                                                                                                                                                                                                                                                         |
     * | {@see GL46::GL_SUBTRACT}                              |    Arg0 - Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_DOT3_RGB} or {@see GL46::GL_DOT3_RGBA} | <!-- eqn: 4  *  ((({Arg0 sub r}  -  0.5) * ({Arg1 sub r} - 0.5)) +
     *                                          (({Arg0 sub g}  -  0.5) * ({Arg1 sub g} - 0.5)) +
     *                                          (({Arg0 sub b}  -  0.5) * ({Arg1 sub b} - 0.5)):-->  4 ×        Arg0
     * r   - 0.5   ×    Arg1 r   - 0.5     +      Arg0 g   - 0.5   ×    Arg1 g   - 0.5     +      Arg0 b   - 0.5
     * ×    Arg1 b   - 0.5 |
     * The scalar results for {@see GL46::GL_DOT3_RGB} and {@see GL46::GL_DOT3_RGBA} are placed into each of the 3
     * (RGB) or 4 (RGBA) components on output.
     *
     * Likewise, {@see GL46::GL_COMBINE_ALPHA} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, or {@see GL46::GL_SUBTRACT}. The
     * following table describes how alpha values are combined:
     *
     * | {@see GL46::GL_REPLACE}     | Arg0                                    |
     * | {@see GL46::GL_MODULATE}    |    Arg0 × Arg1                         |
     * | {@see GL46::GL_ADD}         |    Arg0 + Arg1                          |
     * | {@see GL46::GL_ADD_SIGNED}  |    Arg0 + Arg1 - 0.5                    |
     * | {@see GL46::GL_INTERPOLATE} |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2 |
     * | {@see GL46::GL_SUBTRACT}    |    Arg0 - Arg1                          |
     * In the following tables, the value   C s   represents the color sampled from the currently bound texture,   C
     * c   represents the constant texture-environment color,   C f   represents the primary color of the incoming
     * fragment, and   C p   represents the color computed from the previous texture stage or   C f   if processing
     * texture stage 0. Likewise,   A s  ,   A c  ,   A f  , and   A p   represent the respective alpha values.
     *
     * The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_COLOR}           |    C c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C c |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_COLOR}           |    C f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C f |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_COLOR}           |    C p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C p |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * For {@see GL46::GL_TEXTUREn} sources,   C s   and   A s   represent the color and alpha, respectively,
     * produced from texture stage n.
     *
     * The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * The RGB and alpha results of the texture function are multiplied by the values of {@see GL46::GL_RGB_SCALE}
     * and {@see GL46::GL_ALPHA_SCALE}, respectively, and clamped to the range    0 1  .
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_COLOR}, $params is a pointer to an array that holds an RGBA color
     * consisting of four values. Integer color components are interpreted linearly such that the most positive
     * integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1]
     * when they are specified.   C c   takes these four values.
     *
     * If $pname is {@see GL46::GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail
     * parameter, that selects which mipmap, or mipmaps depending upon the selected
     * {@see GL46::GL_TEXTURE_MIN_FILTER}, will be sampled.
     *
     * {@see GL46::GL_TEXTURE_ENV_MODE} defaults to {@see GL46::GL_MODULATE} and {@see GL46::GL_TEXTURE_ENV_COLOR}
     * defaults to (0, 0, 0, 0).
     *
     * If $target is {@see GL46::GL_POINT_SPRITE} and $pname is {@see GL46::GL_COORD_REPLACE}, the boolean value
     * specified is used to either enable or disable point sprite texture coordinate replacement. The default value
     * is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function texEnvf(int $target, int $pname, float $param): void
    {
        $this->info->ffi->glTexEnvf($target, $pname, $param);
    }

    /**
     * A texture environment specifies how texture values are interpreted when a fragment is textured. When $target
     * is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, then $params is (or points to) the symbolic name of a texture
     * function. Six texture functions may be specified: {@see GL46::GL_ADD}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_DECAL}, {@see GL46::GL_BLEND}, {@see GL46::GL_REPLACE}, or {@see GL46::GL_COMBINE}.
     *
     * The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to
     * texture source components. C s and A s are used by the texture functions described below.
     *
     * | {@see GL46::GL_ALPHA}           | (0, 0, 0)         | A t |
     * | {@see GL46::GL_LUMINANCE}       | ( L t, L t, L t ) | 1   |
     * | {@see GL46::GL_LUMINANCE_ALPHA} | ( L t, L t, L t ) | A t |
     * | {@see GL46::GL_INTENSITY}       | ( I t, I t, I t ) | I t |
     * | {@see GL46::GL_RGB}             | ( R t, G t, B t ) | 1   |
     * | {@see GL46::GL_RGBA}            | ( R t, G t, B t ) | A t |
     * A texture function acts on the fragment to be textured using the texture image value that applies to the
     * fragment (see {@see GL46::glTexParameter}) and produces an RGBA color for that fragment. The following table
     * shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a
     * triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image
     * are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the
     * incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c
     * to the texture environment color, and the subscript v indicates a value produced by the texture function.
     *
     * | {@see GL46::GL_ALPHA}           |    C v  = |    C p |    C p                | undefined                                          |    C p                                             |    C p                |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |    A v  =  A p  &amp;it; A s                       |     A p  &amp;it; A s |
     * | {@see GL46::GL_LUMINANCE}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 1)                          |    A v  = |    A p |    A p                |                                                    |    A p                                             |    A p                |
     * | {@see GL46::GL_LUMINANCE_ALPHA} |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 2)                          |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * | {@see GL46::GL_INTENSITY}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it;   1 - A s    + A c  &amp;it; A s |     A p  + A s        |
     * | {@see GL46::GL_RGB}             |    C v  = |    C s |     C p  &amp;it; C s |    C s                                             |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 3)                          |    A v  = |    A p |    A p                |    A p                                             |    A p                                             |    A p                |
     * | {@see GL46::GL_RGBA}            |    C v  = |    C s |     C p  &amp;it; C s |     C p  &amp;it;   1 - A s    + C s  &amp;it; A s |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 4)                          |    A v  = |    A s |     A p  &amp;it; A s |    A p                                             |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, and $params is {@see GL46::GL_COMBINE}, the form of the texture
     * function depends on the values of {@see GL46::GL_COMBINE_RGB} and {@see GL46::GL_COMBINE_ALPHA}.
     *
     * The following describes how the texture sources, as specified by {@see GL46::GL_SRC0_RGB},
     * {@see GL46::GL_SRC1_RGB}, {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA},
     * and {@see GL46::GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables,
     * {@see GL46::GL_SRC0_c} is represented by Arg0, {@see GL46::GL_SRC1_c} is represented by Arg1, and
     * {@see GL46::GL_SRC2_c} is represented by Arg2.
     *
     * {@see GL46::GL_COMBINE_RGB} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, {@see GL46::GL_SUBTRACT},
     * {@see GL46::GL_DOT3_RGB}, or {@see GL46::GL_DOT3_RGBA}.
     *
     * | {@see GL46::GL_REPLACE}                               | Arg0                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_MODULATE}                              |    Arg0 × Arg1                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | {@see GL46::GL_ADD}                                   |    Arg0 + Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_ADD_SIGNED}                            |    Arg0 + Arg1 - 0.5                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_INTERPOLATE}                           |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2                                                                                                                                                                                                                                                                                                                                                                         |
     * | {@see GL46::GL_SUBTRACT}                              |    Arg0 - Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_DOT3_RGB} or {@see GL46::GL_DOT3_RGBA} | <!-- eqn: 4  *  ((({Arg0 sub r}  -  0.5) * ({Arg1 sub r} - 0.5)) +
     *                                          (({Arg0 sub g}  -  0.5) * ({Arg1 sub g} - 0.5)) +
     *                                          (({Arg0 sub b}  -  0.5) * ({Arg1 sub b} - 0.5)):-->  4 ×        Arg0
     * r   - 0.5   ×    Arg1 r   - 0.5     +      Arg0 g   - 0.5   ×    Arg1 g   - 0.5     +      Arg0 b   - 0.5
     * ×    Arg1 b   - 0.5 |
     * The scalar results for {@see GL46::GL_DOT3_RGB} and {@see GL46::GL_DOT3_RGBA} are placed into each of the 3
     * (RGB) or 4 (RGBA) components on output.
     *
     * Likewise, {@see GL46::GL_COMBINE_ALPHA} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, or {@see GL46::GL_SUBTRACT}. The
     * following table describes how alpha values are combined:
     *
     * | {@see GL46::GL_REPLACE}     | Arg0                                    |
     * | {@see GL46::GL_MODULATE}    |    Arg0 × Arg1                         |
     * | {@see GL46::GL_ADD}         |    Arg0 + Arg1                          |
     * | {@see GL46::GL_ADD_SIGNED}  |    Arg0 + Arg1 - 0.5                    |
     * | {@see GL46::GL_INTERPOLATE} |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2 |
     * | {@see GL46::GL_SUBTRACT}    |    Arg0 - Arg1                          |
     * In the following tables, the value   C s   represents the color sampled from the currently bound texture,   C
     * c   represents the constant texture-environment color,   C f   represents the primary color of the incoming
     * fragment, and   C p   represents the color computed from the previous texture stage or   C f   if processing
     * texture stage 0. Likewise,   A s  ,   A c  ,   A f  , and   A p   represent the respective alpha values.
     *
     * The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_COLOR}           |    C c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C c |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_COLOR}           |    C f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C f |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_COLOR}           |    C p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C p |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * For {@see GL46::GL_TEXTUREn} sources,   C s   and   A s   represent the color and alpha, respectively,
     * produced from texture stage n.
     *
     * The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * The RGB and alpha results of the texture function are multiplied by the values of {@see GL46::GL_RGB_SCALE}
     * and {@see GL46::GL_ALPHA_SCALE}, respectively, and clamped to the range    0 1  .
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_COLOR}, $params is a pointer to an array that holds an RGBA color
     * consisting of four values. Integer color components are interpreted linearly such that the most positive
     * integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1]
     * when they are specified.   C c   takes these four values.
     *
     * If $pname is {@see GL46::GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail
     * parameter, that selects which mipmap, or mipmaps depending upon the selected
     * {@see GL46::GL_TEXTURE_MIN_FILTER}, will be sampled.
     *
     * {@see GL46::GL_TEXTURE_ENV_MODE} defaults to {@see GL46::GL_MODULATE} and {@see GL46::GL_TEXTURE_ENV_COLOR}
     * defaults to (0, 0, 0, 0).
     *
     * If $target is {@see GL46::GL_POINT_SPRITE} and $pname is {@see GL46::GL_COORD_REPLACE}, the boolean value
     * specified is used to either enable or disable point sprite texture coordinate replacement. The default value
     * is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texEnvfv(int $target, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexEnvfv($target, $pname, $params);
    }

    /**
     * A texture environment specifies how texture values are interpreted when a fragment is textured. When $target
     * is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, then $params is (or points to) the symbolic name of a texture
     * function. Six texture functions may be specified: {@see GL46::GL_ADD}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_DECAL}, {@see GL46::GL_BLEND}, {@see GL46::GL_REPLACE}, or {@see GL46::GL_COMBINE}.
     *
     * The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to
     * texture source components. C s and A s are used by the texture functions described below.
     *
     * | {@see GL46::GL_ALPHA}           | (0, 0, 0)         | A t |
     * | {@see GL46::GL_LUMINANCE}       | ( L t, L t, L t ) | 1   |
     * | {@see GL46::GL_LUMINANCE_ALPHA} | ( L t, L t, L t ) | A t |
     * | {@see GL46::GL_INTENSITY}       | ( I t, I t, I t ) | I t |
     * | {@see GL46::GL_RGB}             | ( R t, G t, B t ) | 1   |
     * | {@see GL46::GL_RGBA}            | ( R t, G t, B t ) | A t |
     * A texture function acts on the fragment to be textured using the texture image value that applies to the
     * fragment (see {@see GL46::glTexParameter}) and produces an RGBA color for that fragment. The following table
     * shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a
     * triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image
     * are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the
     * incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c
     * to the texture environment color, and the subscript v indicates a value produced by the texture function.
     *
     * | {@see GL46::GL_ALPHA}           |    C v  = |    C p |    C p                | undefined                                          |    C p                                             |    C p                |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |    A v  =  A p  &amp;it; A s                       |     A p  &amp;it; A s |
     * | {@see GL46::GL_LUMINANCE}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 1)                          |    A v  = |    A p |    A p                |                                                    |    A p                                             |    A p                |
     * | {@see GL46::GL_LUMINANCE_ALPHA} |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 2)                          |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * | {@see GL46::GL_INTENSITY}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it;   1 - A s    + A c  &amp;it; A s |     A p  + A s        |
     * | {@see GL46::GL_RGB}             |    C v  = |    C s |     C p  &amp;it; C s |    C s                                             |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 3)                          |    A v  = |    A p |    A p                |    A p                                             |    A p                                             |    A p                |
     * | {@see GL46::GL_RGBA}            |    C v  = |    C s |     C p  &amp;it; C s |     C p  &amp;it;   1 - A s    + C s  &amp;it; A s |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 4)                          |    A v  = |    A s |     A p  &amp;it; A s |    A p                                             |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, and $params is {@see GL46::GL_COMBINE}, the form of the texture
     * function depends on the values of {@see GL46::GL_COMBINE_RGB} and {@see GL46::GL_COMBINE_ALPHA}.
     *
     * The following describes how the texture sources, as specified by {@see GL46::GL_SRC0_RGB},
     * {@see GL46::GL_SRC1_RGB}, {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA},
     * and {@see GL46::GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables,
     * {@see GL46::GL_SRC0_c} is represented by Arg0, {@see GL46::GL_SRC1_c} is represented by Arg1, and
     * {@see GL46::GL_SRC2_c} is represented by Arg2.
     *
     * {@see GL46::GL_COMBINE_RGB} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, {@see GL46::GL_SUBTRACT},
     * {@see GL46::GL_DOT3_RGB}, or {@see GL46::GL_DOT3_RGBA}.
     *
     * | {@see GL46::GL_REPLACE}                               | Arg0                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_MODULATE}                              |    Arg0 × Arg1                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | {@see GL46::GL_ADD}                                   |    Arg0 + Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_ADD_SIGNED}                            |    Arg0 + Arg1 - 0.5                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_INTERPOLATE}                           |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2                                                                                                                                                                                                                                                                                                                                                                         |
     * | {@see GL46::GL_SUBTRACT}                              |    Arg0 - Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_DOT3_RGB} or {@see GL46::GL_DOT3_RGBA} | <!-- eqn: 4  *  ((({Arg0 sub r}  -  0.5) * ({Arg1 sub r} - 0.5)) +
     *                                          (({Arg0 sub g}  -  0.5) * ({Arg1 sub g} - 0.5)) +
     *                                          (({Arg0 sub b}  -  0.5) * ({Arg1 sub b} - 0.5)):-->  4 ×        Arg0
     * r   - 0.5   ×    Arg1 r   - 0.5     +      Arg0 g   - 0.5   ×    Arg1 g   - 0.5     +      Arg0 b   - 0.5
     * ×    Arg1 b   - 0.5 |
     * The scalar results for {@see GL46::GL_DOT3_RGB} and {@see GL46::GL_DOT3_RGBA} are placed into each of the 3
     * (RGB) or 4 (RGBA) components on output.
     *
     * Likewise, {@see GL46::GL_COMBINE_ALPHA} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, or {@see GL46::GL_SUBTRACT}. The
     * following table describes how alpha values are combined:
     *
     * | {@see GL46::GL_REPLACE}     | Arg0                                    |
     * | {@see GL46::GL_MODULATE}    |    Arg0 × Arg1                         |
     * | {@see GL46::GL_ADD}         |    Arg0 + Arg1                          |
     * | {@see GL46::GL_ADD_SIGNED}  |    Arg0 + Arg1 - 0.5                    |
     * | {@see GL46::GL_INTERPOLATE} |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2 |
     * | {@see GL46::GL_SUBTRACT}    |    Arg0 - Arg1                          |
     * In the following tables, the value   C s   represents the color sampled from the currently bound texture,   C
     * c   represents the constant texture-environment color,   C f   represents the primary color of the incoming
     * fragment, and   C p   represents the color computed from the previous texture stage or   C f   if processing
     * texture stage 0. Likewise,   A s  ,   A c  ,   A f  , and   A p   represent the respective alpha values.
     *
     * The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_COLOR}           |    C c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C c |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_COLOR}           |    C f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C f |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_COLOR}           |    C p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C p |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * For {@see GL46::GL_TEXTUREn} sources,   C s   and   A s   represent the color and alpha, respectively,
     * produced from texture stage n.
     *
     * The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * The RGB and alpha results of the texture function are multiplied by the values of {@see GL46::GL_RGB_SCALE}
     * and {@see GL46::GL_ALPHA_SCALE}, respectively, and clamped to the range    0 1  .
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_COLOR}, $params is a pointer to an array that holds an RGBA color
     * consisting of four values. Integer color components are interpreted linearly such that the most positive
     * integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1]
     * when they are specified.   C c   takes these four values.
     *
     * If $pname is {@see GL46::GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail
     * parameter, that selects which mipmap, or mipmaps depending upon the selected
     * {@see GL46::GL_TEXTURE_MIN_FILTER}, will be sampled.
     *
     * {@see GL46::GL_TEXTURE_ENV_MODE} defaults to {@see GL46::GL_MODULATE} and {@see GL46::GL_TEXTURE_ENV_COLOR}
     * defaults to (0, 0, 0, 0).
     *
     * If $target is {@see GL46::GL_POINT_SPRITE} and $pname is {@see GL46::GL_COORD_REPLACE}, the boolean value
     * specified is used to either enable or disable point sprite texture coordinate replacement. The default value
     * is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function texEnvi(int $target, int $pname, int $param): void
    {
        $this->info->ffi->glTexEnvi($target, $pname, $param);
    }

    /**
     * A texture environment specifies how texture values are interpreted when a fragment is textured. When $target
     * is {@see GL46::GL_TEXTURE_FILTER_CONTROL}, $pname must be {@see GL46::GL_TEXTURE_LOD_BIAS}. When $target is
     * {@see GL46::GL_TEXTURE_ENV}, $pname can be {@see GL46::GL_TEXTURE_ENV_MODE},
     * {@see GL46::GL_TEXTURE_ENV_COLOR}, {@see GL46::GL_COMBINE_RGB}, {@see GL46::GL_COMBINE_ALPHA},
     * {@see GL46::GL_RGB_SCALE}, {@see GL46::GL_ALPHA_SCALE}, {@see GL46::GL_SRC0_RGB}, {@see GL46::GL_SRC1_RGB},
     * {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA}, or
     * {@see GL46::GL_SRC2_ALPHA}.
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, then $params is (or points to) the symbolic name of a texture
     * function. Six texture functions may be specified: {@see GL46::GL_ADD}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_DECAL}, {@see GL46::GL_BLEND}, {@see GL46::GL_REPLACE}, or {@see GL46::GL_COMBINE}.
     *
     * The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to
     * texture source components. C s and A s are used by the texture functions described below.
     *
     * | {@see GL46::GL_ALPHA}           | (0, 0, 0)         | A t |
     * | {@see GL46::GL_LUMINANCE}       | ( L t, L t, L t ) | 1   |
     * | {@see GL46::GL_LUMINANCE_ALPHA} | ( L t, L t, L t ) | A t |
     * | {@see GL46::GL_INTENSITY}       | ( I t, I t, I t ) | I t |
     * | {@see GL46::GL_RGB}             | ( R t, G t, B t ) | 1   |
     * | {@see GL46::GL_RGBA}            | ( R t, G t, B t ) | A t |
     * A texture function acts on the fragment to be textured using the texture image value that applies to the
     * fragment (see {@see GL46::glTexParameter}) and produces an RGBA color for that fragment. The following table
     * shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a
     * triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image
     * are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the
     * incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c
     * to the texture environment color, and the subscript v indicates a value produced by the texture function.
     *
     * | {@see GL46::GL_ALPHA}           |    C v  = |    C p |    C p                | undefined                                          |    C p                                             |    C p                |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |    A v  =  A p  &amp;it; A s                       |     A p  &amp;it; A s |
     * | {@see GL46::GL_LUMINANCE}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 1)                          |    A v  = |    A p |    A p                |                                                    |    A p                                             |    A p                |
     * | {@see GL46::GL_LUMINANCE_ALPHA} |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 2)                          |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * | {@see GL46::GL_INTENSITY}       |    C v  = |    C s |     C p  &amp;it; C s | undefined                                          |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * |                                 |    A v  = |    A s |     A p  &amp;it; A s |                                                    |     A p  &amp;it;   1 - A s    + A c  &amp;it; A s |     A p  + A s        |
     * | {@see GL46::GL_RGB}             |    C v  = |    C s |     C p  &amp;it; C s |    C s                                             |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 3)                          |    A v  = |    A p |    A p                |    A p                                             |    A p                                             |    A p                |
     * | {@see GL46::GL_RGBA}            |    C v  = |    C s |     C p  &amp;it; C s |     C p  &amp;it;   1 - A s    + C s  &amp;it; A s |     C p  &amp;it;   1 - C s    + C c  &amp;it; C s |     C p  + C s        |
     * | (or 4)                          |    A v  = |    A s |     A p  &amp;it; A s |    A p                                             |     A p  &amp;it; A s                              |     A p  &amp;it; A s |
     * If $pname is {@see GL46::GL_TEXTURE_ENV_MODE}, and $params is {@see GL46::GL_COMBINE}, the form of the texture
     * function depends on the values of {@see GL46::GL_COMBINE_RGB} and {@see GL46::GL_COMBINE_ALPHA}.
     *
     * The following describes how the texture sources, as specified by {@see GL46::GL_SRC0_RGB},
     * {@see GL46::GL_SRC1_RGB}, {@see GL46::GL_SRC2_RGB}, {@see GL46::GL_SRC0_ALPHA}, {@see GL46::GL_SRC1_ALPHA},
     * and {@see GL46::GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables,
     * {@see GL46::GL_SRC0_c} is represented by Arg0, {@see GL46::GL_SRC1_c} is represented by Arg1, and
     * {@see GL46::GL_SRC2_c} is represented by Arg2.
     *
     * {@see GL46::GL_COMBINE_RGB} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, {@see GL46::GL_SUBTRACT},
     * {@see GL46::GL_DOT3_RGB}, or {@see GL46::GL_DOT3_RGBA}.
     *
     * | {@see GL46::GL_REPLACE}                               | Arg0                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_MODULATE}                              |    Arg0 × Arg1                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | {@see GL46::GL_ADD}                                   |    Arg0 + Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_ADD_SIGNED}                            |    Arg0 + Arg1 - 0.5                                                                                                                                                                                                                                                                                                                                                                                            |
     * | {@see GL46::GL_INTERPOLATE}                           |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2                                                                                                                                                                                                                                                                                                                                                                         |
     * | {@see GL46::GL_SUBTRACT}                              |    Arg0 - Arg1                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | {@see GL46::GL_DOT3_RGB} or {@see GL46::GL_DOT3_RGBA} | <!-- eqn: 4  *  ((({Arg0 sub r}  -  0.5) * ({Arg1 sub r} - 0.5)) +
     *                                          (({Arg0 sub g}  -  0.5) * ({Arg1 sub g} - 0.5)) +
     *                                          (({Arg0 sub b}  -  0.5) * ({Arg1 sub b} - 0.5)):-->  4 ×        Arg0
     * r   - 0.5   ×    Arg1 r   - 0.5     +      Arg0 g   - 0.5   ×    Arg1 g   - 0.5     +      Arg0 b   - 0.5
     * ×    Arg1 b   - 0.5 |
     * The scalar results for {@see GL46::GL_DOT3_RGB} and {@see GL46::GL_DOT3_RGBA} are placed into each of the 3
     * (RGB) or 4 (RGBA) components on output.
     *
     * Likewise, {@see GL46::GL_COMBINE_ALPHA} accepts any of {@see GL46::GL_REPLACE}, {@see GL46::GL_MODULATE},
     * {@see GL46::GL_ADD}, {@see GL46::GL_ADD_SIGNED}, {@see GL46::GL_INTERPOLATE}, or {@see GL46::GL_SUBTRACT}. The
     * following table describes how alpha values are combined:
     *
     * | {@see GL46::GL_REPLACE}     | Arg0                                    |
     * | {@see GL46::GL_MODULATE}    |    Arg0 × Arg1                         |
     * | {@see GL46::GL_ADD}         |    Arg0 + Arg1                          |
     * | {@see GL46::GL_ADD_SIGNED}  |    Arg0 + Arg1 - 0.5                    |
     * | {@see GL46::GL_INTERPOLATE} |     Arg0 × Arg2  +  Arg1 ×   1 - Arg2 |
     * | {@see GL46::GL_SUBTRACT}    |    Arg0 - Arg1                          |
     * In the following tables, the value   C s   represents the color sampled from the currently bound texture,   C
     * c   represents the constant texture-environment color,   C f   represents the primary color of the incoming
     * fragment, and   C p   represents the color computed from the previous texture stage or   C f   if processing
     * texture stage 0. Likewise,   A s  ,   A c  ,   A f  , and   A p   represent the respective alpha values.
     *
     * The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_COLOR}           |    C s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C s |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_COLOR}           |    C c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C c |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_COLOR}           |    C f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C f |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_COLOR}           |    C p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_COLOR} |    1 -  C p |
     * |                               | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * For {@see GL46::GL_TEXTUREn} sources,   C s   and   A s   represent the color and alpha, respectively,
     * produced from texture stage n.
     *
     * The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and
     * operands:
     *
     * | {@see GL46::GL_TEXTURE}       | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_TEXTUREn}      | {@see GL46::GL_SRC_ALPHA}           |    A s      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A s |
     * | {@see GL46::GL_CONSTANT}      | {@see GL46::GL_SRC_ALPHA}           |    A c      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A c |
     * | {@see GL46::GL_PRIMARY_COLOR} | {@see GL46::GL_SRC_ALPHA}           |    A f      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A f |
     * | {@see GL46::GL_PREVIOUS}      | {@see GL46::GL_SRC_ALPHA}           |    A p      |
     * |                               | {@see GL46::GL_ONE_MINUS_SRC_ALPHA} |    1 -  A p |
     * The RGB and alpha results of the texture function are multiplied by the values of {@see GL46::GL_RGB_SCALE}
     * and {@see GL46::GL_ALPHA_SCALE}, respectively, and clamped to the range    0 1  .
     *
     * If $pname is {@see GL46::GL_TEXTURE_ENV_COLOR}, $params is a pointer to an array that holds an RGBA color
     * consisting of four values. Integer color components are interpreted linearly such that the most positive
     * integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1]
     * when they are specified.   C c   takes these four values.
     *
     * If $pname is {@see GL46::GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail
     * parameter, that selects which mipmap, or mipmaps depending upon the selected
     * {@see GL46::GL_TEXTURE_MIN_FILTER}, will be sampled.
     *
     * {@see GL46::GL_TEXTURE_ENV_MODE} defaults to {@see GL46::GL_MODULATE} and {@see GL46::GL_TEXTURE_ENV_COLOR}
     * defaults to (0, 0, 0, 0).
     *
     * If $target is {@see GL46::GL_POINT_SPRITE} and $pname is {@see GL46::GL_COORD_REPLACE}, the boolean value
     * specified is used to either enable or disable point sprite texture coordinate replacement. The default value
     * is {@see GL46::GL_FALSE}.
     *
     * @see http://docs.gl/gl2/glTexEnv
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texEnviv(int $target, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexEnviv($target, $pname, $params);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function texGend(int $coord, int $pname, float $param): void
    {
        $this->info->ffi->glTexGend($coord, $pname, $param);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texGendv(int $coord, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexGendv($coord, $pname, $params);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function texGenf(int $coord, int $pname, float $param): void
    {
        $this->info->ffi->glTexGenf($coord, $pname, $param);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texGenfv(int $coord, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexGenfv($coord, $pname, $params);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function texGeni(int $coord, int $pname, int $param): void
    {
        $this->info->ffi->glTexGeni($coord, $pname, $param);
    }

    /**
     * {@see GL46::glTexGen} selects a texture-coordinate generation function or supplies coefficients for one of the
     * functions. $coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
     * {@see GL46::GL_S}, {@see GL46::GL_T}, {@see GL46::GL_R}, or {@see GL46::GL_Q}. $pname must be one of three
     * symbolic constants: {@see GL46::GL_TEXTURE_GEN_MODE}, {@see GL46::GL_OBJECT_PLANE}, or
     * {@see GL46::GL_EYE_PLANE}. If $pname is {@see GL46::GL_TEXTURE_GEN_MODE}, then $params chooses a mode, one of
     * {@see GL46::GL_OBJECT_LINEAR}, {@see GL46::GL_EYE_LINEAR}, {@see GL46::GL_SPHERE_MAP},
     * {@see GL46::GL_NORMAL_MAP}, or {@see GL46::GL_REFLECTION_MAP}. If $pname is either
     * {@see GL46::GL_OBJECT_PLANE} or {@see GL46::GL_EYE_PLANE}, $params contains coefficients for the corresponding
     * texture generation function.
     *
     * If the texture generation function is {@see GL46::GL_OBJECT_LINEAR}, the function
     *
     *    g =   p 1  × x o   +  p 2  × y o   +  p 3  × z o   +  p 4  × w o
     *
     * is used, where g is the value computed for the coordinate named in $coord,   p 1  ,   p 2  ,   p 3  , and   p
     * 4   are the four values supplied in $params, and   x o  ,   y o  ,   z o  , and   w o   are the object
     * coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a
     * reference plane (defined by   p 1  ,   p 2  ,   p 3  , and   p 4  ). The altitude of a terrain vertex is
     * computed by the {@see GL46::GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level;
     * that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto
     * foothills.
     *
     * If the texture generation function is {@see GL46::GL_EYE_LINEAR}, the function
     *
     *    g =    p 1   ″  × x e   +   p 2   ″  × y e   +   p 3   ″  × z e   +   p 4   ″  × w e
     *
     * is used, where
     *
     *       p 1   ″  &amp;it;  p 2   ″  &amp;it;  p 3   ″  &amp;it;  p 4   ″    =    p 1  &amp;it; p 2
     * &amp;it; p 3  &amp;it; p 4    &amp;it; M -1
     *
     * and   x e  ,   y e  ,   z e  , and   w e   are the eye coordinates of the vertex,   p 1  ,   p 2  ,   p 3  ,
     * and   p 4   are the values supplied in $params, and M is the modelview matrix when {@see GL46::glTexGen} is
     * invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may
     * be inaccurate or undefined.
     *
     * Note that the values in $params define a reference plane in eye coordinates. The modelview matrix that is
     * applied to them may not be the same one in effect when the polygon vertices are transformed. This function
     * establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     *
     * If the texture generation function is {@see GL46::GL_SPHERE_MAP} and $coord is either {@see GL46::GL_S} or
     * {@see GL46::GL_T}, s and t texture coordinates are generated as follows. Let u be the unit vector pointing
     * from the origin to the polygon vertex (in eye coordinates). Let n sup prime be the current normal, after
     * transformation to eye coordinates. Let
     *
     *    f =   f x  &amp;it; f y  &amp;it; f z    T    be the reflection vector such that
     *
     *    f =  u - 2 &amp;it; n ″  &amp;it;  n ″   T  &amp;it; u
     *
     * Finally, let    m =  2 &amp;it;     f x   2  +  f y   2  +   f z  + 1   2       . Then the values assigned to
     * the s and t texture coordinates are
     *
     *    s =   f x  m  +  1 2
     *
     *    t =   f y  m  +  1 2
     *
     * To enable or disable a texture-coordinate generation function, call {@see GL46::glEnable} or
     * {@see GL46::glDisable} with one of the symbolic texture-coordinate names ({@see GL46::GL_TEXTURE_GEN_S},
     * {@see GL46::GL_TEXTURE_GEN_T}, {@see GL46::GL_TEXTURE_GEN_R}, or {@see GL46::GL_TEXTURE_GEN_Q}) as the
     * argument. When enabled, the specified texture coordinate is computed according to the generating function
     * associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from
     * the current set of texture coordinates. Initially, all texture generation functions are set to
     * {@see GL46::GL_EYE_LINEAR} and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations
     * are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0).
     *
     * When the `ARB_multitexture` extension is supported, {@see GL46::glTexGen} sets the texture generation
     * parameters for the currently active texture unit, selected with {@see GL46::glActiveTexture}.
     *
     * @see http://docs.gl/gl2/glTexGen
     * @since 1.1
     * @param int $coord
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texGeniv(int $coord, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexGeniv($coord, $pname, $params);
    }

    /**
     * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is
     * enabled. To enable and disable one-dimensional texturing, call {@see GL46::glEnable} and
     * {@see GL46::glDisable} with argument {@see GL46::GL_TEXTURE_1D}.
     *
     * Texture images are defined with {@see GL46::glTexImage1D}. The arguments describe the parameters of the
     * texture image, such as width, width of the border, level-of-detail number (see {@see GL46::glTexParameter}),
     * and the internal resolution and format used to store the image. The last three arguments describe how the
     * image is represented in memory.
     *
     * If $target is {@see GL46::GL_PROXY_TEXTURE_1D}, no data is read from $data, but all of the texture image state
     * is recalculated, checked for consistency, and checked against the implementation's capabilities. If the
     * implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but
     * does not generate an error (see {@see GL46::glGetError}). To query for an entire mipmap array, use an image
     * array level greater than or equal to 1.
     *
     * If $target is {@see GL46::GL_TEXTURE_1D}, data is read from $data as a sequence of signed or unsigned bytes,
     * shorts, or longs, or single-precision floating-point values, depending on $type. These values are grouped into
     * sets of one, two, three, or four values, depending on $format, to form elements. Each data byte is treated as
     * eight 1-bit elements, with bit ordering determined by {@see GL46::GL_UNPACK_LSB_FIRST} (see
     * {@see GL46::glPixelStore}).
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture image is specified, $data is treated as a byte offset into the
     * buffer object's data store.
     *
     * The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right
     * through the remaining texels in the texture array. The final element corresponds to the right end of the
     * texture array.
     *
     * $format determines the composition of each element in $data. It can assume one of these symbolic values:
     *
     *  - {@see GL46::GL_RED}: Each element is a single red component. The GL
     *    converts it to floating point and assembles it into an RGBA
     *    element by attaching 0 for green and blue, and 1 for alpha. Each
     *    component is clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RG}: Each element is a single red/green double The GL
     *    converts it to floating point and assembles it into an RGBA
     *    element by attaching 0 for blue, and 1 for alpha. Each component is
     *    clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RGB}: Each element is an RGB triple. The GL converts it
     *    to floating point and assembles it into an RGBA element by
     *    attaching 1 for alpha. Each component is clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RGBA}: Each element contains all four components. Each
     *    component clamped to the range [0,1].
     *
     *  - {@see GL46::GL_DEPTH_COMPONENT}: Each element is a single depth value.
     *    The GL converts it to floating point and clamps to the range [0,1].
     *
     * If an application wants to store the texture at a certain resolution or in a certain format, it can request
     * the resolution and format with $internalformat. The GL will choose an internal representation that closely
     * approximates that requested by $internalformat, but it may not match exactly. (The representations specified
     * by {@see GL46::GL_RED}, {@see GL46::GL_RG}, {@see GL46::GL_RGB} and {@see GL46::GL_RGBA} must match exactly.)
     *
     * $internalformat may be one of the base internal formats shown in Table 1, below
     *
     * $internalformat may also be one of the sized internal formats shown in Table 2, below
     *
     * Finally, $internalformat may also be one of the generic or compressed texture formats shown in Table 3 below
     *
     * If the $internalformat parameter is one of the generic compressed formats, {@see GL46::GL_COMPRESSED_RED},
     * {@see GL46::GL_COMPRESSED_RG}, {@see GL46::GL_COMPRESSED_RGB}, or {@see GL46::GL_COMPRESSED_RGBA}, the GL will
     * replace the internal format with the symbolic constant for a specific internal format and compress the texture
     * before storage. If no corresponding internal format is available, or the GL can not compress that image for
     * any reason, the internal format is instead replaced with a corresponding base internal format.
     *
     * If the $internalformat parameter is {@see GL46::GL_SRGB}, {@see GL46::GL_SRGB8}, {@see GL46::GL_SRGB_ALPHA}or
     * {@see GL46::GL_SRGB8_ALPHA8}, the texture is treated as if the red, green, or blue components are encoded in
     * the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component  c
     * s   to a linear component  c l   is:
     *
     *    c l  =  {      c s  12.92      if    c s  ≤ 0.04045       (    c s  + 0.055  1.055  )  2.4      if    c s
     *  &gt; 0.04045
     *
     * Assume  c s   is the sRGB component in the range [0,1].
     *
     * Use the {@see GL46::GL_PROXY_TEXTURE_1D} target to try out a resolution and format. The implementation will
     * update and recompute its best match for the requested storage resolution and format. To then query this state,
     * call {@see GL46::glGetTexLevelParameter}. If the texture cannot be accommodated, texture state is set to 0.
     *
     * A one-component texture image uses only the red component of the RGBA color from $data. A two-component image
     * uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all
     * of the RGBA components.
     *
     * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a
     * boolean result. See {@see GL46::glTexParameter} for details on texture comparison.
     *
     * @see http://docs.gl/gl2/glTexImage1D
     * @see http://docs.gl/gl4/glTexImage1D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $internalformat
     * @param int $width
     * @param int $border
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function texImage1D(int $target, int $level, int $internalformat, int $width, int $border, int $format, int $type, ?\FFI\CData $pixels): void
    {
        $this->info->ffi->glTexImage1D($target, $level, $internalformat, $width, $border, $format, $type, $pixels);
    }

    /**
     * Texturing allows elements of an image array to be read by shaders.
     *
     * To define texture images, call {@see GL46::glTexImage2D}. The arguments describe the parameters of the texture
     * image, such as height, width, width of the border, level-of-detail number (see {@see GL46::glTexParameter}),
     * and number of color components provided. The last three arguments describe how the image is represented in
     * memory.
     *
     * If $target is {@see GL46::GL_PROXY_TEXTURE_2D}, {@see GL46::GL_PROXY_TEXTURE_1D_ARRAY},
     * {@see GL46::GL_PROXY_TEXTURE_CUBE_MAP}, or {@see GL46::GL_PROXY_TEXTURE_RECTANGLE}, no data is read from
     * $data, but all of the texture image state is recalculated, checked for consistency, and checked against the
     * implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it
     * sets all of the image state to 0, but does not generate an error (see {@see GL46::glGetError}). To query for
     * an entire mipmap array, use an image array level greater than or equal to 1.
     *
     * If $target is {@see GL46::GL_TEXTURE_2D}, {@see GL46::GL_TEXTURE_RECTANGLE} or one of the
     * {@see GL46::GL_TEXTURE_CUBE_MAP} targets, data is read from $data as a sequence of signed or unsigned bytes,
     * shorts, or longs, or single-precision floating-point values, depending on $type. These values are grouped into
     * sets of one, two, three, or four values, depending on $format, to form elements. Each data byte is treated as
     * eight 1-bit elements, with bit ordering determined by {@see GL46::GL_UNPACK_LSB_FIRST} (see
     * {@see GL46::glPixelStore}).
     *
     * If $target is {@see GL46::GL_TEXTURE_1D_ARRAY}, data is interpreted as an array of one-dimensional images.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture image is specified, $data is treated as a byte offset into the
     * buffer object's data store.
     *
     * The first element corresponds to the lower left corner of the texture image. Subsequent elements progress
     * left-to-right through the remaining texels in the lowest row of the texture image, and then in successively
     * higher rows of the texture image. The final element corresponds to the upper right corner of the texture
     * image.
     *
     * $format determines the composition of each element in $data. It can assume one of these symbolic values:
     *
     *  - {@see GL46::GL_RED}: Each element is a single red component. The GL
     *    converts it to floating point and assembles it into an RGBA
     *    element by attaching 0 for green and blue, and 1 for alpha. Each
     *    component is clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RG}: Each element is a red/green double. The GL
     *    converts it to floating point and assembles it into an RGBA
     *    element by attaching 0 for blue, and 1 for alpha. Each component is
     *    clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RGB}: Each element is an RGB triple. The GL converts it
     *    to floating point and assembles it into an RGBA element by
     *    attaching 1 for alpha. Each component is clamped to the range [0,1].
     *
     *  - {@see GL46::GL_RGBA}: Each element contains all four components. Each
     *    component is clamped to the range [0,1].
     *
     *  - {@see GL46::GL_DEPTH_COMPONENT}: Each element is a single depth value.
     *    The GL converts it to floating point and clamps to the range [0,1].
     *
     *  - {@see GL46::GL_DEPTH_STENCIL}: Each element is a pair of depth and
     *    stencil values. The depth component of the pair is interpreted as in
     *    {@see GL46::GL_DEPTH_COMPONENT}. The stencil component is interpreted
     *    based on specified the depth + stencil
     *    internal format.
     *
     * If an application wants to store the texture at a certain resolution or in a certain format, it can request
     * the resolution and format with $internalformat. The GL will choose an internal representation that closely
     * approximates that requested by $internalformat, but it may not match exactly. (The representations specified
     * by {@see GL46::GL_RED}, {@see GL46::GL_RG}, {@see GL46::GL_RGB}, and {@see GL46::GL_RGBA} must match exactly.)
     *
     * $internalformat may be one of the base internal formats shown in Table 1, below
     *
     * $internalformat may also be one of the sized internal formats shown in Table 2, below
     *
     * Finally, $internalformat may also be one of the generic or compressed texture formats shown in Table 3 below
     *
     * If the $internalformat parameter is one of the generic compressed formats, {@see GL46::GL_COMPRESSED_RED},
     * {@see GL46::GL_COMPRESSED_RG}, {@see GL46::GL_COMPRESSED_RGB}, or {@see GL46::GL_COMPRESSED_RGBA}, the GL will
     * replace the internal format with the symbolic constant for a specific internal format and compress the texture
     * before storage. If no corresponding internal format is available, or the GL can not compress that image for
     * any reason, the internal format is instead replaced with a corresponding base internal format.
     *
     * If the $internalformat parameter is {@see GL46::GL_SRGB}, {@see GL46::GL_SRGB8}, {@see GL46::GL_SRGB_ALPHA},
     * or {@see GL46::GL_SRGB8_ALPHA8}, the texture is treated as if the red, green, or blue components are encoded
     * in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component
     *  c s   to a linear component  c l   is:
     *
     *    c l  =  {      c s  12.92      if    c s  ≤ 0.04045       (    c s  + 0.055  1.055  )  2.4      if    c s
     *  &gt; 0.04045
     *
     * Assume  c s   is the sRGB component in the range [0,1].
     *
     * Use the {@see GL46::GL_PROXY_TEXTURE_2D}, {@see GL46::GL_PROXY_TEXTURE_1D_ARRAY},
     * {@see GL46::GL_PROXY_TEXTURE_RECTANGLE}, or {@see GL46::GL_PROXY_TEXTURE_CUBE_MAP} target to try out a
     * resolution and format. The implementation will update and recompute its best match for the requested storage
     * resolution and format. To then query this state, call {@see GL46::glGetTexLevelParameter}. If the texture
     * cannot be accommodated, texture state is set to 0.
     *
     * A one-component texture image uses only the red component of the RGBA color extracted from $data. A
     * two-component image uses the R and G values. A three-component image uses the R, G, and B values. A
     * four-component image uses all of the RGBA components.
     *
     * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a
     * boolean result. See {@see GL46::glTexParameter} for details on texture comparison.
     *
     * @see http://docs.gl/gl2/glTexImage2D
     * @see http://docs.gl/gl4/glTexImage2D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $internalformat
     * @param int $width
     * @param int $height
     * @param int $border
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function texImage2D(
        int $target,
        int $level,
        int $internalformat,
        int $width,
        int $height,
        int $border,
        int $format,
        int $type,
        ?\FFI\CData $pixels
    ): void {
        $this->info->ffi->glTexImage2D($target, $level, $internalformat, $width, $height, $border, $format, $type, $pixels);
    }

    /**
     * {@see GL46::glTexParameter} and {@see GL46::glTextureParameter} assign the value or values in $params to the
     * texture parameter specified as $pname. For {@see GL46::glTexParameter}, $target defines the target texture,
     * either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE},
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, or {@see GL46::GL_TEXTURE_RECTANGLE}. The following symbols are
     * accepted in $pname:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Specifies the mode used to
     *    read from depth-stencil format textures. $params must be one of
     *    {@see GL46::GL_DEPTH_COMPONENT} or {@see GL46::GL_STENCIL_INDEX}. If
     *    the depth stencil mode is
     *    {@see GL46::GL_DEPTH_COMPONENT}, then reads from depth-stencil format
     *    textures will return the depth component
     *    of the texel in Rt and the stencil component will be discarded. If the
     *    depth stencil mode is
     *    {@see GL46::GL_STENCIL_INDEX} then the stencil component is returned
     *    in Rt and the depth component is
     *    discarded. The initial value is {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Specifies the index of the lowest
     *    defined mipmap level. This is an integer value. The initial value is
     *    0.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: The data in $params specifies
     *    four values that define the border values that should be used for
     *    border
     *    texels. If a texel is sampled from the border of the texture, the
     *    values of
     *    {@see GL46::GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color
     *    to match the texture's internal format
     *    and substituted for the non-existent texel data. If the texture
     *    contains depth components, the first component
     *    of {@see GL46::GL_TEXTURE_BORDER_COLOR} is interpreted as a depth
     *    value. The initial value is     0.0 , 0.0 ,
     *    0.0 , 0.0    .   If the values for {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR} are specified with
     *    {@see GL46::glTexParameterIiv} or {@see GL46::glTexParameterIuiv}, the
     *    values are stored unmodified with an
     *    internal data type of integer. If specified with {@see
     *    GL46::glTexParameteriv}, they are converted to floating
     *    point with the following equation:   f =   2 c + 1    2 b  - 1    . If
     *    specified with
     *    {@see GL46::glTexParameterfv}, they are stored unmodified as
     *    floating-point values.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Specifies the comparison
     *    operator used when {@see GL46::GL_TEXTURE_COMPARE_MODE} is set to
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
     *     Texture Comparison Function
     *    Computed result        {@see GL46::GL_LEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &lt;=  D t       r
     *    &gt;  D t              {@see GL46::GL_GEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &gt;=  D t       r
     *    &lt;  D t              {@see GL46::GL_LESS}      result =     1.0
     *    0.0   &amp;it;     r &lt;  D t       r
     *    &gt;=  D t              {@see GL46::GL_GREATER}      result =     1.0
     *     0.0   &amp;it;     r &gt;  D t       r
     *    &lt;=  D t              {@see GL46::GL_EQUAL}      result =     1.0
     *    0.0   &amp;it;     r =  D t       r ≠
     *    D t              {@see GL46::GL_NOTEQUAL}      result =     1.0   0.0
     *     &amp;it;     r ≠  D t       r =  D t
     *                 {@see GL46::GL_ALWAYS}      result = 1.0        {@see
     *    GL46::GL_NEVER}      result = 0.0
     *    where r is the current interpolated texture coordinate, and   D t   is
     *    the depth texture value sampled from
     *    the currently bound depth texture. result is assigned to the red
     *    channel.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Specifies the texture comparison
     *    mode for currently bound depth textures. That is, a texture whose
     *    internal
     *    format is {@see GL46::GL_DEPTH_COMPONENT_*}; see {@see
     *    GL46::glTexImage2D}) Permissible values are:
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}   Specifies that the
     *    interpolated and clamped r texture coordinate
     *    should be compared to the value in the currently bound depth texture.
     *    See the discussion of
     *    {@see GL46::GL_TEXTURE_COMPARE_FUNC} for details of how the comparison
     *    is evaluated. The result of the
     *    comparison is assigned to the red channel.     {@see GL46::GL_NONE}
     *    Specifies that the red channel should be
     *    assigned the appropriate value from the currently bound depth texture.
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params specifies a fixed bias value
     *    that is to be added to the level-of-detail parameter for the texture
     *    before texture sampling. The specified value is added to the
     *    shader-supplied bias value (if any) and
     *    subsequently clamped into the implementation-defined range     -  bias
     *    max        bias max      , where   bias
     *    max    is the value of the implementation defined constant {@see
     *    GL46::GL_MAX_TEXTURE_LOD_BIAS}. The initial
     *    value is 0.0.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: The texture minifying function is
     *    used whenever the level-of-detail function used when sampling from the
     *    texture determines that the texture should be minified. There are six
     *    defined minifying functions. Two of them
     *    use either the nearest texture elements or a weighted average of
     *    multiple texture elements to compute the
     *    texture value. The other four use mipmaps.   A mipmap is an ordered
     *    set of arrays representing the same image
     *    at progressively lower resolutions. If the texture has dimensions    2
     *    n  × 2 m   , there are     max
     *    &amp;af;  n m   + 1   mipmaps. The first mipmap is the original
     *    texture, with dimensions    2 n  × 2 m   .
     *    Each subsequent mipmap has dimensions    2   k - 1    × 2   l - 1
     *    , where    2 k  × 2 l    are the
     *    dimensions of the previous mipmap, until either    k = 0   or    l = 0
     *     . At that point, subsequent mipmaps
     *    have dimension    1 × 2   l - 1      or    2   k - 1    × 1   until
     *    the final mipmap, which has dimension
     *    1 × 1  . To define the mipmaps, call {@see GL46::glTexImage1D}, {@see
     *    GL46::glTexImage2D},
     *    {@see GL46::glTexImage3D}, {@see GL46::glCopyTexImage1D}, or {@see
     *    GL46::glCopyTexImage2D} with the level
     *    argument indicating the order of the mipmaps. Level 0 is the original
     *    texture; level    max &amp;af;  n m
     *    is the final    1 × 1   mipmap.   $params supplies a function for
     *    minifying the texture as one of the
     *    following:   {@see GL46::GL_NEAREST}   Returns the value of the
     *    texture element that is nearest (in Manhattan
     *    distance) to the specified texture coordinates.     {@see
     *    GL46::GL_LINEAR}   Returns the weighted average of
     *    the four texture elements that are closest to the specified texture
     *    coordinates. These can include items
     *    wrapped or repeated from other parts of a texture, depending on the
     *    values of {@see GL46::GL_TEXTURE_WRAP_S}
     *    and {@see GL46::GL_TEXTURE_WRAP_T}, and on the exact mapping.
     *    {@see GL46::GL_NEAREST_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely matches the size of the pixel
     *    being textured and uses the
     *    {@see GL46::GL_NEAREST} criterion (the texture element closest to the
     *    specified texture coordinates) to
     *    produce a texture value.     {@see GL46::GL_LINEAR_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely
     *    matches the size of the pixel being textured and uses the {@see
     *    GL46::GL_LINEAR} criterion (a weighted average
     *    of the four texture elements that are closest to the specified texture
     *    coordinates) to produce a texture
     *    value.     {@see GL46::GL_NEAREST_MIPMAP_LINEAR}   Chooses the two
     *    mipmaps that most closely match the size of
     *    the pixel being textured and uses the {@see GL46::GL_NEAREST}
     *    criterion (the texture element closest to the
     *    specified texture coordinates ) to produce a texture value from each
     *    mipmap. The final texture value is a
     *    weighted average of those two values.     {@see
     *    GL46::GL_LINEAR_MIPMAP_LINEAR}   Chooses the two mipmaps that
     *    most closely match the size of the pixel being textured and uses the
     *    {@see GL46::GL_LINEAR} criterion (a
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates) to produce a
     *    texture value from each mipmap. The final texture value is a weighted
     *    average of those two values.       As
     *    more texture elements are sampled in the minification process, fewer
     *    aliasing artifacts will be apparent.
     *    While the {@see GL46::GL_NEAREST} and {@see GL46::GL_LINEAR}
     *    minification functions can be faster than the
     *    other four, they sample only one or multiple texture elements to
     *    determine the texture value of the pixel
     *    being rendered and can produce moire patterns or ragged transitions.
     *    The initial value of
     *    {@see GL46::GL_TEXTURE_MIN_FILTER} is {@see
     *    GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: The texture magnification function
     *    is used whenever the level-of-detail function used when sampling from
     *    the
     *    texture determines that the texture should be magified. It sets the
     *    texture magnification function to either
     *    {@see GL46::GL_NEAREST} or {@see GL46::GL_LINEAR} (see below). {@see
     *    GL46::GL_NEAREST} is generally faster
     *    than {@see GL46::GL_LINEAR}, but it can produce textured images with
     *    sharper edges because the transition
     *    between texture elements is not as smooth. The initial value of {@see
     *    GL46::GL_TEXTURE_MAG_FILTER} is
     *    {@see GL46::GL_LINEAR}.   {@see GL46::GL_NEAREST}   Returns the value
     *    of the texture element that is nearest
     *    (in Manhattan distance) to the specified texture coordinates.
     *    {@see GL46::GL_LINEAR}   Returns the
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates. These can
     *    include items wrapped or repeated from other parts of a texture,
     *    depending on the values of
     *    {@see GL46::GL_TEXTURE_WRAP_S} and {@see GL46::GL_TEXTURE_WRAP_T}, and
     *    on the exact mapping.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Sets the minimum level-of-detail
     *    parameter. This floating-point value limits the selection of highest
     *    resolution mipmap (lowest mipmap level). The initial value is -1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Sets the maximum level-of-detail
     *    parameter. This floating-point value limits the selection of the
     *    lowest
     *    resolution mipmap (highest mipmap level). The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Sets the index of the highest
     *    defined mipmap level. This is an integer value. The initial value is
     *    1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Sets the swizzle that will be
     *    applied to the r component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param are {@see GL46::GL_RED}, {@see
     *    GL46::GL_GREEN}, {@see GL46::GL_BLUE},
     *    {@see GL46::GL_ALPHA}, {@see GL46::GL_ZERO} and {@see GL46::GL_ONE}.
     *    If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_RED}, the value for r will be taken from the first
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_GREEN}, the value
     *    for r will be taken from the second
     *    channel of the fetched texel. If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_BLUE}, the value for r
     *    will be taken from the third channel of the fetched texel. If {@see
     *    GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_ALPHA}, the value for r will be taken from the fourth
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ZERO}, the value
     *    for r will be subtituted with 0.0. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ONE}, the value
     *    for r will be subtituted with 1.0. The
     *    initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Sets the swizzle that will be
     *    applied to the g component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Sets the swizzle that will be
     *    applied to the b component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Sets the swizzle that will be
     *    applied to the a component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Sets the swizzles that will be
     *    applied to the r, g, b, and a components of a texel before they are
     *    returned
     *    to the shader. Valid values for $params and their effects are similar
     *    to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}, except that all channels are
     *    specified simultaneously. Setting the value of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors
     *    are generated) to setting the
     *    parameters of each of {@see GL46::GL_TEXTURE_SWIZZLE_R}, {@see
     *    GL46::GL_TEXTURE_SWIZZLE_G},
     *    {@see GL46::GL_TEXTURE_SWIZZLE_B}, and {@see
     *    GL46::GL_TEXTURE_SWIZZLE_A} successively.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Sets the wrap parameter for texture
     *    coordinate s to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. {@see GL46::GL_CLAMP_TO_EDGE}
     *    causes s coordinates to be clamped to the
     *    range       1  2N      1 -    1  2N       , where N is the size of the
     *    texture in the direction of clamping.
     *    {@see GL46::GL_CLAMP_TO_BORDER} evaluates s coordinates in a similar
     *    manner to {@see GL46::GL_CLAMP_TO_EDGE}.
     *    However, in cases where clamping would have occurred in {@see
     *    GL46::GL_CLAMP_TO_EDGE} mode, the fetched texel
     *    data is substituted with the values specified by {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR}. {@see GL46::GL_REPEAT}
     *    causes the integer part of the s coordinate to be ignored; the GL uses
     *    only the fractional part, thereby
     *    creating a repeating pattern. {@see GL46::GL_MIRRORED_REPEAT} causes
     *    the s coordinate to be set to the
     *    fractional part of the texture coordinate if the integer part of s is
     *    even; if the integer part of s is odd,
     *    then the s texture coordinate is set to    1 -  frac &amp;af;  s    ,
     *    where    frac &amp;af;  s    represents
     *    the fractional part of s. {@see GL46::GL_MIRROR_CLAMP_TO_EDGE} causes
     *    the s coordinate to be repeated as for
     *    {@see GL46::GL_MIRRORED_REPEAT} for one repetition of the texture, at
     *    which point the coordinate to be clamped
     *    as in {@see GL46::GL_CLAMP_TO_EDGE}. Initially, {@see
     *    GL46::GL_TEXTURE_WRAP_S} is set to
     *    {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Sets the wrap parameter for texture
     *    coordinate t to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_T} is set to {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Sets the wrap parameter for texture
     *    coordinate r to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_R} is set to {@see GL46::GL_REPEAT}.
     *
     * @see http://docs.gl/gl2/glTexParameter
     * @see http://docs.gl/gl4/glTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param float $param
     * @return void
     */
    public function texParameterf(int $target, int $pname, float $param): void
    {
        $this->info->ffi->glTexParameterf($target, $pname, $param);
    }

    /**
     * {@see GL46::glTexParameter} and {@see GL46::glTextureParameter} assign the value or values in $params to the
     * texture parameter specified as $pname. For {@see GL46::glTexParameter}, $target defines the target texture,
     * either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE},
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, or {@see GL46::GL_TEXTURE_RECTANGLE}. The following symbols are
     * accepted in $pname:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Specifies the mode used to
     *    read from depth-stencil format textures. $params must be one of
     *    {@see GL46::GL_DEPTH_COMPONENT} or {@see GL46::GL_STENCIL_INDEX}. If
     *    the depth stencil mode is
     *    {@see GL46::GL_DEPTH_COMPONENT}, then reads from depth-stencil format
     *    textures will return the depth component
     *    of the texel in Rt and the stencil component will be discarded. If the
     *    depth stencil mode is
     *    {@see GL46::GL_STENCIL_INDEX} then the stencil component is returned
     *    in Rt and the depth component is
     *    discarded. The initial value is {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Specifies the index of the lowest
     *    defined mipmap level. This is an integer value. The initial value is
     *    0.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: The data in $params specifies
     *    four values that define the border values that should be used for
     *    border
     *    texels. If a texel is sampled from the border of the texture, the
     *    values of
     *    {@see GL46::GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color
     *    to match the texture's internal format
     *    and substituted for the non-existent texel data. If the texture
     *    contains depth components, the first component
     *    of {@see GL46::GL_TEXTURE_BORDER_COLOR} is interpreted as a depth
     *    value. The initial value is     0.0 , 0.0 ,
     *    0.0 , 0.0    .   If the values for {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR} are specified with
     *    {@see GL46::glTexParameterIiv} or {@see GL46::glTexParameterIuiv}, the
     *    values are stored unmodified with an
     *    internal data type of integer. If specified with {@see
     *    GL46::glTexParameteriv}, they are converted to floating
     *    point with the following equation:   f =   2 c + 1    2 b  - 1    . If
     *    specified with
     *    {@see GL46::glTexParameterfv}, they are stored unmodified as
     *    floating-point values.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Specifies the comparison
     *    operator used when {@see GL46::GL_TEXTURE_COMPARE_MODE} is set to
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
     *     Texture Comparison Function
     *    Computed result        {@see GL46::GL_LEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &lt;=  D t       r
     *    &gt;  D t              {@see GL46::GL_GEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &gt;=  D t       r
     *    &lt;  D t              {@see GL46::GL_LESS}      result =     1.0
     *    0.0   &amp;it;     r &lt;  D t       r
     *    &gt;=  D t              {@see GL46::GL_GREATER}      result =     1.0
     *     0.0   &amp;it;     r &gt;  D t       r
     *    &lt;=  D t              {@see GL46::GL_EQUAL}      result =     1.0
     *    0.0   &amp;it;     r =  D t       r ≠
     *    D t              {@see GL46::GL_NOTEQUAL}      result =     1.0   0.0
     *     &amp;it;     r ≠  D t       r =  D t
     *                 {@see GL46::GL_ALWAYS}      result = 1.0        {@see
     *    GL46::GL_NEVER}      result = 0.0
     *    where r is the current interpolated texture coordinate, and   D t   is
     *    the depth texture value sampled from
     *    the currently bound depth texture. result is assigned to the red
     *    channel.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Specifies the texture comparison
     *    mode for currently bound depth textures. That is, a texture whose
     *    internal
     *    format is {@see GL46::GL_DEPTH_COMPONENT_*}; see {@see
     *    GL46::glTexImage2D}) Permissible values are:
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}   Specifies that the
     *    interpolated and clamped r texture coordinate
     *    should be compared to the value in the currently bound depth texture.
     *    See the discussion of
     *    {@see GL46::GL_TEXTURE_COMPARE_FUNC} for details of how the comparison
     *    is evaluated. The result of the
     *    comparison is assigned to the red channel.     {@see GL46::GL_NONE}
     *    Specifies that the red channel should be
     *    assigned the appropriate value from the currently bound depth texture.
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params specifies a fixed bias value
     *    that is to be added to the level-of-detail parameter for the texture
     *    before texture sampling. The specified value is added to the
     *    shader-supplied bias value (if any) and
     *    subsequently clamped into the implementation-defined range     -  bias
     *    max        bias max      , where   bias
     *    max    is the value of the implementation defined constant {@see
     *    GL46::GL_MAX_TEXTURE_LOD_BIAS}. The initial
     *    value is 0.0.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: The texture minifying function is
     *    used whenever the level-of-detail function used when sampling from the
     *    texture determines that the texture should be minified. There are six
     *    defined minifying functions. Two of them
     *    use either the nearest texture elements or a weighted average of
     *    multiple texture elements to compute the
     *    texture value. The other four use mipmaps.   A mipmap is an ordered
     *    set of arrays representing the same image
     *    at progressively lower resolutions. If the texture has dimensions    2
     *    n  × 2 m   , there are     max
     *    &amp;af;  n m   + 1   mipmaps. The first mipmap is the original
     *    texture, with dimensions    2 n  × 2 m   .
     *    Each subsequent mipmap has dimensions    2   k - 1    × 2   l - 1
     *    , where    2 k  × 2 l    are the
     *    dimensions of the previous mipmap, until either    k = 0   or    l = 0
     *     . At that point, subsequent mipmaps
     *    have dimension    1 × 2   l - 1      or    2   k - 1    × 1   until
     *    the final mipmap, which has dimension
     *    1 × 1  . To define the mipmaps, call {@see GL46::glTexImage1D}, {@see
     *    GL46::glTexImage2D},
     *    {@see GL46::glTexImage3D}, {@see GL46::glCopyTexImage1D}, or {@see
     *    GL46::glCopyTexImage2D} with the level
     *    argument indicating the order of the mipmaps. Level 0 is the original
     *    texture; level    max &amp;af;  n m
     *    is the final    1 × 1   mipmap.   $params supplies a function for
     *    minifying the texture as one of the
     *    following:   {@see GL46::GL_NEAREST}   Returns the value of the
     *    texture element that is nearest (in Manhattan
     *    distance) to the specified texture coordinates.     {@see
     *    GL46::GL_LINEAR}   Returns the weighted average of
     *    the four texture elements that are closest to the specified texture
     *    coordinates. These can include items
     *    wrapped or repeated from other parts of a texture, depending on the
     *    values of {@see GL46::GL_TEXTURE_WRAP_S}
     *    and {@see GL46::GL_TEXTURE_WRAP_T}, and on the exact mapping.
     *    {@see GL46::GL_NEAREST_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely matches the size of the pixel
     *    being textured and uses the
     *    {@see GL46::GL_NEAREST} criterion (the texture element closest to the
     *    specified texture coordinates) to
     *    produce a texture value.     {@see GL46::GL_LINEAR_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely
     *    matches the size of the pixel being textured and uses the {@see
     *    GL46::GL_LINEAR} criterion (a weighted average
     *    of the four texture elements that are closest to the specified texture
     *    coordinates) to produce a texture
     *    value.     {@see GL46::GL_NEAREST_MIPMAP_LINEAR}   Chooses the two
     *    mipmaps that most closely match the size of
     *    the pixel being textured and uses the {@see GL46::GL_NEAREST}
     *    criterion (the texture element closest to the
     *    specified texture coordinates ) to produce a texture value from each
     *    mipmap. The final texture value is a
     *    weighted average of those two values.     {@see
     *    GL46::GL_LINEAR_MIPMAP_LINEAR}   Chooses the two mipmaps that
     *    most closely match the size of the pixel being textured and uses the
     *    {@see GL46::GL_LINEAR} criterion (a
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates) to produce a
     *    texture value from each mipmap. The final texture value is a weighted
     *    average of those two values.       As
     *    more texture elements are sampled in the minification process, fewer
     *    aliasing artifacts will be apparent.
     *    While the {@see GL46::GL_NEAREST} and {@see GL46::GL_LINEAR}
     *    minification functions can be faster than the
     *    other four, they sample only one or multiple texture elements to
     *    determine the texture value of the pixel
     *    being rendered and can produce moire patterns or ragged transitions.
     *    The initial value of
     *    {@see GL46::GL_TEXTURE_MIN_FILTER} is {@see
     *    GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: The texture magnification function
     *    is used whenever the level-of-detail function used when sampling from
     *    the
     *    texture determines that the texture should be magified. It sets the
     *    texture magnification function to either
     *    {@see GL46::GL_NEAREST} or {@see GL46::GL_LINEAR} (see below). {@see
     *    GL46::GL_NEAREST} is generally faster
     *    than {@see GL46::GL_LINEAR}, but it can produce textured images with
     *    sharper edges because the transition
     *    between texture elements is not as smooth. The initial value of {@see
     *    GL46::GL_TEXTURE_MAG_FILTER} is
     *    {@see GL46::GL_LINEAR}.   {@see GL46::GL_NEAREST}   Returns the value
     *    of the texture element that is nearest
     *    (in Manhattan distance) to the specified texture coordinates.
     *    {@see GL46::GL_LINEAR}   Returns the
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates. These can
     *    include items wrapped or repeated from other parts of a texture,
     *    depending on the values of
     *    {@see GL46::GL_TEXTURE_WRAP_S} and {@see GL46::GL_TEXTURE_WRAP_T}, and
     *    on the exact mapping.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Sets the minimum level-of-detail
     *    parameter. This floating-point value limits the selection of highest
     *    resolution mipmap (lowest mipmap level). The initial value is -1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Sets the maximum level-of-detail
     *    parameter. This floating-point value limits the selection of the
     *    lowest
     *    resolution mipmap (highest mipmap level). The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Sets the index of the highest
     *    defined mipmap level. This is an integer value. The initial value is
     *    1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Sets the swizzle that will be
     *    applied to the r component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param are {@see GL46::GL_RED}, {@see
     *    GL46::GL_GREEN}, {@see GL46::GL_BLUE},
     *    {@see GL46::GL_ALPHA}, {@see GL46::GL_ZERO} and {@see GL46::GL_ONE}.
     *    If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_RED}, the value for r will be taken from the first
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_GREEN}, the value
     *    for r will be taken from the second
     *    channel of the fetched texel. If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_BLUE}, the value for r
     *    will be taken from the third channel of the fetched texel. If {@see
     *    GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_ALPHA}, the value for r will be taken from the fourth
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ZERO}, the value
     *    for r will be subtituted with 0.0. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ONE}, the value
     *    for r will be subtituted with 1.0. The
     *    initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Sets the swizzle that will be
     *    applied to the g component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Sets the swizzle that will be
     *    applied to the b component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Sets the swizzle that will be
     *    applied to the a component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Sets the swizzles that will be
     *    applied to the r, g, b, and a components of a texel before they are
     *    returned
     *    to the shader. Valid values for $params and their effects are similar
     *    to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}, except that all channels are
     *    specified simultaneously. Setting the value of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors
     *    are generated) to setting the
     *    parameters of each of {@see GL46::GL_TEXTURE_SWIZZLE_R}, {@see
     *    GL46::GL_TEXTURE_SWIZZLE_G},
     *    {@see GL46::GL_TEXTURE_SWIZZLE_B}, and {@see
     *    GL46::GL_TEXTURE_SWIZZLE_A} successively.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Sets the wrap parameter for texture
     *    coordinate s to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. {@see GL46::GL_CLAMP_TO_EDGE}
     *    causes s coordinates to be clamped to the
     *    range       1  2N      1 -    1  2N       , where N is the size of the
     *    texture in the direction of clamping.
     *    {@see GL46::GL_CLAMP_TO_BORDER} evaluates s coordinates in a similar
     *    manner to {@see GL46::GL_CLAMP_TO_EDGE}.
     *    However, in cases where clamping would have occurred in {@see
     *    GL46::GL_CLAMP_TO_EDGE} mode, the fetched texel
     *    data is substituted with the values specified by {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR}. {@see GL46::GL_REPEAT}
     *    causes the integer part of the s coordinate to be ignored; the GL uses
     *    only the fractional part, thereby
     *    creating a repeating pattern. {@see GL46::GL_MIRRORED_REPEAT} causes
     *    the s coordinate to be set to the
     *    fractional part of the texture coordinate if the integer part of s is
     *    even; if the integer part of s is odd,
     *    then the s texture coordinate is set to    1 -  frac &amp;af;  s    ,
     *    where    frac &amp;af;  s    represents
     *    the fractional part of s. {@see GL46::GL_MIRROR_CLAMP_TO_EDGE} causes
     *    the s coordinate to be repeated as for
     *    {@see GL46::GL_MIRRORED_REPEAT} for one repetition of the texture, at
     *    which point the coordinate to be clamped
     *    as in {@see GL46::GL_CLAMP_TO_EDGE}. Initially, {@see
     *    GL46::GL_TEXTURE_WRAP_S} is set to
     *    {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Sets the wrap parameter for texture
     *    coordinate t to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_T} is set to {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Sets the wrap parameter for texture
     *    coordinate r to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_R} is set to {@see GL46::GL_REPEAT}.
     *
     * @see http://docs.gl/gl2/glTexParameter
     * @see http://docs.gl/gl4/glTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texParameterfv(int $target, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexParameterfv($target, $pname, $params);
    }

    /**
     * {@see GL46::glTexParameter} and {@see GL46::glTextureParameter} assign the value or values in $params to the
     * texture parameter specified as $pname. For {@see GL46::glTexParameter}, $target defines the target texture,
     * either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE},
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, or {@see GL46::GL_TEXTURE_RECTANGLE}. The following symbols are
     * accepted in $pname:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Specifies the mode used to
     *    read from depth-stencil format textures. $params must be one of
     *    {@see GL46::GL_DEPTH_COMPONENT} or {@see GL46::GL_STENCIL_INDEX}. If
     *    the depth stencil mode is
     *    {@see GL46::GL_DEPTH_COMPONENT}, then reads from depth-stencil format
     *    textures will return the depth component
     *    of the texel in Rt and the stencil component will be discarded. If the
     *    depth stencil mode is
     *    {@see GL46::GL_STENCIL_INDEX} then the stencil component is returned
     *    in Rt and the depth component is
     *    discarded. The initial value is {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Specifies the index of the lowest
     *    defined mipmap level. This is an integer value. The initial value is
     *    0.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: The data in $params specifies
     *    four values that define the border values that should be used for
     *    border
     *    texels. If a texel is sampled from the border of the texture, the
     *    values of
     *    {@see GL46::GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color
     *    to match the texture's internal format
     *    and substituted for the non-existent texel data. If the texture
     *    contains depth components, the first component
     *    of {@see GL46::GL_TEXTURE_BORDER_COLOR} is interpreted as a depth
     *    value. The initial value is     0.0 , 0.0 ,
     *    0.0 , 0.0    .   If the values for {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR} are specified with
     *    {@see GL46::glTexParameterIiv} or {@see GL46::glTexParameterIuiv}, the
     *    values are stored unmodified with an
     *    internal data type of integer. If specified with {@see
     *    GL46::glTexParameteriv}, they are converted to floating
     *    point with the following equation:   f =   2 c + 1    2 b  - 1    . If
     *    specified with
     *    {@see GL46::glTexParameterfv}, they are stored unmodified as
     *    floating-point values.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Specifies the comparison
     *    operator used when {@see GL46::GL_TEXTURE_COMPARE_MODE} is set to
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
     *     Texture Comparison Function
     *    Computed result        {@see GL46::GL_LEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &lt;=  D t       r
     *    &gt;  D t              {@see GL46::GL_GEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &gt;=  D t       r
     *    &lt;  D t              {@see GL46::GL_LESS}      result =     1.0
     *    0.0   &amp;it;     r &lt;  D t       r
     *    &gt;=  D t              {@see GL46::GL_GREATER}      result =     1.0
     *     0.0   &amp;it;     r &gt;  D t       r
     *    &lt;=  D t              {@see GL46::GL_EQUAL}      result =     1.0
     *    0.0   &amp;it;     r =  D t       r ≠
     *    D t              {@see GL46::GL_NOTEQUAL}      result =     1.0   0.0
     *     &amp;it;     r ≠  D t       r =  D t
     *                 {@see GL46::GL_ALWAYS}      result = 1.0        {@see
     *    GL46::GL_NEVER}      result = 0.0
     *    where r is the current interpolated texture coordinate, and   D t   is
     *    the depth texture value sampled from
     *    the currently bound depth texture. result is assigned to the red
     *    channel.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Specifies the texture comparison
     *    mode for currently bound depth textures. That is, a texture whose
     *    internal
     *    format is {@see GL46::GL_DEPTH_COMPONENT_*}; see {@see
     *    GL46::glTexImage2D}) Permissible values are:
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}   Specifies that the
     *    interpolated and clamped r texture coordinate
     *    should be compared to the value in the currently bound depth texture.
     *    See the discussion of
     *    {@see GL46::GL_TEXTURE_COMPARE_FUNC} for details of how the comparison
     *    is evaluated. The result of the
     *    comparison is assigned to the red channel.     {@see GL46::GL_NONE}
     *    Specifies that the red channel should be
     *    assigned the appropriate value from the currently bound depth texture.
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params specifies a fixed bias value
     *    that is to be added to the level-of-detail parameter for the texture
     *    before texture sampling. The specified value is added to the
     *    shader-supplied bias value (if any) and
     *    subsequently clamped into the implementation-defined range     -  bias
     *    max        bias max      , where   bias
     *    max    is the value of the implementation defined constant {@see
     *    GL46::GL_MAX_TEXTURE_LOD_BIAS}. The initial
     *    value is 0.0.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: The texture minifying function is
     *    used whenever the level-of-detail function used when sampling from the
     *    texture determines that the texture should be minified. There are six
     *    defined minifying functions. Two of them
     *    use either the nearest texture elements or a weighted average of
     *    multiple texture elements to compute the
     *    texture value. The other four use mipmaps.   A mipmap is an ordered
     *    set of arrays representing the same image
     *    at progressively lower resolutions. If the texture has dimensions    2
     *    n  × 2 m   , there are     max
     *    &amp;af;  n m   + 1   mipmaps. The first mipmap is the original
     *    texture, with dimensions    2 n  × 2 m   .
     *    Each subsequent mipmap has dimensions    2   k - 1    × 2   l - 1
     *    , where    2 k  × 2 l    are the
     *    dimensions of the previous mipmap, until either    k = 0   or    l = 0
     *     . At that point, subsequent mipmaps
     *    have dimension    1 × 2   l - 1      or    2   k - 1    × 1   until
     *    the final mipmap, which has dimension
     *    1 × 1  . To define the mipmaps, call {@see GL46::glTexImage1D}, {@see
     *    GL46::glTexImage2D},
     *    {@see GL46::glTexImage3D}, {@see GL46::glCopyTexImage1D}, or {@see
     *    GL46::glCopyTexImage2D} with the level
     *    argument indicating the order of the mipmaps. Level 0 is the original
     *    texture; level    max &amp;af;  n m
     *    is the final    1 × 1   mipmap.   $params supplies a function for
     *    minifying the texture as one of the
     *    following:   {@see GL46::GL_NEAREST}   Returns the value of the
     *    texture element that is nearest (in Manhattan
     *    distance) to the specified texture coordinates.     {@see
     *    GL46::GL_LINEAR}   Returns the weighted average of
     *    the four texture elements that are closest to the specified texture
     *    coordinates. These can include items
     *    wrapped or repeated from other parts of a texture, depending on the
     *    values of {@see GL46::GL_TEXTURE_WRAP_S}
     *    and {@see GL46::GL_TEXTURE_WRAP_T}, and on the exact mapping.
     *    {@see GL46::GL_NEAREST_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely matches the size of the pixel
     *    being textured and uses the
     *    {@see GL46::GL_NEAREST} criterion (the texture element closest to the
     *    specified texture coordinates) to
     *    produce a texture value.     {@see GL46::GL_LINEAR_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely
     *    matches the size of the pixel being textured and uses the {@see
     *    GL46::GL_LINEAR} criterion (a weighted average
     *    of the four texture elements that are closest to the specified texture
     *    coordinates) to produce a texture
     *    value.     {@see GL46::GL_NEAREST_MIPMAP_LINEAR}   Chooses the two
     *    mipmaps that most closely match the size of
     *    the pixel being textured and uses the {@see GL46::GL_NEAREST}
     *    criterion (the texture element closest to the
     *    specified texture coordinates ) to produce a texture value from each
     *    mipmap. The final texture value is a
     *    weighted average of those two values.     {@see
     *    GL46::GL_LINEAR_MIPMAP_LINEAR}   Chooses the two mipmaps that
     *    most closely match the size of the pixel being textured and uses the
     *    {@see GL46::GL_LINEAR} criterion (a
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates) to produce a
     *    texture value from each mipmap. The final texture value is a weighted
     *    average of those two values.       As
     *    more texture elements are sampled in the minification process, fewer
     *    aliasing artifacts will be apparent.
     *    While the {@see GL46::GL_NEAREST} and {@see GL46::GL_LINEAR}
     *    minification functions can be faster than the
     *    other four, they sample only one or multiple texture elements to
     *    determine the texture value of the pixel
     *    being rendered and can produce moire patterns or ragged transitions.
     *    The initial value of
     *    {@see GL46::GL_TEXTURE_MIN_FILTER} is {@see
     *    GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: The texture magnification function
     *    is used whenever the level-of-detail function used when sampling from
     *    the
     *    texture determines that the texture should be magified. It sets the
     *    texture magnification function to either
     *    {@see GL46::GL_NEAREST} or {@see GL46::GL_LINEAR} (see below). {@see
     *    GL46::GL_NEAREST} is generally faster
     *    than {@see GL46::GL_LINEAR}, but it can produce textured images with
     *    sharper edges because the transition
     *    between texture elements is not as smooth. The initial value of {@see
     *    GL46::GL_TEXTURE_MAG_FILTER} is
     *    {@see GL46::GL_LINEAR}.   {@see GL46::GL_NEAREST}   Returns the value
     *    of the texture element that is nearest
     *    (in Manhattan distance) to the specified texture coordinates.
     *    {@see GL46::GL_LINEAR}   Returns the
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates. These can
     *    include items wrapped or repeated from other parts of a texture,
     *    depending on the values of
     *    {@see GL46::GL_TEXTURE_WRAP_S} and {@see GL46::GL_TEXTURE_WRAP_T}, and
     *    on the exact mapping.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Sets the minimum level-of-detail
     *    parameter. This floating-point value limits the selection of highest
     *    resolution mipmap (lowest mipmap level). The initial value is -1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Sets the maximum level-of-detail
     *    parameter. This floating-point value limits the selection of the
     *    lowest
     *    resolution mipmap (highest mipmap level). The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Sets the index of the highest
     *    defined mipmap level. This is an integer value. The initial value is
     *    1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Sets the swizzle that will be
     *    applied to the r component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param are {@see GL46::GL_RED}, {@see
     *    GL46::GL_GREEN}, {@see GL46::GL_BLUE},
     *    {@see GL46::GL_ALPHA}, {@see GL46::GL_ZERO} and {@see GL46::GL_ONE}.
     *    If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_RED}, the value for r will be taken from the first
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_GREEN}, the value
     *    for r will be taken from the second
     *    channel of the fetched texel. If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_BLUE}, the value for r
     *    will be taken from the third channel of the fetched texel. If {@see
     *    GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_ALPHA}, the value for r will be taken from the fourth
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ZERO}, the value
     *    for r will be subtituted with 0.0. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ONE}, the value
     *    for r will be subtituted with 1.0. The
     *    initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Sets the swizzle that will be
     *    applied to the g component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Sets the swizzle that will be
     *    applied to the b component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Sets the swizzle that will be
     *    applied to the a component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Sets the swizzles that will be
     *    applied to the r, g, b, and a components of a texel before they are
     *    returned
     *    to the shader. Valid values for $params and their effects are similar
     *    to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}, except that all channels are
     *    specified simultaneously. Setting the value of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors
     *    are generated) to setting the
     *    parameters of each of {@see GL46::GL_TEXTURE_SWIZZLE_R}, {@see
     *    GL46::GL_TEXTURE_SWIZZLE_G},
     *    {@see GL46::GL_TEXTURE_SWIZZLE_B}, and {@see
     *    GL46::GL_TEXTURE_SWIZZLE_A} successively.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Sets the wrap parameter for texture
     *    coordinate s to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. {@see GL46::GL_CLAMP_TO_EDGE}
     *    causes s coordinates to be clamped to the
     *    range       1  2N      1 -    1  2N       , where N is the size of the
     *    texture in the direction of clamping.
     *    {@see GL46::GL_CLAMP_TO_BORDER} evaluates s coordinates in a similar
     *    manner to {@see GL46::GL_CLAMP_TO_EDGE}.
     *    However, in cases where clamping would have occurred in {@see
     *    GL46::GL_CLAMP_TO_EDGE} mode, the fetched texel
     *    data is substituted with the values specified by {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR}. {@see GL46::GL_REPEAT}
     *    causes the integer part of the s coordinate to be ignored; the GL uses
     *    only the fractional part, thereby
     *    creating a repeating pattern. {@see GL46::GL_MIRRORED_REPEAT} causes
     *    the s coordinate to be set to the
     *    fractional part of the texture coordinate if the integer part of s is
     *    even; if the integer part of s is odd,
     *    then the s texture coordinate is set to    1 -  frac &amp;af;  s    ,
     *    where    frac &amp;af;  s    represents
     *    the fractional part of s. {@see GL46::GL_MIRROR_CLAMP_TO_EDGE} causes
     *    the s coordinate to be repeated as for
     *    {@see GL46::GL_MIRRORED_REPEAT} for one repetition of the texture, at
     *    which point the coordinate to be clamped
     *    as in {@see GL46::GL_CLAMP_TO_EDGE}. Initially, {@see
     *    GL46::GL_TEXTURE_WRAP_S} is set to
     *    {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Sets the wrap parameter for texture
     *    coordinate t to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_T} is set to {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Sets the wrap parameter for texture
     *    coordinate r to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_R} is set to {@see GL46::GL_REPEAT}.
     *
     * @see http://docs.gl/gl2/glTexParameter
     * @see http://docs.gl/gl4/glTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param int $param
     * @return void
     */
    public function texParameteri(int $target, int $pname, int $param): void
    {
        $this->info->ffi->glTexParameteri($target, $pname, $param);
    }

    /**
     * {@see GL46::glTexParameter} and {@see GL46::glTextureParameter} assign the value or values in $params to the
     * texture parameter specified as $pname. For {@see GL46::glTexParameter}, $target defines the target texture,
     * either {@see GL46::GL_TEXTURE_1D}, {@see GL46::GL_TEXTURE_1D_ARRAY}, {@see GL46::GL_TEXTURE_2D},
     * {@see GL46::GL_TEXTURE_2D_ARRAY}, {@see GL46::GL_TEXTURE_2D_MULTISAMPLE},
     * {@see GL46::GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@see GL46::GL_TEXTURE_3D}, {@see GL46::GL_TEXTURE_CUBE_MAP},
     * {@see GL46::GL_TEXTURE_CUBE_MAP_ARRAY}, or {@see GL46::GL_TEXTURE_RECTANGLE}. The following symbols are
     * accepted in $pname:
     *
     *  - {@see GL46::GL_DEPTH_STENCIL_TEXTURE_MODE}: Specifies the mode used to
     *    read from depth-stencil format textures. $params must be one of
     *    {@see GL46::GL_DEPTH_COMPONENT} or {@see GL46::GL_STENCIL_INDEX}. If
     *    the depth stencil mode is
     *    {@see GL46::GL_DEPTH_COMPONENT}, then reads from depth-stencil format
     *    textures will return the depth component
     *    of the texel in Rt and the stencil component will be discarded. If the
     *    depth stencil mode is
     *    {@see GL46::GL_STENCIL_INDEX} then the stencil component is returned
     *    in Rt and the depth component is
     *    discarded. The initial value is {@see GL46::GL_DEPTH_COMPONENT}.
     *
     *  - {@see GL46::GL_TEXTURE_BASE_LEVEL}: Specifies the index of the lowest
     *    defined mipmap level. This is an integer value. The initial value is
     *    0.
     *
     *  - {@see GL46::GL_TEXTURE_BORDER_COLOR}: The data in $params specifies
     *    four values that define the border values that should be used for
     *    border
     *    texels. If a texel is sampled from the border of the texture, the
     *    values of
     *    {@see GL46::GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color
     *    to match the texture's internal format
     *    and substituted for the non-existent texel data. If the texture
     *    contains depth components, the first component
     *    of {@see GL46::GL_TEXTURE_BORDER_COLOR} is interpreted as a depth
     *    value. The initial value is     0.0 , 0.0 ,
     *    0.0 , 0.0    .   If the values for {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR} are specified with
     *    {@see GL46::glTexParameterIiv} or {@see GL46::glTexParameterIuiv}, the
     *    values are stored unmodified with an
     *    internal data type of integer. If specified with {@see
     *    GL46::glTexParameteriv}, they are converted to floating
     *    point with the following equation:   f =   2 c + 1    2 b  - 1    . If
     *    specified with
     *    {@see GL46::glTexParameterfv}, they are stored unmodified as
     *    floating-point values.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_FUNC}: Specifies the comparison
     *    operator used when {@see GL46::GL_TEXTURE_COMPARE_MODE} is set to
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
     *     Texture Comparison Function
     *    Computed result        {@see GL46::GL_LEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &lt;=  D t       r
     *    &gt;  D t              {@see GL46::GL_GEQUAL}      result =     1.0
     *    0.0   &amp;it;     r &gt;=  D t       r
     *    &lt;  D t              {@see GL46::GL_LESS}      result =     1.0
     *    0.0   &amp;it;     r &lt;  D t       r
     *    &gt;=  D t              {@see GL46::GL_GREATER}      result =     1.0
     *     0.0   &amp;it;     r &gt;  D t       r
     *    &lt;=  D t              {@see GL46::GL_EQUAL}      result =     1.0
     *    0.0   &amp;it;     r =  D t       r ≠
     *    D t              {@see GL46::GL_NOTEQUAL}      result =     1.0   0.0
     *     &amp;it;     r ≠  D t       r =  D t
     *                 {@see GL46::GL_ALWAYS}      result = 1.0        {@see
     *    GL46::GL_NEVER}      result = 0.0
     *    where r is the current interpolated texture coordinate, and   D t   is
     *    the depth texture value sampled from
     *    the currently bound depth texture. result is assigned to the red
     *    channel.
     *
     *  - {@see GL46::GL_TEXTURE_COMPARE_MODE}: Specifies the texture comparison
     *    mode for currently bound depth textures. That is, a texture whose
     *    internal
     *    format is {@see GL46::GL_DEPTH_COMPONENT_*}; see {@see
     *    GL46::glTexImage2D}) Permissible values are:
     *    {@see GL46::GL_COMPARE_REF_TO_TEXTURE}   Specifies that the
     *    interpolated and clamped r texture coordinate
     *    should be compared to the value in the currently bound depth texture.
     *    See the discussion of
     *    {@see GL46::GL_TEXTURE_COMPARE_FUNC} for details of how the comparison
     *    is evaluated. The result of the
     *    comparison is assigned to the red channel.     {@see GL46::GL_NONE}
     *    Specifies that the red channel should be
     *    assigned the appropriate value from the currently bound depth texture.
     *
     *  - {@see GL46::GL_TEXTURE_LOD_BIAS}: $params specifies a fixed bias value
     *    that is to be added to the level-of-detail parameter for the texture
     *    before texture sampling. The specified value is added to the
     *    shader-supplied bias value (if any) and
     *    subsequently clamped into the implementation-defined range     -  bias
     *    max        bias max      , where   bias
     *    max    is the value of the implementation defined constant {@see
     *    GL46::GL_MAX_TEXTURE_LOD_BIAS}. The initial
     *    value is 0.0.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_FILTER}: The texture minifying function is
     *    used whenever the level-of-detail function used when sampling from the
     *    texture determines that the texture should be minified. There are six
     *    defined minifying functions. Two of them
     *    use either the nearest texture elements or a weighted average of
     *    multiple texture elements to compute the
     *    texture value. The other four use mipmaps.   A mipmap is an ordered
     *    set of arrays representing the same image
     *    at progressively lower resolutions. If the texture has dimensions    2
     *    n  × 2 m   , there are     max
     *    &amp;af;  n m   + 1   mipmaps. The first mipmap is the original
     *    texture, with dimensions    2 n  × 2 m   .
     *    Each subsequent mipmap has dimensions    2   k - 1    × 2   l - 1
     *    , where    2 k  × 2 l    are the
     *    dimensions of the previous mipmap, until either    k = 0   or    l = 0
     *     . At that point, subsequent mipmaps
     *    have dimension    1 × 2   l - 1      or    2   k - 1    × 1   until
     *    the final mipmap, which has dimension
     *    1 × 1  . To define the mipmaps, call {@see GL46::glTexImage1D}, {@see
     *    GL46::glTexImage2D},
     *    {@see GL46::glTexImage3D}, {@see GL46::glCopyTexImage1D}, or {@see
     *    GL46::glCopyTexImage2D} with the level
     *    argument indicating the order of the mipmaps. Level 0 is the original
     *    texture; level    max &amp;af;  n m
     *    is the final    1 × 1   mipmap.   $params supplies a function for
     *    minifying the texture as one of the
     *    following:   {@see GL46::GL_NEAREST}   Returns the value of the
     *    texture element that is nearest (in Manhattan
     *    distance) to the specified texture coordinates.     {@see
     *    GL46::GL_LINEAR}   Returns the weighted average of
     *    the four texture elements that are closest to the specified texture
     *    coordinates. These can include items
     *    wrapped or repeated from other parts of a texture, depending on the
     *    values of {@see GL46::GL_TEXTURE_WRAP_S}
     *    and {@see GL46::GL_TEXTURE_WRAP_T}, and on the exact mapping.
     *    {@see GL46::GL_NEAREST_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely matches the size of the pixel
     *    being textured and uses the
     *    {@see GL46::GL_NEAREST} criterion (the texture element closest to the
     *    specified texture coordinates) to
     *    produce a texture value.     {@see GL46::GL_LINEAR_MIPMAP_NEAREST}
     *    Chooses the mipmap that most closely
     *    matches the size of the pixel being textured and uses the {@see
     *    GL46::GL_LINEAR} criterion (a weighted average
     *    of the four texture elements that are closest to the specified texture
     *    coordinates) to produce a texture
     *    value.     {@see GL46::GL_NEAREST_MIPMAP_LINEAR}   Chooses the two
     *    mipmaps that most closely match the size of
     *    the pixel being textured and uses the {@see GL46::GL_NEAREST}
     *    criterion (the texture element closest to the
     *    specified texture coordinates ) to produce a texture value from each
     *    mipmap. The final texture value is a
     *    weighted average of those two values.     {@see
     *    GL46::GL_LINEAR_MIPMAP_LINEAR}   Chooses the two mipmaps that
     *    most closely match the size of the pixel being textured and uses the
     *    {@see GL46::GL_LINEAR} criterion (a
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates) to produce a
     *    texture value from each mipmap. The final texture value is a weighted
     *    average of those two values.       As
     *    more texture elements are sampled in the minification process, fewer
     *    aliasing artifacts will be apparent.
     *    While the {@see GL46::GL_NEAREST} and {@see GL46::GL_LINEAR}
     *    minification functions can be faster than the
     *    other four, they sample only one or multiple texture elements to
     *    determine the texture value of the pixel
     *    being rendered and can produce moire patterns or ragged transitions.
     *    The initial value of
     *    {@see GL46::GL_TEXTURE_MIN_FILTER} is {@see
     *    GL46::GL_NEAREST_MIPMAP_LINEAR}.
     *
     *  - {@see GL46::GL_TEXTURE_MAG_FILTER}: The texture magnification function
     *    is used whenever the level-of-detail function used when sampling from
     *    the
     *    texture determines that the texture should be magified. It sets the
     *    texture magnification function to either
     *    {@see GL46::GL_NEAREST} or {@see GL46::GL_LINEAR} (see below). {@see
     *    GL46::GL_NEAREST} is generally faster
     *    than {@see GL46::GL_LINEAR}, but it can produce textured images with
     *    sharper edges because the transition
     *    between texture elements is not as smooth. The initial value of {@see
     *    GL46::GL_TEXTURE_MAG_FILTER} is
     *    {@see GL46::GL_LINEAR}.   {@see GL46::GL_NEAREST}   Returns the value
     *    of the texture element that is nearest
     *    (in Manhattan distance) to the specified texture coordinates.
     *    {@see GL46::GL_LINEAR}   Returns the
     *    weighted average of the texture elements that are closest to the
     *    specified texture coordinates. These can
     *    include items wrapped or repeated from other parts of a texture,
     *    depending on the values of
     *    {@see GL46::GL_TEXTURE_WRAP_S} and {@see GL46::GL_TEXTURE_WRAP_T}, and
     *    on the exact mapping.
     *
     *  - {@see GL46::GL_TEXTURE_MIN_LOD}: Sets the minimum level-of-detail
     *    parameter. This floating-point value limits the selection of highest
     *    resolution mipmap (lowest mipmap level). The initial value is -1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LOD}: Sets the maximum level-of-detail
     *    parameter. This floating-point value limits the selection of the
     *    lowest
     *    resolution mipmap (highest mipmap level). The initial value is 1000.
     *
     *  - {@see GL46::GL_TEXTURE_MAX_LEVEL}: Sets the index of the highest
     *    defined mipmap level. This is an integer value. The initial value is
     *    1000.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_R}: Sets the swizzle that will be
     *    applied to the r component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param are {@see GL46::GL_RED}, {@see
     *    GL46::GL_GREEN}, {@see GL46::GL_BLUE},
     *    {@see GL46::GL_ALPHA}, {@see GL46::GL_ZERO} and {@see GL46::GL_ONE}.
     *    If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_RED}, the value for r will be taken from the first
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_GREEN}, the value
     *    for r will be taken from the second
     *    channel of the fetched texel. If {@see GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_BLUE}, the value for r
     *    will be taken from the third channel of the fetched texel. If {@see
     *    GL46::GL_TEXTURE_SWIZZLE_R} is
     *    {@see GL46::GL_ALPHA}, the value for r will be taken from the fourth
     *    channel of the fetched texel. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ZERO}, the value
     *    for r will be subtituted with 0.0. If
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R} is {@see GL46::GL_ONE}, the value
     *    for r will be subtituted with 1.0. The
     *    initial value is {@see GL46::GL_RED}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_G}: Sets the swizzle that will be
     *    applied to the g component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_GREEN}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_B}: Sets the swizzle that will be
     *    applied to the b component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_BLUE}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_A}: Sets the swizzle that will be
     *    applied to the a component of a texel before it is returned to the
     *    shader.
     *    Valid values for $param and their effects are similar to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}. The
     *    initial value is {@see GL46::GL_ALPHA}.
     *
     *  - {@see GL46::GL_TEXTURE_SWIZZLE_RGBA}: Sets the swizzles that will be
     *    applied to the r, g, b, and a components of a texel before they are
     *    returned
     *    to the shader. Valid values for $params and their effects are similar
     *    to those of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_R}, except that all channels are
     *    specified simultaneously. Setting the value of
     *    {@see GL46::GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors
     *    are generated) to setting the
     *    parameters of each of {@see GL46::GL_TEXTURE_SWIZZLE_R}, {@see
     *    GL46::GL_TEXTURE_SWIZZLE_G},
     *    {@see GL46::GL_TEXTURE_SWIZZLE_B}, and {@see
     *    GL46::GL_TEXTURE_SWIZZLE_A} successively.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_S}: Sets the wrap parameter for texture
     *    coordinate s to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. {@see GL46::GL_CLAMP_TO_EDGE}
     *    causes s coordinates to be clamped to the
     *    range       1  2N      1 -    1  2N       , where N is the size of the
     *    texture in the direction of clamping.
     *    {@see GL46::GL_CLAMP_TO_BORDER} evaluates s coordinates in a similar
     *    manner to {@see GL46::GL_CLAMP_TO_EDGE}.
     *    However, in cases where clamping would have occurred in {@see
     *    GL46::GL_CLAMP_TO_EDGE} mode, the fetched texel
     *    data is substituted with the values specified by {@see
     *    GL46::GL_TEXTURE_BORDER_COLOR}. {@see GL46::GL_REPEAT}
     *    causes the integer part of the s coordinate to be ignored; the GL uses
     *    only the fractional part, thereby
     *    creating a repeating pattern. {@see GL46::GL_MIRRORED_REPEAT} causes
     *    the s coordinate to be set to the
     *    fractional part of the texture coordinate if the integer part of s is
     *    even; if the integer part of s is odd,
     *    then the s texture coordinate is set to    1 -  frac &amp;af;  s    ,
     *    where    frac &amp;af;  s    represents
     *    the fractional part of s. {@see GL46::GL_MIRROR_CLAMP_TO_EDGE} causes
     *    the s coordinate to be repeated as for
     *    {@see GL46::GL_MIRRORED_REPEAT} for one repetition of the texture, at
     *    which point the coordinate to be clamped
     *    as in {@see GL46::GL_CLAMP_TO_EDGE}. Initially, {@see
     *    GL46::GL_TEXTURE_WRAP_S} is set to
     *    {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_T}: Sets the wrap parameter for texture
     *    coordinate t to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_T} is set to {@see GL46::GL_REPEAT}.
     *
     *  - {@see GL46::GL_TEXTURE_WRAP_R}: Sets the wrap parameter for texture
     *    coordinate r to either {@see GL46::GL_CLAMP_TO_EDGE},
     *    {@see GL46::GL_CLAMP_TO_BORDER}, {@see GL46::GL_MIRRORED_REPEAT},
     *    {@see GL46::GL_REPEAT}, or
     *    {@see GL46::GL_MIRROR_CLAMP_TO_EDGE}. See the discussion under {@see
     *    GL46::GL_TEXTURE_WRAP_S}. Initially,
     *    {@see GL46::GL_TEXTURE_WRAP_R} is set to {@see GL46::GL_REPEAT}.
     *
     * @see http://docs.gl/gl2/glTexParameter
     * @see http://docs.gl/gl4/glTexParameter
     * @since 1.1
     * @param int $target
     * @param int $pname
     * @param \FFI\CData|null $params
     * @return void
     */
    public function texParameteriv(int $target, int $pname, ?\FFI\CData $params): void
    {
        $this->info->ffi->glTexParameteriv($target, $pname, $params);
    }

    /**
     * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is
     * enabled. To enable or disable one-dimensional texturing, call {@see GL46::glEnable} and
     * {@see GL46::glDisable} with argument {@see GL46::GL_TEXTURE_1D}.
     *
     * {@see GL46::glTexSubImage1D} and {@see GL46::glTextureSubImage1D} redefine a contiguous subregion of an
     * existing one-dimensional texture image. The texels referenced by $pixels replace the portion of the existing
     * texture array with x indices $xoffset and    xoffset + width - 1  , inclusive. This region may not include any
     * texels outside the range of the texture array as it was originally specified. It is not an error to specify a
     * subtexture with width of 0, but such a specification has no effect.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture image is specified, $pixels is treated as a byte offset into the
     * buffer object's data store.
     *
     * @see http://docs.gl/gl2/glTexSubImage1D
     * @see http://docs.gl/gl4/glTexSubImage1D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $xoffset
     * @param int $width
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function texSubImage1D(int $target, int $level, int $xoffset, int $width, int $format, int $type, ?\FFI\CData $pixels): void
    {
        $this->info->ffi->glTexSubImage1D($target, $level, $xoffset, $width, $format, $type, $pixels);
    }

    /**
     * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is
     * enabled.
     *
     * {@see GL46::glTexSubImage2D} and {@see GL46::glTextureSubImage2D} redefine a contiguous subregion of an
     * existing two-dimensional or one-dimensional array texture image. The texels referenced by $pixels replace the
     * portion of the existing texture array with x indices $xoffset and    xoffset + width - 1  , inclusive, and y
     * indices $yoffset and    yoffset + height - 1  , inclusive. This region may not include any texels outside the
     * range of the texture array as it was originally specified. It is not an error to specify a subtexture with
     * zero width or height, but such a specification has no effect.
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_PIXEL_UNPACK_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a texture image is specified, $pixels is treated as a byte offset into the
     * buffer object's data store.
     *
     * @see http://docs.gl/gl2/glTexSubImage2D
     * @see http://docs.gl/gl4/glTexSubImage2D
     * @since 1.1
     * @param int $target
     * @param int $level
     * @param int $xoffset
     * @param int $yoffset
     * @param int $width
     * @param int $height
     * @param int $format
     * @param int $type
     * @param \FFI\CData|null $pixels
     * @return void
     */
    public function texSubImage2D(
        int $target,
        int $level,
        int $xoffset,
        int $yoffset,
        int $width,
        int $height,
        int $format,
        int $type,
        ?\FFI\CData $pixels
    ): void {
        $this->info->ffi->glTexSubImage2D($target, $level, $xoffset, $yoffset, $width, $height, $format, $type, $pixels);
    }

    /**
     * {@see GL46::glTranslate} produces a translation by    x y z  . The current matrix (see
     * {@see GL46::glMatrixMode}) is multiplied by this translation matrix, with the product replacing the current
     * matrix, as if {@see GL46::glMultMatrix} were called with the following matrix for its argument:
     *
     *       1   0   0   x     0   1   0   y     0   0   1   z     0   0   0   1
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * a call to {@see GL46::glTranslate} are translated.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the untranslated coordinate
     * system.
     *
     * @see http://docs.gl/gl2/glTranslate
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function translated(float $x, float $y, float $z): void
    {
        $this->info->ffi->glTranslated($x, $y, $z);
    }

    /**
     * {@see GL46::glTranslate} produces a translation by    x y z  . The current matrix (see
     * {@see GL46::glMatrixMode}) is multiplied by this translation matrix, with the product replacing the current
     * matrix, as if {@see GL46::glMultMatrix} were called with the following matrix for its argument:
     *
     *       1   0   0   x     0   1   0   y     0   0   1   z     0   0   0   1
     *
     * If the matrix mode is either {@see GL46::GL_MODELVIEW} or {@see GL46::GL_PROJECTION}, all objects drawn after
     * a call to {@see GL46::glTranslate} are translated.
     *
     * Use {@see GL46::glPushMatrix} and {@see GL46::glPopMatrix} to save and restore the untranslated coordinate
     * system.
     *
     * @see http://docs.gl/gl2/glTranslate
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function translatef(float $x, float $y, float $z): void
    {
        $this->info->ffi->glTranslatef($x, $y, $z);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @return void
     */
    public function vertex2d(float $x, float $y): void
    {
        $this->info->ffi->glVertex2d($x, $y);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex2dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex2dv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @return void
     */
    public function vertex2f(float $x, float $y): void
    {
        $this->info->ffi->glVertex2f($x, $y);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex2fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex2fv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @return void
     */
    public function vertex2i(int $x, int $y): void
    {
        $this->info->ffi->glVertex2i($x, $y);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex2iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex2iv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @return void
     */
    public function vertex2s(int $x, int $y): void
    {
        $this->info->ffi->glVertex2s($x, $y);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex2sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex2sv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function vertex3d(float $x, float $y, float $z): void
    {
        $this->info->ffi->glVertex3d($x, $y, $z);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex3dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex3dv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @return void
     */
    public function vertex3f(float $x, float $y, float $z): void
    {
        $this->info->ffi->glVertex3f($x, $y, $z);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex3fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex3fv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @return void
     */
    public function vertex3i(int $x, int $y, int $z): void
    {
        $this->info->ffi->glVertex3i($x, $y, $z);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex3iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex3iv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @return void
     */
    public function vertex3s(int $x, int $y, int $z): void
    {
        $this->info->ffi->glVertex3s($x, $y, $z);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex3sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex3sv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @param float $w
     * @return void
     */
    public function vertex4d(float $x, float $y, float $z, float $w): void
    {
        $this->info->ffi->glVertex4d($x, $y, $z, $w);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex4dv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex4dv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param float $x
     * @param float $y
     * @param float $z
     * @param float $w
     * @return void
     */
    public function vertex4f(float $x, float $y, float $z, float $w): void
    {
        $this->info->ffi->glVertex4f($x, $y, $z, $w);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex4fv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex4fv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @param int $w
     * @return void
     */
    public function vertex4i(int $x, int $y, int $z, int $w): void
    {
        $this->info->ffi->glVertex4i($x, $y, $z, $w);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex4iv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex4iv($v);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $z
     * @param int $w
     * @return void
     */
    public function vertex4s(int $x, int $y, int $z, int $w): void
    {
        $this->info->ffi->glVertex4s($x, $y, $z, $w);
    }

    /**
     * {@see GL46::glVertex} commands are used within {@see GL46::glBegin}/{@see GL46::glEnd} pairs to specify point,
     * line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated
     * with the vertex when {@see GL46::glVertex} is called.
     *
     * When only x and y are specified, z defaults to 0 and w defaults to 1. When x, y, and z are specified, w
     * defaults to 1.
     *
     * @see http://docs.gl/gl2/glVertex
     * @since 1.1
     * @param \FFI\CData|null $v
     * @return void
     */
    public function vertex4sv(?\FFI\CData $v): void
    {
        $this->info->ffi->glVertex4sv($v);
    }

    /**
     * {@see GL46::glVertexPointer} specifies the location and data format of an array of vertex coordinates to use
     * when rendering. $size specifies the number of coordinates per vertex, and must be 2, 3, or 4. $type specifies
     * the data type of each coordinate, and $stride specifies the byte stride from one vertex to the next, allowing
     * vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage
     * may be more efficient on some implementations; see {@see GL46::glInterleavedArrays}.)
     *
     * If a non-zero named buffer object is bound to the {@see GL46::GL_ARRAY_BUFFER} target (see
     * {@see GL46::glBindBuffer}) while a vertex array is specified, $pointer is treated as a byte offset into the
     * buffer object's data store. Also, the buffer object binding ({@see GL46::GL_ARRAY_BUFFER_BINDING}) is saved as
     * vertex array client-side state ({@see GL46::GL_VERTEX_ARRAY_BUFFER_BINDING}).
     *
     * When a vertex array is specified, $size, $type, $stride, and $pointer are saved as client-side state, in
     * addition to the current vertex array buffer object binding.
     *
     * To enable and disable the vertex array, call {@see GL46::glEnableClientState} and
     * {@see GL46::glDisableClientState} with the argument {@see GL46::GL_VERTEX_ARRAY}. If enabled, the vertex array
     * is used when {@see GL46::glArrayElement}, {@see GL46::glDrawArrays}, {@see GL46::glMultiDrawArrays},
     * {@see GL46::glDrawElements}, {@see GL46::glMultiDrawElements}, or {@see GL46::glDrawRangeElements} is called.
     *
     * @see http://docs.gl/gl2/glVertexPointer
     * @since 1.1
     * @param int $size
     * @param int $type
     * @param int $stride
     * @param \FFI\CData|null $pointer
     * @return void
     */
    public function vertexPointer(int $size, int $type, int $stride, ?\FFI\CData $pointer): void
    {
        $this->info->ffi->glVertexPointer($size, $type, $stride, $pointer);
    }

    /**
     * {@see GL46::glViewport} specifies the affine transformation of x and y from normalized device coordinates to
     * window coordinates. Let    x nd  y nd    be normalized device coordinates. Then the window coordinates    x w
     * y w    are computed as follows:
     *
     *    x w  =    x nd  + 1   &amp;it;   width 2   + x
     *
     *    y w  =    y nd  + 1   &amp;it;   height 2   + y
     *
     * Viewport width and height are silently clamped to a range that depends on the implementation. To query this
     * range, call {@see GL46::glGet} with argument {@see GL46::GL_MAX_VIEWPORT_DIMS}.
     *
     * @see http://docs.gl/gl2/glViewport
     * @see http://docs.gl/gl4/glViewport
     * @since 1.1
     * @param int $x
     * @param int $y
     * @param int $width
     * @param int $height
     * @return void
     */
    public function viewport(int $x, int $y, int $width, int $height): void
    {
        $this->info->ffi->glViewport($x, $y, $width, $height);
    }
}
